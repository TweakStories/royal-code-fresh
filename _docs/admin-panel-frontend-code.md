--- START OF FILE apps/admin-panel/environments/environment.prod.ts ---
// environment.prod.ts

export const environment = {
  production: true,
  apiUrl: 'https://jouw-productie-api.com/api',
  mediaUpload: {
    maxFiles: 4,
    allowedImageTypes: ['image/jpeg', 'image/png', 'image/webp'],
    maxSizeMb: 10
  }
};
--- END OF FILE ---

--- START OF FILE apps/admin-panel/environments/environment.ts ---
// environment.ts
export const environment = {
  production: false,
  backendUrl: 'https://localhost:5001/api',
  apiUrl:'/api',
  mediaUpload: {
    maxFiles: 50,
    allowedImageTypes: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
    maxSizeMb: 10
  }
};
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/app.component.html ---
<router-outlet></router-outlet>
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/app.component.scss ---

--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/app.component.ts ---
import { Component } from '@angular/core';
import { RouterModule } from '@angular/router';

@Component({
  imports: [RouterModule],
  selector: 'admin-root',
  templateUrl: './app.component.html',
  styleUrl: './app.component.scss',
})
export class AppComponent {
  protected title = 'admin-panel';
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/app.config.server.ts ---
import { provideServerRendering } from '@angular/ssr';
import { mergeApplicationConfig, ApplicationConfig } from '@angular/core';
import { appConfig } from './app.config';
import { provideServerTransferState } from '@angular/platform-browser';

const serverConfig: ApplicationConfig = {
  providers: [
    provideServerRendering(),
    provideServerTransferState()
  ],
};

export const config = mergeApplicationConfig(appConfig, serverConfig);
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/app.config.ts ---
/**
 * @file app.config.ts (Admin Panel) - DEFINITIVE CORRECTED VERSION
 * @Version 6.0.2 (Removed Eager Character Progression Feature)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description
 *   Fixed critical import errors where ActionReducer and ActionReducerMap
 *   were incorrectly imported from @angular/core instead of @ngrx/store.
 *   Removed eager loading of CharacterProgressionFeature to improve performance.
 */

// ===== ANGULAR CORE IMPORTS =====
import { 
  ApplicationConfig, 
  provideZoneChangeDetection, 
  isDevMode, 
  inject, 
  APP_INITIALIZER,
  PLATFORM_ID
} from '@angular/core';
import { provideRouter, withComponentInputBinding, withViewTransitions, withInMemoryScrolling } from '@angular/router';
import { provideClientHydration } from '@angular/platform-browser';
import { provideAnimationsAsync } from '@angular/platform-browser/animations/async';
import { isPlatformBrowser } from '@angular/common';

// ===== HTTP & INTERCEPTORS =====
import { provideHttpClient, withInterceptors, HttpInterceptorFn, HttpRequest } from '@angular/common/http';
import { AuthInterceptor } from '@royal-code/auth/data-access';
import { globalErrorInterceptor } from '@royal-code/core/error-handling';
import { etagInterceptor } from '@royal-code/core/http';

// ===== NGRX STORE =====
import { 
  MetaReducer, 
  provideStore, 
  Store, 
  ActionReducer, 
  ActionReducerMap 
} from '@ngrx/store';
import { provideEffects } from '@ngrx/effects';
import { provideRouterStore, routerReducer, RouterReducerState } from '@ngrx/router-store';
import { provideStoreDevtools } from '@ngrx/store-devtools';
import { localStorageSync } from 'ngrx-store-localstorage';
import { RouterStateUrl } from '@royal-code/core/routing'; // Import RouterStateUrl

// ===== STORE FEATURES =====
import { AuthFacade, provideAuthFeature } from '@royal-code/store/auth';
import { provideUserFeature } from '@royal-code/store/user';
import { provideErrorFeature } from '@royal-code/store/error';
import { provideThemeFeature, APP_THEME_DEFAULTS, AppThemeDefaults } from '@royal-code/store/theme';
import { provideNavigationFeature } from '@royal-code/core/navigations/state';
// << DE FIX: provideCharacterProgressionFeature is verwijderd voor lazy loading >>
// import { provideCharacterProgressionFeature } from '@royal-code/features/character-progression';
import { provideProductsFeature, AbstractProductApiService } from '@royal-code/features/products/core';
import { provideCartFeature, AbstractCartApiService } from '@royal-code/features/cart/core';
import { provideOrdersFeature, AbstractOrderApiService } from '@royal-code/features/orders/core';
import { provideChatFeature, AbstractChatApiService } from '@royal-code/features/chat/core';
import { provideReviewsFeature, AbstractReviewsApiService } from '@royal-code/features/reviews/core';
import { provideMediaFeature, AbstractMediaApiService } from '@royal-code/features/media/core';
import { provideAdminProductsFeature } from '@royal-code/features/admin-products/core';
import { provideAdminUsersFeature } from '@royal-code/features/admin-users/core';
import { provideAdminOrdersFeature } from '@royal-code/features/admin-orders/core';
import { provideAdminVariantsFeature } from '@royal-code/features/admin-variants/core';
import { AbstractAdminDashboardApiService, provideAdminDashboardFeature } from '@royal-code/features/admin-dashboard/core';
import { PlushieAdminDashboardApiService } from '@royal-code/features/admin-dashboard/data-access'; 
import { DroneshopAccountApiService } from '@royal-code/features/account/data-access-droneshop';

// ===== I18N =====
import { provideTranslateService, TranslateService } from '@ngx-translate/core';
import { provideTranslateHttpLoader } from '@ngx-translate/http-loader';

// ===== CORE SERVICES =====
import { APP_CONFIG } from '@royal-code/core/config';
import { LOGGER_CONFIG, LogLevel } from '@royal-code/core/logging';
import { StorageService } from '@royal-code/core/storage';

// ===== API SERVICE IMPLEMENTATIONS (Adjust as needed for Admin Panel) =====
import { DroneshopProductApiService } from '@royal-code/features/products/data-access-droneshop';
import { PlushieCartApiService } from '@royal-code/features/cart/data-access-plushie';
import { PlushieReviewsApiService } from '@royal-code/features/reviews/data-access-plushie';
import { PlushieChatApiService } from '@royal-code/features/chat/data-access-plushie';
import { PlushieMediaApiService } from '@royal-code/features/media/data-access-plushie';
import { PlushieOrderApiService } from '@royal-code/features/orders/data-access-plushie';

// ===== ICONS =====
import { BarChart, CheckCircle, Edit, HelpCircle, Home, LUCIDE_ICONS, LucideIconProvider, MoreVertical, UserCircle, XCircle, icons } from 'lucide-angular';

// ===== ENVIRONMENT & ROUTES =====
import { environment } from '../../environments/environment';
import { appRoutes } from './app.routes';
import { AbstractAccountApiService, provideAccountFeature } from '@royal-code/features/account/core';

// ========================================
// ROOT STATE & REDUCERS
// ========================================
// DE FIX: Definieer de root state en reducers lokaal, en beperk deze tot ENKEL de router.
// Alle andere state slices worden via hun `provide...Feature` functies geregistreerd.
export interface RootState {
  router: RouterReducerState<RouterStateUrl>;
}

const rootReducers: ActionReducerMap<RootState> = {
  router: routerReducer,
};

// ========================================
// META REDUCERS (PLATFORM-AWARE)
// ========================================
// DE FIX: Maak de meta-reducer platform-aware om SSR hydration problemen te voorkomen.
export function localStorageSyncFactory(platformId: object): MetaReducer<any> {
  return function localStorageSyncReducer(reducer: ActionReducer<any>): ActionReducer<any> {
    if (isPlatformBrowser(platformId)) {
      return localStorageSync({
        keys: ['theme', 'user', 'cart', 'adminUiSettings', 'adminProducts', 'adminUsers'],
        rehydrate: true,
        storageKeySerializer: (key) => `AdminPanelApp_${key}`,
      })(reducer);
    }
    return reducer;
  };
}

// ========================================
// INTERCEPTORS
// ========================================
export const authInterceptorFn: HttpInterceptorFn = (req, next) => {
  const handlerAdapter = { handle: (request: HttpRequest<any>) => next(request) };
  return inject(AuthInterceptor).intercept(req, handlerAdapter);
};

// ========================================
// INITIALIZERS
// ========================================
export function initializeI18nFactory(translate: TranslateService, storage: StorageService): () => Promise<void> {
  return () => {
    const defaultLang = 'en';
    const supportedLangs = ['en', 'nl'];
    const storedLang = storage.getItem<string>('AdminPanelApp_language');
    const browserLang = translate.getBrowserLang();
    const langToUse = (storedLang && supportedLangs.includes(storedLang))
      ? storedLang
      : (browserLang && supportedLangs.includes(browserLang)) ? browserLang : defaultLang;
    translate.setDefaultLang(defaultLang);
    return translate.use(langToUse).toPromise().then(() => console.log(`[APP_INITIALIZER] i18n initialized to: ${langToUse}`));
  };
}

export function initializeAuthFactory(authFacade: AuthFacade): () => void {
  return () => authFacade.checkAuthStatus();
}

// ========================================
// THEME CONFIGURATION
// ========================================
const ADMIN_PANEL_THEME_DEFAULTS: AppThemeDefaults = {
  defaultThemeName: 'oceanicFlow',
  defaultDarkMode: true,
};

// ========================================
// APPLICATION CONFIGURATION
// ========================================
export const appConfig: ApplicationConfig = {
  providers: [
    // ===== ANGULAR CORE =====
    provideZoneChangeDetection({ eventCoalescing: true }),
    provideAnimationsAsync(),
    // provideClientHydration(),

    // ===== ROUTING =====
    provideRouter(appRoutes, 
      withComponentInputBinding(), 
      withViewTransitions(), 
      withInMemoryScrolling({ 
        scrollPositionRestoration: 'enabled', 
        anchorScrolling: 'enabled' 
      })
    ),

    // ===== HTTP =====
    provideHttpClient(withInterceptors([authInterceptorFn, etagInterceptor, globalErrorInterceptor])),
    AuthInterceptor,
    StorageService,

    // ===== NGRX STORE =====
    provideStore(rootReducers, { // DE FIX: Gebruik de lokaal gedefinieerde, minimale rootReducers
      runtimeChecks: {
        strictStateImmutability: true,
        strictActionImmutability: true,
        strictStateSerializability: true,
        strictActionSerializability: true,
        strictActionWithinNgZone: true,
        strictActionTypeUniqueness: true, // Zet op true voor betere-praktijken
      }
    }),
    {
      provide: 'META_REDUCERS',
      useFactory: localStorageSyncFactory,
      deps: [PLATFORM_ID],
      multi: true
    },
    provideEffects([]),
    provideRouterStore(),
    
    // ===== DEV TOOLS (Development Only) =====
    isDevMode() ? provideStoreDevtools({ name: 'Admin Panel App', maxAge: 25, logOnly: false }) : [],

    // ===== STORE FEATURES (Dit is nu de enige manier waarop features worden geregistreerd) =====
    provideAuthFeature(),
    provideUserFeature(),
    provideErrorFeature(),
    provideThemeFeature(),
    provideNavigationFeature(),
    // << DE FIX: CharacterProgressionFeature is verwijderd uit eager providers >>
    // provideCharacterProgressionFeature(),
    provideProductsFeature(),
    provideCartFeature(),
    provideOrdersFeature(),
    provideChatFeature(),
    provideReviewsFeature(),
    provideMediaFeature(),
    provideAdminProductsFeature(),
    provideAdminUsersFeature(),
    provideAdminOrdersFeature(),
    provideAdminVariantsFeature(),
    provideAdminDashboardFeature(),
    provideAccountFeature(),

    // ===== APP INITIALIZERS =====
    { provide: APP_INITIALIZER, useFactory: initializeI18nFactory, multi: true, deps: [TranslateService, StorageService] },
    { provide: APP_INITIALIZER, useFactory: initializeAuthFactory, multi: true, deps: [AuthFacade] },

    // ===== API SERVICE IMPLEMENTATIONS (Adjust as needed for Admin Panel) =====
    { provide: AbstractProductApiService, useClass: DroneshopProductApiService },
    { provide: AbstractCartApiService, useClass: PlushieCartApiService },
    { provide: AbstractReviewsApiService, useClass: PlushieReviewsApiService },
    { provide: AbstractChatApiService, useClass: PlushieChatApiService },
    { provide: AbstractMediaApiService, useClass: PlushieMediaApiService },
    { provide: AbstractOrderApiService, useClass: PlushieOrderApiService },
    { provide: AbstractAdminDashboardApiService, useClass: PlushieAdminDashboardApiService },
    { provide: AbstractAccountApiService, useClass: DroneshopAccountApiService },


    // ===== I18N =====
    provideTranslateService({ lang: 'en', fallbackLang: 'en', loader: provideTranslateHttpLoader({ prefix: './assets/i18n/', suffix: '.json' }) }),

    // ===== CONFIGURATION =====
    { provide: APP_CONFIG, useValue: environment },
    { provide: LOGGER_CONFIG, useValue: { level: isDevMode() ? LogLevel.DEBUG : LogLevel.INFO, appName: 'AdminPanel' } },
    { provide: APP_THEME_DEFAULTS, useValue: ADMIN_PANEL_THEME_DEFAULTS },

    // ===== ICONS =====
    { provide: LUCIDE_ICONS, multi: true, useValue: new LucideIconProvider({...icons, Edit, Home, UserCircle, 
      BarChart, MoreVertical, XCircle, CheckCircle, HelpCircle, }) },
  ],
};
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/app.routes.ts ---
/**
 * @file app.routes.ts (Admin Panel)
 * @Version 1.7.0 (Added Swagger Test Page Route)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Defines the main application routes for the Admin Panel, now including a
 *              route for the new Swagger simulation test page.
 */
import { Routes } from '@angular/router';
import { AdminShellComponent } from './components/admin-shell/admin-shell.component';
import { authGuard } from '@royal-code/features/authentication';
import { i18nInitResolver } from '@royal-code/shared/utils';
import { provideEffects } from '@ngrx/effects';
import { provideState } from '@ngrx/store';
import { adminProductsFeature, AdminProductsEffects } from '@royal-code/features/admin-products/core';
import { AdminProductApiService } from '@royal-code/features/admin-products/data-access';
import { provideAdminOrdersFeature } from '@royal-code/features/admin-orders/core';
import { AbstractAdminOrderApiService } from '@royal-code/features/admin-orders/core';
import { AdminOrderApiService } from '@royal-code/features/admin-orders/data-access';
import { provideAdminVariantsFeature } from '@royal-code/features/admin-variants/core';
import { provideAdminUsersFeature } from '@royal-code/features/admin-users/core';

export const appRoutes: Routes = [
  {
    path: '',
    component: AdminShellComponent,
    canActivate: [authGuard],
    children: [
      { path: '', redirectTo: 'dashboard', pathMatch: 'full' },
      {
        path: 'dashboard',
        loadComponent: () => import('./pages/dashboard-page/dashboard-page.component').then(m => m.DashboardPageComponent),
        data: { labelKey: 'admin.dashboard.title' }
      },
      // ... (andere routes blijven ongewijzigd)
      {
        path: 'products',
        children: [
          { path: '', pathMatch: 'full', loadComponent: () => import('./pages/product-management-page/product-management-page.component').then(m => m.ProductManagementPageComponent) },
          { path: 'new', loadComponent: () => import('./pages/product-create-page/product-create-page.component').then(m => m.ProductCreatePageComponent), data: { labelKey: 'admin.products.createTitle' } },
          { path: ':id', loadComponent: () => import('./pages/product-edit-page/product-edit-page.component').then(m => m.ProductEditPageComponent), data: { labelKey: 'admin.products.editTitle' } },
        ],
        data: { labelKey: 'admin.products.title' }
      },
      {
        path: 'orders',
        providers: [ provideAdminOrdersFeature(), { provide: AbstractAdminOrderApiService, useClass: AdminOrderApiService } ],
        children: [
          { path: '', pathMatch: 'full', loadComponent: () => import('./pages/order-management-page/order-management-page.component').then(m => m.OrderManagementPageComponent) },
          { path: 'new', loadComponent: () => import('./pages/order-create-page/order-create-page.component').then(m => m.OrderCreatePageComponent), data: { labelKey: 'admin.orders.createTitle' } },
          { path: ':id', loadComponent: () => import('./pages/order-detail-page/order-detail-page.component').then(m => m.OrderDetailPageComponent), data: { labelKey: 'admin.orders.detail.title' } },
        ],
        data: { labelKey: 'admin.orders.title' },
      },
      { path: 'reviews', loadChildren: () => import('@royal-code/features/admin-reviews/ui').then(m => m.adminReviewsRoutes), data: { labelKey: 'admin.reviews.title' } },
      { path: 'variants', loadComponent: () => import('./pages/variant-management-page/variant-management-page.component').then(m => m.VariantManagementPageComponent), providers: [ provideAdminVariantsFeature() ], data: { labelKey: 'admin.variants.title' } },
      {
        path: 'users',
        providers: [ provideAdminUsersFeature() ],
        data: { labelKey: 'admin.users.title' },
        children: [
           { path: '', pathMatch: 'full', loadComponent: () => import('./pages/user-management-page/user-management-page.component').then(m => m.UserManagementPageComponent), data: { labelKey: 'admin.users.management.title' } },
           { path: 'roles', loadComponent: () => import('./pages/role-management-page/role-management-page.component').then(m => m.RoleManagementPageComponent), data: { labelKey: 'admin.roles.manageRoles' } },
           { path: 'new', loadComponent: () => import('./pages/user-create-page/user-create-page.component').then(m => m.UserCreatePageComponent), data: { labelKey: 'admin.users.createTitle' } },
           { path: ':id', loadComponent: () => import('./pages/user-edit-page/user-edit-page.component').then(m => m.UserEditPageComponent), data: { labelKey: 'admin.users.editTitle' } },
        ],
      },
      {
        path: 'settings',
        loadComponent: () => import('./pages/settings-page/settings-page.component').then(m => m.SettingsPageComponent),
        data: { labelKey: 'admin.settings.title' },
        children: [
          { path: '', redirectTo: 'general', pathMatch: 'full' },
          { path: 'general', loadComponent: () => import('./components/settings-general/settings-general.component').then(m => m.SettingsGeneralComponent) },
          { path: 'products', loadComponent: () => import('./components/settings-products/settings-products.component').then(m => m.SettingsProductsComponent) },
          { path: 'orders', loadComponent: () => import('./components/settings-orders/settings-orders.component').then(m => m.SettingsOrdersComponent) },
          { path: 'security', loadComponent: () => import('./components/settings-security/settings-security.component').then(m => m.SettingsSecurityComponent) },
          { path: 'compliance', loadComponent: () => import('./components/settings-compliance/settings-compliance.component').then(m => m.SettingsComplianceComponent) },
          { path: 'marketing', loadComponent: () => import('./components/settings-marketing/settings-marketing.component').then(m => m.SettingsMarketingComponent) },
          { path: 'system', loadComponent: () => import('./components/settings-system/settings-system.component').then(m => m.SettingsSystemComponent) },
          { path: 'admin-panel', loadComponent: () => import('./components/settings-admin-panel/settings-admin-panel.component').then(m => m.SettingsAdminPanelComponent) },
          { path: 'governance', loadComponent: () => import('./components/settings-governance/settings-governance.component').then(m => m.SettingsGovernanceComponent) },
          { path: 'deployment', loadComponent: () => import('./components/settings-deployment/settings-deployment.component').then(m => m.SettingsDeploymentComponent) },
        ]
      },
      // << DE FIX: Nieuwe Swagger Test Pagina route >>
      {
        path: 'swagger-test',
        loadComponent: () => import('./pages/swagger-test-page/swagger-test-page.component').then(m => m.SwaggerTestPageComponent),
        data: { labelKey: 'Swagger Test' }
      },
    ]
  },
  {
    path: 'login',
    loadComponent: () => import('@royal-code/features/authentication').then(m => m.LoginComponent)
  },
  { path: '**', redirectTo: 'dashboard' }
];
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/admin-header/admin-header.component.ts ---
/**
 * @file admin-header.component.ts (Admin Panel)
 * @Version 1.1.0
 * @Author Royal-Code MonorepoAppDevAI & User
 * @Date 2025-07-20
 * @Description Header component for the admin panel, now with theme switcher and example action dropdowns.
 */
import { Component, ChangeDetectionStrategy, Signal, inject } from '@angular/core';
import { RouterModule } from '@angular/router';
import { AuthFacade } from '@royal-code/store/auth';
import { AppIcon } from '@royal-code/shared/domain';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiIconComponent } from '@royal-code/ui/icon';
import { UiDropdownComponent } from '@royal-code/ui/dropdown';
import { UiImageComponent } from '@royal-code/ui/media';
import { TranslateModule } from '@ngx-translate/core';
import { ExpandingThemeSelectorComponent, UiThemeSwitcherComponent } from '@royal-code/ui/theme-switcher';
import { Profile } from '@royal-code/shared/domain';

@Component({
  selector: 'admin-header',
  standalone: true,
  imports: [RouterModule, TranslateModule, UiButtonComponent, UiIconComponent, UiDropdownComponent, UiImageComponent, ExpandingThemeSelectorComponent, UiThemeSwitcherComponent],
  template: `
    <header class="h-16 flex-shrink-0 bg-surface flex items-center justify-between px-6 border-b border-border">
      <!-- Left side can be used for search or breadcrumbs later -->
      <div></div>

      <!-- Right side controls -->
      <div class="flex items-center gap-3">
        <!-- THEME SWITCHERS -->
        <royal-code-expanding-theme-selector />
        <royal-code-ui-theme-switcher />

        <!-- Voorbeeld Dropdown 1: Rapporten -->
        <royal-code-ui-dropdown alignment="right">
          <button dropdown-trigger royal-code-ui-button type="outline" sizeVariant="sm">
            <royal-code-ui-icon [icon]="AppIcon.BarChart" sizeVariant="sm" extraClass="mr-2"/>
            Rapporten
          </button>
          <div dropdown class="p-1 w-56">
             <a href="#" class="flex items-center w-full px-3 py-2 text-sm rounded-md hover:bg-hover">Verkooprapport</a>
             <a href="#" class="flex items-center w-full px-3 py-2 text-sm rounded-md hover:bg-hover">Gebruikersactiviteit</a>
          </div>
        </royal-code-ui-dropdown>

        <!-- Voorbeeld Dropdown 2: Nieuw Maken -->
        <royal-code-ui-dropdown alignment="right">
          <button dropdown-trigger royal-code-ui-button type="primary">
            <royal-code-ui-icon [icon]="AppIcon.Plus" sizeVariant="sm" extraClass="mr-2"/>
            Nieuw
          </button>
          <div dropdown class="p-1 w-56">
             <a routerLink="/products/new" class="flex items-center w-full px-3 py-2 text-sm rounded-md hover:bg-hover">Nieuw Product</a>
             <a routerLink="/users/new" class="flex items-center w-full px-3 py-2 text-sm rounded-md hover:bg-hover">Nieuwe Gebruiker</a>
             <a routerLink="/challenges/new" class="flex items-center w-full px-3 py-2 text-sm rounded-md hover:bg-hover">Nieuwe Challenge</a>
          </div>
        </royal-code-ui-dropdown>

        <!-- User Menu -->
        @if (isAuthenticated()) {
          <royal-code-ui-dropdown alignment="right">
            <button dropdown-trigger class="flex items-center gap-2 p-1 rounded-full hover:bg-hover">
              <div class="h-9 w-9 rounded-full border border-border bg-muted overflow-hidden">
                @if (currentUser()?.avatar; as avatar) {
                  <royal-code-ui-image [image]="avatar" [alt]="'Admin Avatar'" objectFit="cover" [rounded]="true" />
                } @else {
                  <royal-code-ui-icon [icon]="AppIcon.UserCircle" extraClass="w-full h-full text-secondary" />
                }
              </div>
            </button>
            <div dropdown class="p-1 w-48">
              <div class="px-3 py-2 border-b border-border">
                  <p class="text-sm font-semibold text-foreground truncate">{{ currentUser()?.displayName }}</p>
              </div>
              <div class="pt-1">
                <button (click)="logout()" class="flex items-center w-full px-3 py-2 text-sm text-destructive rounded-md hover:bg-destructive/10">
                  <royal-code-ui-icon [icon]="AppIcon.LogOut" sizeVariant="sm" extraClass="mr-2" />
                  <span>Uitloggen</span>
                </button>
              </div>
            </div>
          </royal-code-ui-dropdown>
        }
      </div>
    </header>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class AdminHeaderComponent {
  private readonly authFacade = inject(AuthFacade);

  readonly isAuthenticated: Signal<boolean> = this.authFacade.isAuthenticated;
  readonly currentUser: Signal<Profile | null> = this.authFacade.currentUser;
  readonly AppIcon = AppIcon;

  logout(): void {
    this.authFacade.logout();
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/admin-shell/admin-shell.component.ts ---
import { Component, ChangeDetectionStrategy, signal } from '@angular/core';
import { RouterModule } from '@angular/router';
import { AdminHeaderComponent } from '../admin-header/admin-header.component';
import { UiSidebarComponent } from '@royal-code/ui/sidebar';
import { UiVerticalNavComponent } from '@royal-code/ui/navigation';
import { NavigationItem, AppIcon } from '@royal-code/shared/domain';

@Component({
  selector: 'admin-shell',
  standalone: true,
  imports: [RouterModule, AdminHeaderComponent, UiSidebarComponent, UiVerticalNavComponent],
  template: `
    <div class="flex h-screen bg-background text-foreground">
      <royal-code-ui-sidebar [isOpen]="true" mode="docked">
        <div slot="header" class="p-4 border-b border-border">
          <h1 class="font-bold text-lg">Royal-Code Admin</h1>
        </div>
        
        <royal-code-ui-vertical-nav [items]="adminNavItems()" />

        <div slot="footer" class="p-2 border-t border-border">
          <!-- Footer content like user profile -->
        </div>
      </royal-code-ui-sidebar>

      <div class="flex flex-col flex-grow">
        <admin-header />
        <main class="flex-grow p-6 overflow-auto">
          <router-outlet />
        </main>
      </div>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class AdminShellComponent {
  // << DE FIX: Alle Settings items toegevoegd als children van het 'Settings' item >>
  adminNavItems = signal<NavigationItem[]>([
    { id: 'dashboard', labelKey: 'Dashboard', icon: AppIcon.Home, route: '/dashboard' },
    { id: 'management', labelKey: 'Management', isSectionHeader: true },
    { id: 'products', labelKey: 'Products', icon: AppIcon.Package, route: '/products' },
    { id: 'orders', labelKey: 'Orders', icon: AppIcon.ShoppingCart, route: '/orders' },
    { id: 'reviews', labelKey: 'Reviews', icon: AppIcon.Star, route: '/reviews' }, 
    { id: 'variants', labelKey: 'Attributes', icon: AppIcon.Ruler, route: '/variants' },
    {
      id: 'users',
      labelKey: 'Users',
      icon: AppIcon.Users,
      route: '/users',
      children: [
        { id: 'user-list', labelKey: 'User Management', route: '/users' },
        { id: 'role-list', labelKey: 'Role Management', route: '/users/roles' },
      ]
    },
    { id: 'system', labelKey: 'System', isSectionHeader: true },
    {
      id: 'settings',
      labelKey: 'Settings',
      icon: AppIcon.Settings,
      route: '/settings',
      children: [
        { id: 'settings-general', labelKey: 'Algemeen', route: '/settings/general' },
        { id: 'settings-products', labelKey: 'Product & Inventaris', route: '/settings/products' },
        { id: 'settings-orders', labelKey: 'Order & Checkout', route: '/settings/orders' },
        { id: 'settings-security', labelKey: 'Beveiliging', route: '/settings/security' },
        { id: 'settings-compliance', labelKey: 'Compliance (Drone)', route: '/settings/compliance' },
        { id: 'settings-marketing', labelKey: 'Marketing & SEO', route: '/settings/marketing' },
        { id: 'settings-system', labelKey: 'Systeem & Technisch', route: '/settings/system' },
        { id: 'settings-admin-panel', labelKey: 'Admin Panel Specifiek', route: '/settings/admin-panel' },
        { id: 'settings-governance', labelKey: 'Governance & Audit', route: '/settings/governance' },
        { id: 'settings-deployment', labelKey: 'Deployment', route: '/settings/deployment' },
      ]
    },
  ]);
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/dashboard-bestsellers/dashboard-bestsellers.component.ts ---
/**
 * @file dashboard-bestsellers.component.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Presentational component to display a list of best-selling products.
 */
import { Component, ChangeDetectionStrategy, input } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { TranslateModule } from '@ngx-translate/core';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { UiImageComponent } from '@royal-code/ui/media';
import { UiIconComponent } from '@royal-code/ui/icon';
import { AppIcon } from '@royal-code/shared/domain';
import { Bestseller } from '@royal-code/features/admin-dashboard/domain';

@Component({
  selector: 'admin-dashboard-bestsellers',
  standalone: true,
  imports: [CommonModule, RouterModule, TranslateModule, CurrencyPipe, UiTitleComponent, UiImageComponent, UiIconComponent],
  template: `
    <div class="bg-card border border-border rounded-xs shadow-sm h-full flex flex-col">
      <header class="p-4 border-b border-border">
        <royal-code-ui-title [level]="TitleTypeEnum.H3" text="Best Verkochte Producten" />
      </header>
      <div class="flex-grow p-4 space-y-4 overflow-y-auto">
        @if (bestsellers(); as items) {
          @for (item of items; track item.productId) {
            <a [routerLink]="['/products', item.productId]" class="flex items-center gap-4 group">
              <div class="flex-shrink-0 w-12 h-12 rounded-md overflow-hidden bg-muted">
                <royal-code-ui-image [src]="item.thumbnailUrl" [alt]="item.productName" objectFit="cover" class="w-full h-full" />
              </div>
              <div class="flex-grow min-w-0">
                <p class="font-semibold text-foreground group-hover:text-primary transition-colors truncate" [title]="item.productName">{{ item.productName }}</p>
                <p class="text-xs text-secondary font-mono">SKU: {{ item.sku || 'N/A' }}</p>
              </div>
              <div class="flex flex-col items-end flex-shrink-0">
                <p class="font-semibold text-foreground">{{ item.totalRevenue | currency:'EUR' }}</p>
                <p class="text-xs text-secondary">{{ item.unitsSold }} verkocht</p>
              </div>
            </a>
          } @empty {
            <p class="text-sm text-muted text-center pt-8">Geen data over bestsellers beschikbaar.</p>
          }
        } @else {
          <!-- Skeleton Loader -->
          @for (_ of [1,2,3]; track $index) {
            <div class="flex items-center gap-4 animate-pulse">
              <div class="w-12 h-12 rounded-md bg-muted"></div>
              <div class="flex-grow space-y-2">
                <div class="h-4 w-3/4 bg-muted rounded"></div>
                <div class="h-3 w-1/2 bg-muted rounded"></div>
              </div>
              <div class="w-20 h-4 bg-muted rounded"></div>
            </div>
          }
        }
      </div>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class DashboardBestsellersComponent {
  bestsellers = input.required<readonly Bestseller[]>();
  protected readonly TitleTypeEnum = TitleTypeEnum;
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/dashboard-kpi-card/dashboard-kpi-card.component.ts ---
/**
 * @file dashboard-kpi-card.component.ts
 * @Version 1.1.0 (Mapped to Kpi Domain Model)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Presentational component for a single Key Performance Indicator (KPI) on the dashboard, now mapped to the domain Kpi.
 */
import { Component, ChangeDetectionStrategy, input } from '@angular/core';
import { CommonModule, CurrencyPipe, DecimalPipe } from '@angular/common';
import { TranslateModule } from '@ngx-translate/core';
import { AppIcon } from '@royal-code/shared/domain';
import { UiIconComponent } from '@royal-code/ui/icon';
import { Kpi } from '@royal-code/features/admin-dashboard/domain'; // Import Kpi domain model

export interface KpiCardData {
  icon: AppIcon;
  label: string;
  value: number; // De hoofdwaarde van de KPI
  format?: 'currency' | 'decimal' | 'none';
  trendData?: Kpi; // De volledige Kpi-informatie, inclusief changePercentage en trendDirection
}

@Component({
  selector: 'admin-dashboard-kpi-card',
  standalone: true,
  imports: [CommonModule, CurrencyPipe, DecimalPipe, TranslateModule, UiIconComponent],
  template: `
    @if(data(); as cardData) {
      <div class="flex items-center p-4 bg-card border border-border rounded-xs shadow-sm">
        <div class="flex-shrink-0 bg-primary/10 text-primary p-3 rounded-md">
          <royal-code-ui-icon [icon]="cardData.icon" sizeVariant="lg" />
        </div>
        <div class="ml-4 flex-grow">
          <p class="text-sm font-medium text-muted truncate">{{ cardData.label | translate }}</p>
          <p class="text-2xl font-bold text-foreground">
            @switch (cardData.format) {
              @case ('currency') { {{ cardData.value | currency:'EUR' }} }
              @case ('decimal') { {{ cardData.value | number }} }
              @default { {{ cardData.value }} }
            }
          </p>
          @if (cardData.trendData; as trend) {
            <p class="text-xs text-secondary mt-1 flex items-center"
               [ngClass]="{
                 'text-success': trend.trendDirection === 'up',
                 'text-error': trend.trendDirection === 'down',
                 'text-muted': trend.trendDirection === 'neutral'
               }">
              <royal-code-ui-icon [icon]="trend.trendDirection === 'up' ? AppIcon.TrendingUp : AppIcon.TrendingDown" sizeVariant="xs" extraClass="mr-1" />
              {{ trend.changePercentage }}% vs. vorige maand
            </p>
          }
        </div>
      </div>
    }
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class DashboardKpiCardComponent {
  data = input.required<KpiCardData>();
  protected readonly AppIcon = AppIcon;
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/dashboard-recent-orders/dashboard-recent-orders.component.ts ---
/**
 * @file dashboard-recent-orders.component.ts
 * @Version 1.1.0 (Mapped to AdminDashboardOrderListItem)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Component to display a list of recent orders on the dashboard, now mapped to the domain model.
 */
import { Component, ChangeDetectionStrategy, input, output } from '@angular/core';
import { CommonModule, CurrencyPipe, DatePipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { TranslateModule } from '@ngx-translate/core';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { UiButtonComponent } from '@royal-code/ui/button';
import { AppIcon } from '@royal-code/shared/domain';
import { UiIconComponent } from '@royal-code/ui/icon';
import { OrderStatusPipe } from '@royal-code/features/orders/ui-plushie';
import { UiBadgeComponent } from '@royal-code/ui/badge';
import { AdminDashboardOrderListItem } from '@royal-code/features/admin-dashboard/domain'; // Import domain model
import { DateTimeInfo } from '@royal-code/shared/base-models';

// NOTE: De RecentOrder interface is verwijderd omdat we direct de AdminDashboardOrderListItem gebruiken.

@Component({
  selector: 'admin-dashboard-recent-orders',
  standalone: true,
  imports: [CommonModule, RouterModule, TranslateModule, CurrencyPipe, DatePipe, UiTitleComponent, UiButtonComponent, UiIconComponent, OrderStatusPipe, UiBadgeComponent],
  template: `
    <div class="bg-card border border-border rounded-xs shadow-sm h-full flex flex-col">
      <header class="p-4 border-b border-border flex justify-between items-center">
        <royal-code-ui-title [level]="TitleTypeEnum.H3" text="Recente Orders" />
        <royal-code-ui-button type="outline" sizeVariant="sm" routerLink="/orders">
          Bekijk Alles
        </royal-code-ui-button>
      </header>
      <div class="flex-grow p-4 space-y-4 overflow-y-auto">
        @for(order of orders(); track order.id) {
          <a [routerLink]="['/orders', order.id]" class="flex items-center gap-4 group">
            @if (order.productThumbnails && order.productThumbnails.length > 0) {
              <div class="flex-shrink-0 w-12 h-12 rounded-md overflow-hidden bg-muted">
                <img [src]="order.productThumbnails[0]" [alt]="order.customerName + ' order thumbnail'" class="w-full h-full object-cover">
              </div>
            }
            <div class="flex-grow">
              <p class="font-semibold text-foreground group-hover:text-primary transition-colors">{{ order.customerName }}</p>
              <p class="text-xs text-secondary font-mono">{{ order.orderDate.iso | date:'short' }}</p>
            </div>
            <div class="flex flex-col items-end">
              <p class="font-semibold text-foreground">{{ order.grandTotal | currency:'EUR' }}</p>
              @if (order.status | orderStatusInfo; as statusInfo) {
                <royal-code-ui-badge [color]="statusInfo.color" [icon]="statusInfo.icon" size="sm">
                  {{ statusInfo.textKey | translate }}
                </royal-code-ui-badge>
              }
            </div>
          </a>
        } @empty {
          <p class="text-sm text-muted text-center pt-8">Geen recente orders gevonden.</p>
        }
      </div>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class DashboardRecentOrdersComponent {
  orders = input.required<readonly AdminDashboardOrderListItem[]>(); // << DE FIX: readonly AdminDashboardOrderListItem[]
  protected readonly TitleTypeEnum = TitleTypeEnum;
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/dashboard-recent-reviews/dashboard-recent-reviews.component.ts ---
/**
 * @file dashboard-recent-reviews.component.ts
 * @Version 1.1.0 (Mapped to ReviewListItemDto)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Component to display recent reviews needing moderation, now mapped to the domain model.
 */
import { Component, ChangeDetectionStrategy, input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { TranslateModule } from '@ngx-translate/core';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiRatingComponent } from '@royal-code/ui/rating';
import { ReviewListItemDto } from '@royal-code/features/reviews/domain'; // Import domain model
import { DateTimeInfo } from '@royal-code/shared/base-models';

// NOTE: De RecentReview interface is verwijderd omdat we direct de ReviewListItemDto gebruiken.

@Component({
  selector: 'admin-dashboard-recent-reviews',
  standalone: true,
  imports: [CommonModule, RouterModule, TranslateModule, UiTitleComponent, UiButtonComponent, UiRatingComponent],
  template: `
    <div class="bg-card border border-border rounded-xs shadow-sm h-full flex flex-col">
      <header class="p-4 border-b border-border flex justify-between items-center">
        <royal-code-ui-title [level]="TitleTypeEnum.H3" text="Nieuwe Reviews" />
        <royal-code-ui-button type="outline" sizeVariant="sm" routerLink="/reviews">
          Beheer Reviews
        </royal-code-ui-button>
      </header>
      <div class="flex-grow p-4 space-y-4 overflow-y-auto">
        @for(review of reviews(); track review.id) {
          <div class="group">
            <div class="flex justify-between items-start">
              <div>
                <p class="font-semibold text-foreground">{{ review.authorDisplayName }}</p>
                @if(review.productName) {
                  <p class="text-xs text-secondary">voor {{ review.productName }}</p>
                }
              </div>
              <royal-code-ui-rating [rating]="review.rating * 2" [readonly]="true" size="sm"/>
            </div>
            <p class="text-sm text-muted mt-2 line-clamp-2 italic">"{{ review.reviewText }}"</p>
            <div class="mt-2 flex items-center gap-2">
               <royal-code-ui-button type="primary" sizeVariant="sm">Goedkeuren</royal-code-ui-button>
               <royal-code-ui-button type="outline" sizeVariant="sm">Afwijzen</royal-code-ui-button>
            </div>
          </div>
        } @empty {
          <p class="text-sm text-muted text-center pt-8">Geen nieuwe reviews.</p>
        }
      </div>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class DashboardRecentReviewsComponent {
  reviews = input.required<readonly ReviewListItemDto[]>(); // << DE FIX: readonly ReviewListItemDto[]
  protected readonly TitleTypeEnum = TitleTypeEnum;
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/dashboard-sales-chart/dashboard-sales-chart.component.ts ---
/**
 * @file dashboard-sales-chart.component.ts
 * @Version 2.7.0 (Simplified Chart without Date Adapter)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Simplified component for displaying the sales chart using Chart.js and Ng2-Charts,
 *              without requiring chartjs-adapter-date-fns dependency.
 */
import { Component, ChangeDetectionStrategy, input, OnInit, effect } from '@angular/core';
import { CommonModule, DecimalPipe } from '@angular/common';
import { TranslateModule } from '@ngx-translate/core';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { RevenueDataPoint } from '@royal-code/features/admin-dashboard/domain';

// --- Charting Imports ---
import { BaseChartDirective } from 'ng2-charts';
import {
  ChartConfiguration,
  ChartOptions,
  ChartType,
  Chart,
  registerables,
  ChartData,
} from 'chart.js';

// Register Chart.js components
Chart.register(...registerables);

@Component({
  selector: 'admin-dashboard-sales-chart',
  standalone: true,
  imports: [CommonModule, TranslateModule, UiTitleComponent, BaseChartDirective, DecimalPipe],
  template: `
    <div class="bg-card border border-border rounded-xs shadow-sm h-96 flex flex-col p-4">
      <royal-code-ui-title [level]="TitleTypeEnum.H3" text="Omzet Afgelopen 30 Dagen" />
      <div class="flex-grow flex items-center justify-center text-muted text-sm mt-4 bg-surface-alt rounded-md p-2">
        @if (data() && data()!.length > 0) {
          <canvas baseChart
            [data]="lineChartData"
            [options]="lineChartOptions"
            [type]="'line'"
          ></canvas>
        } @else {
          <p>{{ 'admin.dashboard.chart.noData' | translate }}</p>
        }
      </div>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class DashboardSalesChartComponent implements OnInit {
  data = input<readonly RevenueDataPoint[] | undefined>();
  protected readonly TitleTypeEnum = TitleTypeEnum;

  // Primary kleur styling gebaseerd op jouw design system
  public lineChartData: ChartData<'line', number[], string> = {
    datasets: [
      {
        data: [], // Will be populated with revenue numbers
        label: 'Omzet',
        fill: true,
        backgroundColor: 'hsla(38, 92%, 58%, 0.1)', // Primary kleur met 10% transparantie
        borderColor: 'hsl(38, 92%, 58%)', // Primary kleur (hue: 38, sat: 92%, lightness: 58%)
        borderWidth: 2, // Dunnere lijn
        pointBackgroundColor: 'hsl(38, 92%, 58%)',
        pointBorderColor: 'white',
        pointBorderWidth: 2,
        pointRadius: 3, // Kleinere punten
        pointHoverRadius: 5,
        pointHoverBackgroundColor: 'hsl(38, 92%, 51%)', // Iets donkerder bij hover
        pointHoverBorderColor: 'white',
        pointHoverBorderWidth: 2,
        tension: 0.4, // Zachte curves
      },
    ],
    labels: [], // Will be populated with formatted date strings
  };

  // Moderne en cleane chart styling
  public lineChartOptions: ChartOptions<'line'> = {
    responsive: true,
    maintainAspectRatio: false,
    interaction: {
      intersect: false,
      mode: 'index',
    },
    elements: {
      line: {
        tension: 0.4, // Zachte curves
      },
      point: {
        radius: 2, // Kleinere punten standaard
        hoverRadius: 4, // Iets groter bij hover
        borderWidth: 1,
        hoverBorderWidth: 2,
      },
    },
    layout: {
      padding: {
        top: 10,
        bottom: 10,
        left: 10,
        right: 10,
      },
    },
    scales: {
      x: {
        border: {
          display: false, // Geen dikke border
        },
        grid: {
          display: true,
          color: 'rgba(148, 163, 184, 0.1)', // Zeer subtiele grid lijnen
          lineWidth: 1,
        },
        ticks: {
          color: 'rgb(100, 116, 139)', // Matte tekst kleur
          font: {
            size: 11,
            family: 'Inter, system-ui, sans-serif',
          },
          maxTicksLimit: 7,
          padding: 8,
        },
      },
      y: {
        beginAtZero: true,
        border: {
          display: false, // Geen dikke border
        },
        grid: {
          display: true,
          color: 'rgba(148, 163, 184, 0.1)', // Zeer subtiele grid lijnen
          lineWidth: 1,
        },
        ticks: {
          color: 'rgb(100, 116, 139)', // Matte tekst kleur
          font: {
            size: 11,
            family: 'Inter, system-ui, sans-serif',
          },
          callback: function (value) {
            return new DecimalPipe('nl-NL').transform(value, '1.0-0') + '€';
          },
          padding: 8,
        },
      },
    },
    plugins: {
      legend: {
        display: false, // Geen legend nodig
      },
      tooltip: {
        enabled: true,
        backgroundColor: 'rgba(15, 23, 42, 0.9)', // Donkere tooltip
        titleColor: 'white',
        bodyColor: 'white',
        borderColor: 'hsl(var(--color-primary) / 0.3)',
        borderWidth: 1,
        cornerRadius: 6,
        displayColors: false,
        titleFont: {
          size: 12,
          weight: 'normal',
        },
        bodyFont: {
          size: 12,
          weight: 'bold',
        },
        padding: 10,
        callbacks: {
          title: (context) => {
            return context[0].label || '';
          },
          label: (context) => {
            const value = context.parsed.y;
            return `€${new DecimalPipe('nl-NL').transform(value, '1.2-2')}`;
          },
        },
      },
    },
  };

  // Fixed: Remove the public property and use inline literal type
  // public lineChartType: ChartType = 'line'; // Remove this line

  constructor() {
    effect(() => {
      const revenueData = this.data();
      if (revenueData && revenueData.length > 0) {
        this.updateChartData(revenueData);
      } else {
        this.lineChartData.datasets[0].data = [];
        this.lineChartData.labels = [];
      }
    });
  }

  ngOnInit(): void {
    // Chart.js components are already registered
  }

  private updateChartData(dataPoints: readonly RevenueDataPoint[]): void {
    // Convert data points to simple arrays for Chart.js
    const revenues: number[] = dataPoints.map(point => point.revenue);
    const labels: string[] = dataPoints.map(point => 
      point.date.toLocaleDateString('nl-NL', { 
        month: 'short', 
        day: 'numeric' 
      })
    );

    this.lineChartData.datasets[0].data = revenues;
    this.lineChartData.labels = labels;
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/product-form/product-form.component.ts ---
/**
 * @file product-form.component.ts
 * @Version 45.0.0 (Definitive Data Integrity & Patching Fix)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-04
 * @Description
 *   De definitieve, Gold Standard-versie van het Product Form. Lost alle bekende bugs op
 *   door de `patchFormForEdit` methode volledig te herschrijven om dataverlies te
 *   voorkomen en introduceert robuuste logging voor volledige transparantie.
 */
import {
  Component,
  ChangeDetectionStrategy,
  inject,
  OnInit,
  input,
  output,
  effect,
  DestroyRef,
  signal,
  computed
} from '@angular/core';
import { CommonModule, TitleCasePipe } from '@angular/common';
import {
  AbstractControl,
  FormBuilder,
  FormGroup,
  ReactiveFormsModule,
  FormArray,
  Validators,
  ValidationErrors,
  ValidatorFn,
  FormControl
} from '@angular/forms';
import { RouterModule } from '@angular/router';
import {
  debounceTime,
  distinctUntilChanged,
  filter,
  take,
  finalize,
  auditTime,
  startWith,
  pairwise,
  catchError,
  concatMap,
  tap
} from 'rxjs/operators';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { v4 as uuidv4 } from 'uuid';
import { TranslateService, TranslateModule } from '@ngx-translate/core';
import { EMPTY, forkJoin, from } from 'rxjs';
import { Store } from '@ngrx/store';

// UI & Core Dependencies
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiIconComponent } from '@royal-code/ui/icon';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiTextareaComponent } from '@royal-code/ui/textarea';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { UiToggleButtonComponent } from '@royal-code/ui/button';
import { UiSliderComponent } from '@royal-code/ui/meters';
import { AppIcon } from '@royal-code/shared/domain';
import { NotificationService } from '@royal-code/ui/notifications';
import { Media, Image, MediaType } from '@royal-code/shared/domain';
import { MediaActions, MediaFacade } from '@royal-code/features/media/core';
import { MediaUploaderComponent, VariantImageManagerComponent } from '@royal-code/ui/media';
import {
  UiSelectComponent,
  SelectOption,
  UiTagInputComponent,
  UiCategorySelectorComponent
} from '@royal-code/ui/forms';
import { DynamicOverlayService } from '@royal-code/ui/overlay';
import { ValidationService } from '@royal-code/shared/utils';
import { ValidationSummaryDialogComponent } from '@royal-code/ui/dialogs';

// Domain, State & DTOs
import { AdminProductListViewModel, CustomAttributeDefinitionDto, PredefinedAttributeValueDto } from '@royal-code/features/admin-products/core';
import { CreateProductPayload, Product, ProductType, StockStatus, UpdateProductPayload, VariantAttributeType, VariantAttribute, VariantAttributeValue, ProductDisplaySpecification, ProductVariantCombination, ProductStatus } from '@royal-code/features/products/domain';
import { isPhysicalProduct } from '@royal-code/features/products/domain';
import { filterImageMedia } from '@royal-code/shared/utils';
import { PlushieMediaApiService } from '@royal-code/features/media/data-access-plushie';
import { CategoryTreeService } from 'libs/features/products/core/src/lib/services/category-tree.service';

// Type Definitions & Constants
const CUSTOM_ATTRIBUTE_VALUE = '__custom__';

interface AttributeFormValue {
  tempId: string;
  nameKeyOrText: string;
  type: VariantAttributeType;
  displayType?: string;
  isRequired: boolean;
  values: AttributeValueFormValue[];
}

interface AttributeValueFormValue {
  tempId: string;
  predefinedValue: PredefinedAttributeValueDto | typeof CUSTOM_ATTRIBUTE_VALUE | null;
  displayNameKeyOrText: string;
  colorHex?: string;
  priceModifier?: number;
  isAvailable: boolean;
}

@Component({
  selector: 'admin-product-form',
  standalone: true,
  imports: [
    CommonModule, RouterModule, ReactiveFormsModule, TitleCasePipe, TranslateModule,
    UiTitleComponent, UiButtonComponent, UiIconComponent, UiInputComponent,
    UiTextareaComponent, UiSpinnerComponent, UiToggleButtonComponent,
    UiSliderComponent, MediaUploaderComponent, UiSelectComponent, VariantImageManagerComponent,
    UiTagInputComponent, UiCategorySelectorComponent
  ],
  template: `
<form [formGroup]="productForm" (ngSubmit)="onSave()">
@if (viewModel(); as vm) {
  <!-- === HEADER SECTION === -->
  <div class="sticky top-0 z-10 bg-background/95 backdrop-blur-sm py-4 border-b border-border px-4">
    <div class="flex justify-between items-center">
      <royal-code-ui-title 
        [level]="TitleTypeEnum.H1" 
        [text]="(isEditMode() ? 'admin.products.editTitle' : 'admin.products.createTitle') | translate" />
      
      <div class="flex items-center gap-3">
        <!-- Debug Toggle Button (alleen voor development) -->
        <royal-code-ui-button 
          type="transparent" 
          sizeVariant="sm" 
          (clicked)="toggleDebugOverlay()" 
          extraClasses="text-destructive border-destructive"
          title="Open Debug Panel">
          <royal-code-ui-icon [icon]="AppIcon.Bug" extraClass="mr-2" />
          Debug
        </royal-code-ui-button>
        
        <royal-code-ui-button type="outline" routerLink="/products">
          {{ 'admin.products.form.cancel' | translate }}
        </royal-code-ui-button>
        
        <royal-code-ui-button 
          type="primary" 
          htmlType="submit" 
          [disabled]="vm.isSubmitting || isAnyUploadPending()">
          @if (vm.isSubmitting || isMediaUploading()) {
            <royal-code-ui-spinner size="sm" extraClass="mr-2" />
            <span>{{ isMediaUploading() ? 'Uploading media...' : ('admin.products.form.saving' | translate) }}</span>
          } @else {
            <span>{{ 'admin.products.form.save' | translate }}</span>
          }
        </royal-code-ui-button>
      </div>
    </div>
  </div>

  <!-- === DEBUG OVERLAY === -->
  @if (showDebugOverlay()) {
    <div class="fixed inset-0 z-50 bg-black/50 backdrop-blur-sm" (click)="closeDebugOverlay()">
      <div class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-card border border-border rounded-lg shadow-xl w-[600px] max-h-[80vh] overflow-y-auto" (click)="$event.stopPropagation()">
        
        <!-- Debug Panel Header -->
        <div class="flex justify-between items-center p-4 border-b border-border">
          <h3 class="text-lg font-semibold flex items-center">
            <royal-code-ui-icon [icon]="AppIcon.Bug" extraClass="mr-2 text-destructive" />
            Debug Panel
          </h3>
          <royal-code-ui-button 
            type="transparent" 
            sizeVariant="icon" 
            (clicked)="closeDebugOverlay()">
            <royal-code-ui-icon [icon]="AppIcon.X" />
          </royal-code-ui-button>
        </div>

        <!-- Debug Panel Content -->
        <div class="p-4 space-y-4">
          
          <!-- Form State Section -->
          <div class="space-y-2">
            <h4 class="font-medium text-sm text-secondary border-b border-border pb-1">Form State</h4>
            <div class="grid grid-cols-1 gap-2">
              <royal-code-ui-button 
                type="outline" 
                sizeVariant="sm" 
                (clicked)="debugVariantState(); closeDebugOverlay()"
                extraClasses="justify-start">
                <royal-code-ui-icon [icon]="AppIcon.Settings" extraClass="mr-2" />
                Debug Variant State
              </royal-code-ui-button>
              
              <royal-code-ui-button 
                type="outline" 
                sizeVariant="sm" 
                (clicked)="debugAttributeState(); closeDebugOverlay()"
                extraClasses="justify-start">
                <royal-code-ui-icon [icon]="AppIcon.Tag" extraClass="mr-2" />
                Debug Attribute State
              </royal-code-ui-button>
            </div>
          </div>

          <!-- Media Section -->
          <div class="space-y-2">
            <h4 class="font-medium text-sm text-secondary border-b border-border pb-1">Media</h4>
            <div class="grid grid-cols-1 gap-2">
              <royal-code-ui-button 
                type="outline" 
                sizeVariant="sm" 
                (clicked)="debugMediaState(); closeDebugOverlay()"
                extraClasses="justify-start">
                <royal-code-ui-icon [icon]="AppIcon.Image" extraClass="mr-2" />
                Debug Media State
              </royal-code-ui-button>
              
              <royal-code-ui-button 
                type="outline" 
                sizeVariant="sm" 
                (clicked)="reloadProductMedia(); closeDebugOverlay()"
                extraClasses="justify-start">
                <royal-code-ui-icon [icon]="AppIcon.RefreshCw" extraClass="mr-2" />
                Reload Product Media
              </royal-code-ui-button>
            </div>
          </div>

          <!-- Categories Section -->
          <div class="space-y-2">
            <h4 class="font-medium text-sm text-secondary border-b border-border pb-1">Categories</h4>
            <div class="grid grid-cols-1 gap-2">
              <royal-code-ui-button 
                type="outline" 
                sizeVariant="sm" 
                (clicked)="debugCategoryState(); closeDebugOverlay()"
                extraClasses="justify-start">
                <royal-code-ui-icon [icon]="AppIcon.Folder" extraClass="mr-2" />
                Debug Category State
              </royal-code-ui-button>
              
              <royal-code-ui-button 
                type="outline" 
                sizeVariant="sm" 
                (clicked)="debugCategoryTree(); closeDebugOverlay()"
                extraClasses="justify-start">
                <royal-code-ui-icon [icon]="AppIcon.Tree" extraClass="mr-2" />
                Debug Category Tree
              </royal-code-ui-button>
              
              <royal-code-ui-button 
                type="outline" 
                sizeVariant="sm" 
                (clicked)="testCategoryParents(); closeDebugOverlay()"
                extraClasses="justify-start">
                <royal-code-ui-icon [icon]="AppIcon.ArrowUp" extraClass="mr-2" />
                Test Category Parents
              </royal-code-ui-button>
            </div>
          </div>

          <!-- Form Actions Section -->
          <div class="space-y-2">
            <h4 class="font-medium text-sm text-secondary border-b border-border pb-1">Form Actions</h4>
            <div class="grid grid-cols-1 gap-2">
              <royal-code-ui-button 
                type="outline" 
                sizeVariant="sm" 
                (clicked)="regenerateSkus(); closeDebugOverlay()"
                extraClasses="justify-start text-warning">
                <royal-code-ui-icon [icon]="AppIcon.RefreshCw" extraClass="mr-2" />
                Regenerate All SKUs
              </royal-code-ui-button>
            </div>
          </div>

          <!-- Current Form Status -->
          <div class="space-y-2 pt-4 border-t border-border">
            <h4 class="font-medium text-sm text-secondary">Current Status</h4>
            <div class="text-xs space-y-1 text-muted-foreground">
              <div>Form Valid: {{ productForm.valid ? 'Yes' : 'No' }}</div>
              <div>Variant Attributes: {{ variantAttributes.length }}</div>
              <div>Combinations: {{ variantCombinations.length }}</div>
              <div>Media Items: {{ uploadedMedia().length }}</div>
              <div>Is Patching: {{ isPatching ? 'Yes' : 'No' }}</div>
            </div>
          </div>

        </div>
      </div>
    </div>
  }

  <!-- === FORM CONTENT GRID === -->
  <div class="p-2 md:p-4 grid grid-cols-1 lg:grid-cols-3 gap-8">
    
    <!-- === MAIN CONTENT COLUMN === -->
    <div class="lg:col-span-2 space-y-6">
      
      <!-- Basic Information -->
      <div class="p-6 bg-card border border-border rounded-xs">
        <h3 class="text-lg font-medium mb-4">{{ 'admin.products.form.basicInfo' | translate }}</h3>
        <div class="space-y-4">
          <royal-code-ui-input 
            [label]="'admin.products.form.productName' | translate" 
            formControlName="name" 
            [required]="true" 
            [error]="getFieldError('name')" />
          <royal-code-ui-textarea 
            [label]="'admin.products.form.shortSummary' | translate" 
            formControlName="shortDescription" 
            [rows]="3" />
          <royal-code-ui-textarea 
            [label]="'admin.products.form.fullDescription' | translate" 
            formControlName="description" 
            [rows]="6" />
        </div>
      </div>

      <!-- Media Section -->
      <div class="p-6 bg-card border border-border rounded-xs">
        <h3 class="text-lg font-medium mb-4">{{ 'admin.products.form.media' | translate }}</h3>
        
        <p class="text-sm text-secondary mb-4">Upload all product images here. These images will be available for assignment to the fallback product and specific combinations.</p>
        <media-uploader (filesSelected)="handleFileUploads($event)" />
        
        @if(isUploading()) {
          <div class="mt-2 text-sm text-info flex items-center justify-center">
            <royal-code-ui-icon [icon]="AppIcon.Loader" sizeVariant="sm" extraClass="animate-spin mr-2" />
            <span>Processing images...</span>
          </div>
        }
        
        <h4 class="text-base font-medium mt-6 mb-2 flex justify-between items-center">
          <span>All Uploaded Media</span>
          <royal-code-ui-icon [icon]="AppIcon.Info" class="text-secondary" title="Alle geüploade afbeeldingen voor dit product. Deze kunnen worden toegewezen aan specifieke varianten of combinaties."></royal-code-ui-icon>
        </h4>
        @if(uploadedMedia().length > 0) {
          <div class="mt-4 grid grid-cols-4 sm:grid-cols-6 lg:grid-cols-8 gap-2">
            @for(media of uploadedMedia(); track media.id) {
              <div 
                class="aspect-square bg-muted rounded-md overflow-hidden relative group"
                [class.border-2]="media.id === featuredImageIdC()"
                [class.border-primary]="media.id === featuredImageIdC()"
                [title]="media.id === featuredImageIdC() ? ('admin.products.form.featuredImage' | translate) : ''">
                <img [src]="getMediaUrl(media)" [alt]="getMediaAltText(media)" class="w-full h-full object-cover">
                <button 
                  type="button" 
                  (click)="removeMedia(media.id); $event.stopPropagation()" 
                  class="absolute top-1 right-1 bg-destructive/80 text-destructive-on rounded-full p-1 opacity-0 group-hover:opacity-100 transition-opacity">
                  <royal-code-ui-icon [icon]="AppIcon.X" sizeVariant="xs" />
                </button>
                @if (media.id === featuredImageIdC()) {
                  <div class="absolute bottom-0 left-0 right-0 bg-primary/70 text-primary-on text-center text-xs p-0.5">
                    {{ 'admin.products.form.featured' | translate }}
                  </div>
                }
              </div>
            }
          </div>
        } @else {
          <div class="mt-4">
            <p class="text-sm text-secondary">No media in MediaFacade state.</p>
            @if(productForm.get('mediaIds')?.value?.length > 0) {
              <p class="text-sm text-info">Product has {{ productForm.get('mediaIds')?.value?.length }} media items, but they're not loaded in state.</p>
              <royal-code-ui-button type="outline" sizeVariant="sm" (clicked)="reloadProductMedia()">
                Reload Media
              </royal-code-ui-button>
            }
          </div>
        }

        <h4 class="text-base font-medium mt-6 mb-2 flex justify-between items-center">
          <span>Fallback Product Images</span>
          <royal-code-ui-button type="outline" sizeVariant="sm" (clicked)="manageRootMedia()">
            <royal-code-ui-icon [icon]="AppIcon.Image" extraClass="mr-2" />
            Manage Assignment
          </royal-code-ui-button>
          <royal-code-ui-icon [icon]="AppIcon.Info" class="text-secondary" title="Deze afbeeldingen worden getoond als er geen specifieke variant of combinatie is geselecteerd, of als deze geen eigen afbeeldingen heeft."></royal-code-ui-icon>
        </h4>
        <p class="text-sm text-secondary mb-4">These images are shown for the product when no specific variant or combination is selected. One of them can be set as the featured image.</p>
        @if(rootMedia().length > 0) {
          <div class="mt-4 grid grid-cols-4 sm:grid-cols-6 lg:grid-cols-8 gap-2">
            @for(media of rootMedia(); track media.id) {
              <div 
                class="aspect-square bg-muted rounded-md overflow-hidden relative group cursor-pointer"
                [class.border-2]="media.id === featuredImageIdC()"
                [class.border-primary]="media.id === featuredImageIdC()"
                (click)="setFeaturedImage(media.id)"
                [title]="media.id === featuredImageIdC() ? ('admin.products.form.featuredImage' | translate) : ('admin.products.form.setAsFeatured' | translate)">
                <img [src]="getMediaUrl(media)" [alt]="getMediaAltText(media)" class="w-full h-full object-cover">
                @if (media.id === featuredImageIdC()) {
                  <div class="absolute bottom-0 left-0 right-0 bg-primary/70 text-primary-on text-center text-xs p-0.5">
                    {{ 'admin.products.form.featured' | translate }}
                  </div>
                }
              </div>
            }
          </div>
        } @else {
          <p class="text-sm text-secondary mt-2">No fallback images assigned. Click "Manage Assignment" to select them from your uploaded media.</p>
        }
      </div>

      <!-- Variants Section -->
      <div class="p-6 bg-card border border-border rounded-xs">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-lg font-medium">{{ 'admin.products.form.variants' | translate }}</h3>
          <royal-code-ui-button type="outline" sizeVariant="sm" (clicked)="addVariantAttribute()">
            <royal-code-ui-icon [icon]="AppIcon.Plus" extraClass="mr-2" />
            {{ 'admin.products.form.addAttribute' | translate }}
          </royal-code-ui-button>
        </div>
        
        <div formArrayName="variantAttributes" class="space-y-4">
          @if(vm.isLoadingAttributes) {
            <div class="text-center p-4 text-secondary">{{ 'admin.products.form.loadingAttributes' | translate }}</div>
          } @else if (!vm.attributeNames.length && vm.error) {
            <div class="text-center p-4 text-destructive bg-destructive/10 border border-destructive rounded-md">
              <p class="font-semibold">{{ 'admin.products.form.errorLoadingAttributes' | translate }}</p>
              <p class="text-sm">{{ vm.error }}</p>
            </div>
          } @else {
            @for (attr of variantAttributes.controls; track trackByTempId($index, attr); let i = $index) {
              <div [formGroupName]="i" class="p-4 border border-border rounded-md bg-surface-alt">
                <div class="grid grid-cols-1 gap-4 mb-3">
                  <div>
                    <label class="block text-sm font-medium text-foreground mb-1">{{ 'admin.products.form.attribute' | translate }}</label>
                    <select formControlName="nameKeyOrText" (change)="onAttributeNameChange(attr)" class="w-full p-2 border border-input rounded-md bg-background text-sm">
                      <option value="" disabled>{{ 'admin.products.form.chooseExistingAttribute' | translate }}</option>
                      @for(name of vm.attributeNames; track name) { 
                        <option [value]="name">{{ name | titlecase }}</option> 
                      }
                    </select>
                  </div>
                  <div class="col-span-2 flex justify-between items-center">
                    <label class="flex items-center text-sm font-medium text-foreground">
                      <input type="checkbox" formControlName="isRequired" class="mr-2 h-4 w-4 rounded text-primary focus:ring-primary border-border">
                      {{ 'admin.products.form.isRequired' | translate }}
                    </label>
                    <royal-code-ui-button type="fire" sizeVariant="sm" (clicked)="removeVariantAttribute(i)">
                      <royal-code-ui-icon [icon]="AppIcon.Trash2" sizeVariant="sm" extraClass="mr-2"/>
                      {{ 'admin.products.form.removeAttribute' | translate }}
                    </royal-code-ui-button>
                  </div>
                </div>
                <div formArrayName="values" class="space-y-2">
                  @for (val of getAttributeValues(attr).controls; track trackByTempId($index, val); let j = $index) {
                    <div [formGroupName]="j" class="p-3 border border-dashed border-border rounded-md">
                      <div class="grid grid-cols-[1fr_auto] gap-2 items-end">
                        <div>
                          <label class="block text-xs font-medium text-foreground mb-1">{{ 'admin.products.form.chooseValue' | translate }}</label>
                          <select formControlName="predefinedValue" class="w-full p-2 border border-input rounded-md bg-background text-sm" [compareWith]="comparePredefinedValues">
                            <option [ngValue]="null" disabled>{{ 'admin.products.form.selectExisting' | translate }}</option>
                            @if(getPredefinedValues(attr.get('nameKeyOrText')?.value); as options) {
                              @for(option of options; track option.id) { 
                                <option [ngValue]="option">{{ option.displayName }}</option> 
                              }
                            }
                            <option [value]="CUSTOM_ATTRIBUTE_VALUE">{{ 'admin.products.form.createNewValue' | translate }}</option>
                          </select>
                        </div>
                        <royal-code-ui-button type="transparent" sizeVariant="icon" (clicked)="removeAttributeValue(attr, j)">
                          <royal-code-ui-icon [icon]="AppIcon.X" sizeVariant="sm"/>
                        </royal-code-ui-button>
                      </div>
                      @if (val.get('predefinedValue')?.value === CUSTOM_ATTRIBUTE_VALUE) {
                        <div class="grid grid-cols-2 gap-2 mt-3 pt-3 border-t border-border">
                          <royal-code-ui-input 
                            [label]="'admin.products.form.displayNameNew' | translate" 
                            formControlName="displayNameKeyOrText" 
                            [required]="true" 
                            [error]="getArrayError(attr, j, 'displayNameKeyOrText')" />
                          @if(attr.get('type')?.value === 'color') { 
                            <royal-code-ui-input 
                              [label]="'admin.products.form.colorHexOptional' | translate" 
                              formControlName="colorHex" /> 
                          }
                          <royal-code-ui-input 
                            [label]="'admin.products.form.priceModifierOptional' | translate" 
                            formControlName="priceModifier" 
                            type="number" />
                        </div>
                      } @else {
                        <div [class.hidden]="!val.get('predefinedValue')?.value">
                          <royal-code-ui-input 
                            [label]="'admin.products.form.displayName' | translate" 
                            formControlName="displayNameKeyOrText" 
                            [readonly]="true" 
                            extraClasses="mt-2" />
                        </div>
                      }
                    </div>
                  }
                </div>
                <royal-code-ui-button type="outline" sizeVariant="xs" (clicked)="addAttributeValue(attr)" extraClasses="mt-3">
                  {{ 'admin.products.form.addValue' | translate }}
                </royal-code-ui-button>
              </div>
            }
          }
        </div>
        @if (variantAttributes.controls.length > 0) {
          <div class="pt-4 border-t border-border flex justify-end">
            <royal-code-ui-button type="outline" sizeVariant="sm" (clicked)="addVariantAttribute()">
              <royal-code-ui-icon [icon]="AppIcon.Plus" extraClass="mr-2" />
              {{ 'admin.products.form.addAttribute' | translate }}
            </royal-code-ui-button>
          </div>
        }
      </div>

      <!-- Combinations Matrix -->
      <div class="p-6 bg-card border border-border rounded-xs">
        <h3 class="text-lg font-medium mb-4">{{ 'admin.products.form.combinations' | translate }}</h3>
        @if(variantCombinations.controls.length > 0) {
          <div class="overflow-x-auto">
            <table class="w-full text-sm">
              <thead class="text-left text-secondary border-b border-border">
                <tr>
                  @for (attr of variantAttributes.controls; track trackByTempId($index, attr)) {
                    @if (getAttributeValues(attr).controls.length > 0 && attr.value.nameKeyOrText) { 
                      <th class="p-2 font-medium">{{ attr.value.nameKeyOrText | titlecase }}</th> 
                    }
                  }
                  <th class="p-2 font-medium">SKU</th>
                  <th class="p-2 font-medium">Price</th>
                  <th class="p-2 font-medium">Original Price</th>
                  <th class="p-2 font-medium">Stock</th>
                  <th class="p-2 font-medium">Status</th>
                  <th class="p-2 font-medium">Media</th>
                  <th class="p-2 font-medium">Default</th>
                  <th class="p-2 font-medium">Active</th>
                </tr>
              </thead>
              <tbody formArrayName="variantCombinations">
                @for (combo of variantCombinations.controls; track trackByCombination($index, combo); let i = $index) {
                  <tr [formGroupName]="i" class="border-b border-border last:border-b-0" [ngClass]="{ 'opacity-50 bg-surface-alt': !combo.get('isActive')?.value }">
                    @for (mainAttr of variantAttributes.controls; track trackByTempId($index, mainAttr)) {
                      @if (getAttributeValues(mainAttr).controls.length > 0 && mainAttr.value.nameKeyOrText) {
                         <td class="p-2 font-semibold">{{ getAttributeDisplayValueForCombination(combo, mainAttr.value.tempId) }}</td>
                      }
                    }
                    <td class="p-2">
                      <royal-code-ui-input 
                        formControlName="sku" 
                        [required]="true" 
                        extraClasses="!py-1" 
                        [error]="getCombinationError(i, 'sku')" />
                    </td>
                    <td class="p-2">
                      <royal-code-ui-input 
                        formControlName="price" 
                        type="number" 
                        [required]="true" 
                        extraClasses="!py-1" 
                        [error]="getCombinationError(i, 'price')" />
                    </td>
                    <td class="p-2">
                      <royal-code-ui-input 
                        formControlName="originalPrice" 
                        type="number" 
                        extraClasses="!py-1" />
                    </td>
                    <td class="p-2">
                      <royal-code-ui-input 
                        formControlName="stockQuantity" 
                        type="number" 
                        [required]="true" 
                        extraClasses="!py-1" 
                        [error]="getCombinationError(i, 'stockQuantity')" />
                    </td>
                    <td class="p-2">
                      <select formControlName="stockStatus" class="w-full p-1 border border-input rounded-md bg-background text-xs"> 
                        @for(status of stockStatuses; track status) { 
                          <option [value]="status">{{ status | titlecase }}</option> 
                        } 
                      </select>
                    </td>
                    <td class="p-2">
                      <div class="flex items-center gap-2">
                        @if((combo.get('mediaIds')?.value ?? []).length > 0) {
                          <div class="w-8 h-8 rounded-md border border-border bg-muted overflow-hidden">
                            <img [src]="getMediaDisplayUrl(getCombinationPrimaryImage(combo))" [alt]="'Combination image'" class="w-full h-full object-cover">
                          </div>
                        }
                        <royal-code-ui-button type="outline" sizeVariant="icon" (clicked)="manageCombinationMedia(combo)" [title]="'Manage media for this combination'">
                          <royal-code-ui-icon [icon]="AppIcon.Camera" />
                        </royal-code-ui-button>
                      </div>
                    </td>
                    <td class="p-2 text-center">
                      <input type="radio" name="defaultVariant" [value]="i" (change)="setDefaultVariant(i)" [checked]="combo.get('isDefault')?.value" class="h-4 w-4 text-primary focus:ring-primary border-border">
                    </td>
                    <td class="p-2">
                      <royal-code-ui-toggle-button formControlName="isActive" label="" />
                    </td>
                  </tr>
                }
              </tbody>
            </table>
          </div>
          @if (variantCombinations.errors) {
            <div class="mt-2 text-sm text-destructive space-y-1">
              @if (variantCombinations.errors['duplicateSku']) { 
                <p>{{ 'admin.products.form.duplicateSku' | translate }}</p> 
              }
              @if (variantCombinations.errors['noDefaultVariant']) { 
                <p>{{ 'admin.products.form.noDefaultVariant' | translate }}</p> 
              }
              @if (variantCombinations.errors['noCombinationsGenerated']) { 
                <p>{{ 'admin.products.form.noCombinationsGenerated' | translate }}</p> 
              }
            </div>
          }
        } @else {
          <p class="text-sm text-secondary">{{ 'admin.products.form.addAttributesToGenerate' | translate }}</p>
        }
      </div>

      <!-- Custom Attributes -->
      @if (hasCustomAttributes()) {
        <div class="p-6 bg-card border border-border rounded-xs">
          <div class="flex justify-between items-center mb-4">
            <h3 class="text-lg font-medium">{{ 'admin.products.form.propertiesAndQualities' | translate }}</h3>
          </div>
          
          <div [formGroupName]="'customAttributes'" class="space-y-6">
            <div class="space-y-4">
              <h4 class="text-base font-medium mb-3 border-b border-border pb-2">Product Qualities</h4>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                @for (key of getCustomAttributeKeys(); track key) {
                  @if(productForm.get('customAttributes.' + key)) {
                    <div>
                      <royal-code-ui-slider 
                        [label]="formatCustomAttributeLabel(key)" 
                        [formControlName]="key" 
                        [min]="1" 
                        [max]="10" 
                        [step]="1" 
                        [valueLabel]="productForm.get('customAttributes')?.get(key)?.value?.toString()" />
                    </div>
                  }
                }
              </div>
            </div>
          </div>
        </div>
      }

      <!-- Display Specifications -->
      <div class="p-6 bg-card border border-border rounded-xs">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-lg font-medium">{{ 'admin.products.form.displaySpecifications' | translate }}</h3>
          <royal-code-ui-button type="outline" sizeVariant="sm" (clicked)="addDisplaySpecification()">
            <royal-code-ui-icon [icon]="AppIcon.Plus" extraClass="mr-2" />
            {{ 'admin.products.form.addSpec' | translate }}
          </royal-code-ui-button>
        </div>
        <div formArrayName="displaySpecifications" class="space-y-4">
          @for (spec of displaySpecifications.controls; track trackByTempId($index, spec); let i = $index) {
            <div [formGroupName]="i" class="p-4 border border-dashed border-border rounded-md">
              <div class="grid grid-cols-[1fr_auto] gap-2 items-end">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 w-full">
                  <royal-code-ui-select 
                    [label]="'admin.products.form.specKeyInternal' | translate" 
                    formControlName="specKey" 
                    [options]="specificationOptions()" 
                    [required]="true" 
                    [error]="getSpecError(i, 'specKey')" />
                  <royal-code-ui-input 
                    [label]="'admin.products.form.displayName' | translate" 
                    formControlName="labelKeyOrText" 
                    [readonly]="true" />
                  <royal-code-ui-input 
                    [label]="'admin.products.form.displayValue' | translate" 
                    formControlName="valueKeyOrText" 
                    [required]="true" 
                    [error]="getSpecError(i, 'valueKeyOrText')" />
                  <royal-code-ui-input 
                    [label]="'admin.products.form.groupOptional' | translate" 
                    formControlName="groupKeyOrText" 
                    [readonly]="true" />
                </div>
                <royal-code-ui-button type="transparent" sizeVariant="icon" (clicked)="removeDisplaySpecification(i)">
                  <royal-code-ui-icon [icon]="AppIcon.X" sizeVariant="sm"/>
                </royal-code-ui-button>
              </div>
            </div>
          }
        </div>
        @if (displaySpecifications.controls.length === 0) { 
          <p class="text-sm text-secondary">{{ 'admin.products.form.addSpecsHelp' | translate }}</p> 
        }
      </div>
    </div>

    <!-- === SIDEBAR COLUMN === -->
    <aside class="lg:col-span-1 space-y-6 sticky top-24">
      
      <!-- Organization & Status -->
      <div class="p-6 bg-card border border-border rounded-xs">
        <h3 class="text-lg font-medium mb-4">{{ 'admin.products.form.organizationAndStatus' | translate }}</h3>
        <div class="space-y-4">
          <label class="block text-sm font-medium text-foreground mb-1">{{ 'admin.products.form.status' | translate }}</label>
          <select formControlName="status" class="w-full p-2 border border-input rounded-md bg-background text-sm"> 
            @for(status of productStatuses; track status) { 
              <option [value]="status">{{ status | titlecase }}</option> 
            } 
          </select>
          <royal-code-ui-toggle-button formControlName="isActive" [label]="'admin.products.form.isActive' | translate" />
          <royal-code-ui-toggle-button formControlName="isFeatured" [label]="'admin.products.form.isFeatured' | translate" />
          <royal-code-ui-input 
            [label]="'admin.products.form.currency' | translate" 
            formControlName="currency" 
            [required]="true" 
            [error]="getFieldError('currency')" />
          <royal-code-ui-tag-input 
            [label]="'admin.products.form.tags' | translate" 
            formControlName="tags" />
          <royal-code-ui-category-selector 
            formControlName="categoryIds" 
            [categories]="vm.allCategories" 
            [isLoading]="vm.isLoadingCategories" 
            [label]="'admin.products.form.categories' | translate" />
        </div>
      </div>

      <!-- Physical Product Config -->
      @if (productForm.get('type')?.value === ProductType.PHYSICAL) {
        <div class="p-6 bg-card border border-border rounded-xs" formGroupName="physicalProductConfig">
          <h3 class="text-lg font-medium mb-4">{{ 'admin.products.form.physicalConfig' | translate }}</h3>
          <div formGroupName="pricing" class="space-y-4">
            <royal-code-ui-input 
              [label]="'admin.products.form.price' | translate" 
              formControlName="price" 
              type="number" 
              [required]="variantCombinations.length === 0" 
              [error]="getFieldError('physicalProductConfig.pricing.price')" />
            <royal-code-ui-input 
              [label]="'admin.products.form.originalPriceOptional' | translate" 
              formControlName="originalPrice" 
              type="number" />
            @if (productForm.get('physicalProductConfig.pricing')?.errors?.['priceInvalid'] && productForm.get('physicalProductConfig.pricing')?.touched) { 
              <p class="text-destructive text-sm mt-2">{{ 'admin.products.form.priceCannotBeHigherThanOriginal' | translate }}</p> 
            }
          </div>
          <div class="space-y-4 mt-4 pt-4 border-t border-border">
            <royal-code-ui-input 
              [label]="'admin.products.form.skuOptional' | translate" 
              formControlName="sku" />
            <royal-code-ui-input 
              [label]="'admin.products.form.brandOptional' | translate" 
              formControlName="brand" />
            <royal-code-ui-toggle-button 
              formControlName="manageStock" 
              [label]="'admin.products.form.manageStock' | translate" />
            @if (productForm.get('physicalProductConfig.manageStock')?.value) { 
              <royal-code-ui-input 
                [label]="'admin.products.form.stockQuantity' | translate" 
                formControlName="stockQuantity" 
                type="number" 
                [required]="variantCombinations.length === 0" 
                [error]="getFieldError('physicalProductConfig.stockQuantity')" /> 
            }
            <royal-code-ui-toggle-button 
              formControlName="allowBackorders" 
              [label]="'admin.products.form.allowBackorders' | translate" />
            <royal-code-ui-input 
              [label]="'admin.products.form.lowStockThreshold' | translate" 
              formControlName="lowStockThreshold" 
              type="number" />
          </div>
          <div formGroupName="availabilityRules" class="mt-4 pt-4 border-t border-border">
            <h4 class="text-base font-medium mb-2">Order Rules</h4>
            <div class="space-y-3">
              <royal-code-ui-input label="Min. order quantity" formControlName="minOrderQuantity" type="number" />
              <royal-code-ui-input label="Max. order quantity" formControlName="maxOrderQuantity" type="number" />
              <royal-code-ui-input label="Order in multiples of" formControlName="quantityIncrements" type="number" />
              <royal-code-ui-toggle-button label="Rules Active" formControlName="isActive" />
            </div>
            @if (productForm.get('physicalProductConfig.availabilityRules')?.errors?.['minMaxInvalid']) { 
              <p class="text-destructive text-sm mt-2">Max. quantity must be greater than min. quantity.</p> 
            }
          </div>
          <div formGroupName="ageRestrictions" class="mt-4 pt-4 border-t border-border">
            <h4 class="text-base font-medium mb-2">Age Restrictions</h4>
            <div class="grid grid-cols-2 gap-3">
              <royal-code-ui-input label="Min. age" formControlName="minAge" type="number" />
              <royal-code-ui-input label="Max. age" formControlName="maxAge" type="number" />
            </div>
            @if (productForm.get('physicalProductConfig.ageRestrictions')?.errors?.['minMaxInvalid']) { 
              <p class="text-destructive text-sm mt-2">Max. age must be greater than min. age.</p> 
            }
          </div>
        </div>
      }

      <!-- SEO Section -->
      <div class="p-6 bg-card border border-border rounded-xs" formGroupName="seo">
        <h3 class="text-lg font-medium mb-4">{{ 'admin.products.form.seo' | translate }}</h3>
        <div class="space-y-4">
          <royal-code-ui-input 
            [label]="'admin.products.form.seoTitle' | translate" 
            formControlName="title" />
          <royal-code-ui-textarea 
            [label]="'admin.products.form.seoDescription' | translate" 
            formControlName="description" 
            [rows]="3" />
          <royal-code-ui-input 
            [label]="'admin.products.form.seoKeywordsCommaSeparated' | translate" 
            formControlName="keywords" />
        </div>
      </div>
    </aside>
  </div>
} @else {
  <div class="flex justify-center items-center h-64">
    <royal-code-ui-spinner size="lg" />
  </div>
}
</form>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class ProductFormComponent implements OnInit {
  // === Inputs & Outputs ===
  readonly product = input<Product | undefined>();
  readonly viewModel = input<AdminProductListViewModel>(); // Input is optional, template handles undefined
  readonly saveProduct = output<CreateProductPayload | UpdateProductPayload>();

  // === Dependencies ===
  private readonly fb = inject(FormBuilder);
  private readonly store = inject(Store);
  protected readonly mediaFacade = inject(MediaFacade);
  private readonly notificationService = inject(NotificationService);
  private readonly translateService = inject(TranslateService);
  private readonly destroyRef = inject(DestroyRef);
  private readonly validationService = inject(ValidationService);
  private readonly overlayService = inject(DynamicOverlayService);
  private readonly mediaApiService = inject(PlushieMediaApiService);
  private readonly categoryTreeService = inject(CategoryTreeService);
  private categoryKeyMap = new Map<string, string>();
  private readonly categoryParentCache = new Map<string, string[]>();

  // === Form & State ===
  productForm!: FormGroup;
  readonly isEditMode = computed(() => !!this.product());
  readonly isUploading = signal(false);
  readonly isMediaUploading = this.mediaFacade.isSubmitting;
  private hasBeenPatched = false;
  private lastPatchedProductId?: string;
  private customAttributesInitialized = false;
  protected isPatching = false;

  // === Debug Overlay ===
  protected showDebugOverlay = signal(false);

  // === Template Helpers ===
  protected readonly TitleTypeEnum = TitleTypeEnum;
  protected readonly AppIcon = AppIcon;
  protected readonly ProductType = ProductType;
  protected readonly productStatuses = Object.values(ProductStatus);
  protected readonly stockStatuses = Object.values(StockStatus);
  protected readonly uploadedMedia = this.mediaFacade.allMedia;
  protected featuredImageIdC = computed(() => this.productForm.get('featuredImageId')?.value);
  protected readonly CUSTOM_ATTRIBUTE_VALUE = CUSTOM_ATTRIBUTE_VALUE;
  protected readonly isAnyUploadPending = computed(() =>
    this.isUploading() || this.mediaFacade.isSubmitting()
  );

  // === Computed Properties ===
  protected readonly rootMedia = computed(() => {
    const allImages = filterImageMedia(this.uploadedMedia());
    const rootMediaIds = this.productForm.get('mediaIds')?.value as string[] || [];
    return rootMediaIds.map(id => allImages.find(img => img.id === id)).filter((img): img is Image => !!img);
  });

  protected readonly customAttributeGroups = computed(() => {
    const vm = this.viewModel();
    if (!vm) return null;
    const definitions = vm.customAttributeDefinitions ?? [];
    if (definitions.length === 0) return null;
    const groupsMap = definitions.reduce((acc, def) => {
      const groupName = this.translateService.instant(def.group || 'admin.products.form.otherGroup');
      if (!acc[groupName]) acc[groupName] = [];
      acc[groupName].push(def);
      return acc;
    }, {} as Record<string, CustomAttributeDefinitionDto[]>);
    return Object.entries(groupsMap).map(([name, definitions]) => ({ name, definitions }));
  });

  protected readonly specificationOptions = computed<SelectOption[]>(() => {
    const vm = this.viewModel();
    if (!vm) return [];
    return vm.displaySpecificationDefinitions.map(def => ({ value: def.specKey, label: this.translateService.instant(def.labelKeyOrText) }));
  });

  protected readonly memoizedSpecOptions = computed(() => this.specificationOptions());

  // === Lifecycle ===
  constructor() {
    this.initializeForm();
    this.setupEffects();
    this.setupMediaSync();
  }

  ngOnInit(): void {
    this.setupFormMonitoring();
    this.loadCategoryMapping();
    this.productForm.updateValueAndValidity();
  }

  // === Form Accessors ===
  get variantAttributes(): FormArray { return this.productForm.get('variantAttributes') as FormArray; }
  get variantCombinations(): FormArray { return this.productForm.get('variantCombinations') as FormArray; }
  get displaySpecifications(): FormArray { return this.productForm.get('displaySpecifications') as FormArray; }
  getAttributeValues(attr: AbstractControl): FormArray { return (attr as FormGroup).get('values') as FormArray; }

  getAttributeDisplayValueForCombination(combo: AbstractControl, formAttributeTempId: string): string {
    const attrsInCombo = combo.get('attributes')?.value as { attributeId: string, attributeNameKeyOrText: string, attributeValueId: string, attributeValueNameKeyOrText: string, colorHex: string | null }[];
    if (!attrsInCombo || attrsInCombo.length === 0) return 'N/A';

    const formAttrControl = this.variantAttributes.controls.find(c => c.get('tempId')?.value === formAttributeTempId);
    if (!formAttrControl) {
      return 'Fout';
    }
    const formAttributeName = formAttrControl.get('nameKeyOrText')?.value;

    const relevantComboAttribute = attrsInCombo.find(a => a.attributeNameKeyOrText === formAttributeName);

    return relevantComboAttribute?.attributeValueNameKeyOrText ?? 'N/A';
  }

  // === Debug Overlay Methods ===
  protected toggleDebugOverlay(): void {
    this.showDebugOverlay.set(!this.showDebugOverlay());
  }

  protected closeDebugOverlay(): void {
    this.showDebugOverlay.set(false);
  }

  // === Public Methods ===
  onSave(): void {
    if (this.isAnyUploadPending()) {
      this.notificationService.showWarning('Please wait for media uploads to complete');
      return;
    }

    this.productForm.markAllAsTouched();
    if (this.productForm.invalid) { this.showValidationErrors(); return; }
    const payload = this.mapFormToPayload();

    console.log('%c[ProductFormComponent] FINAL PAYLOAD TO BE SENT:', 'color: #4CAF50; font-weight: bold; font-size: 14px;', structuredClone(payload));

    this.saveProduct.emit(payload);
  }

  handleFileUploads(files: File[]): void {
    this.isUploading.set(true);
    this.processFilesSequentially(files);
  }

  private processFilesSequentially(files: File[]): void {
    from(files).pipe(
      concatMap(file =>
        this.mediaApiService.createMedia({
          altText: file.name.split('.').slice(0, -1).join('.'),
          type: 'image'
        }, file).pipe(
          tap(media => {
            this.store.dispatch(MediaActions.mediaLoadedFromSource({ media: [media] }));
          }),
          catchError(error => {
            console.error('Upload failed for', file.name, error);
            return EMPTY;
          })
        )
      ),
      finalize(() => {
        this.isUploading.set(false);
        this.notificationService.showSuccess('All uploads completed');
      }),
      takeUntilDestroyed(this.destroyRef)
    ).subscribe();
  }

  // === Variant Management ===
  addVariantAttribute(): void {
    this.variantAttributes.push(this.createVariantAttribute({}));
  }
  removeVariantAttribute(index: number): void {
    this.variantAttributes.removeAt(index);
    this.generateCombinations();
  }
  addAttributeValue(attrCtrl: AbstractControl): void {
    this.getAttributeValues(attrCtrl).push(this.createAttributeValue({}));
    setTimeout(() => this.generateCombinations(), 0);
  }
  removeAttributeValue(attrCtrl: AbstractControl, valueIndex: number): void {
    this.getAttributeValues(attrCtrl).removeAt(valueIndex);
    this.generateCombinations();
  }
  onAttributeNameChange(attrCtrl: AbstractControl): void {
    const name = attrCtrl.get('nameKeyOrText')?.value;
    attrCtrl.patchValue({ type: this.inferAttributeType(name) }, { emitEvent: false });
    this.getAttributeValues(attrCtrl).clear();
    this.generateCombinations();
  }

  // === Display Specifications ===
  addDisplaySpecification(): void { this.displaySpecifications.push(this.createDisplaySpecification()); }
  removeDisplaySpecification(index: number): void { this.displaySpecifications.removeAt(index); }

  // === MEDIA MANAGEMENT SECTION ===
  setFeaturedImage(mediaId: string | null): void {
    this.productForm.get('featuredImageId')?.setValue(mediaId);
  }

  manageRootMedia(): void {
    const rootMediaControl = this.productForm.get('mediaIds');
    if (!rootMediaControl) return;

    const dialogRef = this.overlayService.open<string[]>({
      component: VariantImageManagerComponent,
      data: {
        allProductImages: filterImageMedia(this.uploadedMedia()),
        linkedMediaIds: rootMediaControl.value || [],
        variantDisplayName: 'General Product Images'
      },
      backdropType: 'dark', closeOnClickOutside: false, maxWidth: '800px', height: '70vh'
    });

    dialogRef.afterClosed$.pipe(take(1)).subscribe(result => {
      if (result) {
        rootMediaControl.setValue(result);
        rootMediaControl.markAsDirty();
        const currentFeaturedId = this.featuredImageIdC();
        if ((currentFeaturedId && !result.includes(currentFeaturedId)) || (!currentFeaturedId && result.length > 0)) {
          this.setFeaturedImage(result[0] || null);
        }
      }
    });
  }

  manageCombinationMedia(combinationControl: AbstractControl): void {
    const dialogRef = this.overlayService.open<string[]>({
      component: VariantImageManagerComponent,
      data: {
        allProductImages: filterImageMedia(this.uploadedMedia()),
        linkedMediaIds: combinationControl.get('mediaIds')?.value || [],
        variantDisplayName: `Combination: ${combinationControl.get('sku')?.value || 'New'}`
      },
      backdropType: 'dark', closeOnClickOutside: false, maxWidth: '800px', height: '70vh'
    });
    dialogRef.afterClosed$.pipe(take(1)).subscribe(result => {
      if (result) {
        combinationControl.get('mediaIds')?.setValue(result);
        combinationControl.markAsDirty();
      }
    });
  }

  removeMedia(id: string): void {
    if (!confirm('Are you sure you want to permanently delete this media item? It will be removed from all assignments.')) {
      return;
    }
    this.mediaFacade.deleteMedia(id);
    if (this.featuredImageIdC() === id) {
      this.setFeaturedImage(null);
    }
    const rootMediaControl = this.productForm.get('mediaIds');
    if (rootMediaControl) {
      const currentRootMediaIds = (rootMediaControl.value as string[]).filter(mediaId => mediaId !== id);
      if (currentRootMediaIds.length !== (rootMediaControl.value as string[]).length) {
        rootMediaControl.setValue(currentRootMediaIds, { emitEvent: false });
        rootMediaControl.markAsDirty();
      }
    }
    this.variantCombinations.controls.forEach(comboControl => {
      const mediaIdsControl = comboControl.get('mediaIds');
      if (mediaIdsControl) {
        const currentIds = (mediaIdsControl.value as string[]).filter(mediaId => mediaId !== id);
        if (currentIds.length !== (mediaIdsControl.value as string[]).length) {
          mediaIdsControl.setValue(currentIds, { emitEvent: false });
          mediaIdsControl.markAsDirty();
        }
      }
    });
    this.notificationService.showSuccess('Media item successfully deleted and removed from assignments.');
  }

  private loadProductMediaIntoState(product: Product): void {
    if (!product.media || product.media.length === 0) {
        return;
    }

    console.log('[ProductFormComponent] Loading product media into MediaFacade state:', product.media);
    
    this.store.dispatch(MediaActions.mediaLoadedFromSource({ 
        media: [...product.media] 
    }));
  }

  // === Combinations ===
  setDefaultVariant(selectedIndex: number): void { this.variantCombinations.controls.forEach((c, i) => c.get('isDefault')?.setValue(i === selectedIndex, { emitEvent: false })); }

  // === Helper Methods ===
  getPredefinedValues(attrName?: string | null): PredefinedAttributeValueDto[] | undefined { 
    const titleCaseName = attrName ? (attrName.split('.').pop() || '').charAt(0).toUpperCase() + (attrName.split('.').pop() || '').slice(1) : '';
    return this.viewModel()?.predefinedAttributes?.[titleCaseName]; 
  }

  getCombinationPrimaryImage(comboCtrl: AbstractControl): Image | undefined { const ids = comboCtrl.get('mediaIds')?.value as string[] | null; return ids?.length ? filterImageMedia(this.uploadedMedia()).find(img => img.id === ids[0]) : undefined; }
  getValidationRule(def: CustomAttributeDefinitionDto, rule: 'min' | 'max'): number { try { return (JSON.parse(def.validationRulesJson || '{}'))[rule] ?? (rule === 'min' ? 0 : 100); } catch { return rule === 'min' ? 0 : 100; } }
  comparePredefinedValues(o1: any, o2: any): boolean {
    if (o1 === CUSTOM_ATTRIBUTE_VALUE || o2 === CUSTOM_ATTRIBUTE_VALUE) return o1 === o2;
    return (typeof o1 === 'object' && o1 && typeof o2 === 'object' && o2) ? o1.id === o2.id : o1 === o2;
  }

  // === CONSOLIDATED TRACKBY FUNCTIONS ===
  protected trackByTempId = (index: number, control: AbstractControl) => control.get('tempId')?.value ?? index;
  protected trackByCombination = (index: number, control: AbstractControl) => { 
    const attrs = control.get('attributes')?.value as { attributeId: string, attributeValueId: string }[]; 
    return attrs ? attrs.map(a => a.attributeValueId).sort().join('-') : index; 
  };

  // === CONSOLIDATED ERROR HANDLING ===
  protected getErrorMessage(control: AbstractControl | null): string {
    if (!control || !control.touched || control.valid) return '';
    
    if (control.hasError('required')) {
      return this.translateService.instant('common.errors.validation.requiredField');
    }
    if (control.hasError('duplicate')) {
      return this.translateService.instant('admin.products.form.duplicateSku');
    }
    return this.translateService.instant('common.errors.validation.invalidField');
  }

  protected getFieldError(path: string): string {
    return this.getErrorMessage(this.productForm.get(path));
  }

  protected getArrayError(arrayControl: AbstractControl, index: number, fieldName: string): string {
    const control = (arrayControl.get('values') as FormArray)?.at(index)?.get(fieldName);
    return this.getErrorMessage(control);
  }

  protected getCombinationError(index: number, fieldName: string): string {
    const control = this.variantCombinations?.at(index)?.get(fieldName);
    return this.getErrorMessage(control);
  }

  protected getSpecError(index: number, fieldName: string): string {
    const control = this.displaySpecifications?.at(index)?.get(fieldName);
    return this.getErrorMessage(control);
  }

  // === SIMPLIFIED MEDIA UTILITIES ===
  protected getMediaDisplayUrl(media?: Media): string {
    if (!media) return '';
    
    return media.type === MediaType.IMAGE 
      ? (media as Image).variants?.[0]?.url || ''
      : (media as any)?.url || '';
  }

  protected getMediaDisplayText(media: Media): string {
    return media.type === MediaType.IMAGE 
      ? (media as Image).altText || 'Image'
      : (media as any).title || 'Media';
  }

  // Backwards compatibility aliases
  getMediaUrl = this.getMediaDisplayUrl;
  getMediaAltText = this.getMediaDisplayText;

  // === Template Helper Methods ===
  protected hasCustomAttributes(): boolean {
    const customAttrs = this.productForm.get('customAttributes')?.value;
    return customAttrs && Object.keys(customAttrs).length > 0;
  }

  protected getCustomAttributeKeys(): string[] {
    const customAttrs = this.productForm.get('customAttributes')?.value;
    return customAttrs ? Object.keys(customAttrs) : [];
  }

  protected formatCustomAttributeLabel(key: string): string {
    return key
      .replace(/([A-Z])/g, ' $1')
      .replace(/_/g, ' ')
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ');
  }

  protected reloadProductMedia(): void {
    const product = this.product();
    if (product) {
      this.loadProductMediaIntoState(product);
      this.notificationService.showInfo('Media reloaded into state');
    }
  }

  // === CONSOLIDATED DEBUG SYSTEM ===
  private debugState(section: 'variant' | 'media' | 'category' | 'attribute', action?: string): void {
    console.group(`%c[DEBUG] ${section.toUpperCase()} ${action || 'State'}`, 'color: #9C27B0; font-weight: bold;');
    
    switch (section) {
      case 'variant':
        try {
          const rawValue = this.productForm.getRawValue();
          console.log('%c--- RAW FORM VALUE (CLONED) ---', 'color: #03A9F4; font-weight: bold;', structuredClone(rawValue));
          const payload = this.mapFormToPayload();
          console.log('%c--- MAPPED PAYLOAD PREVIEW (CLONED) ---', 'color: #4CAF50; font-weight: bold;', structuredClone(payload));
        } catch (e) {
          console.error("Error during debug state creation:", e);
        }
        break;
        
      case 'media':
        console.log('All media from facade:', this.uploadedMedia());
        console.log('Root media IDs from form:', this.productForm.get('mediaIds')?.value as string[] || []);
        console.log('Root media computed:', this.rootMedia());
        console.log('Featured image ID:', this.featuredImageIdC());
        this.variantCombinations.controls.forEach((combo, i) => {
          const mediaIds = combo.get('mediaIds')?.value as string[] || [];
          console.log(`Combination ${i} media IDs:`, mediaIds);
        });
        break;
        
      case 'category':
        const selectedIds = this.productForm.get('categoryIds')?.value || [];
        console.log('Selected category IDs:', selectedIds);
        console.log('Category key map size:', this.categoryKeyMap.size);
        const vm = this.viewModel();
        console.log('Available categories count:', vm?.allCategories?.length);
        if (action === 'tree') {
          this.categoryTreeService.getCategoryTreeAsync().then(categories => {
            console.log('Full category tree:', categories);
            const logTreeStructure = (items: any[], level = 0) => {
              items.forEach(item => {
                const indent = '  '.repeat(level);
                console.log(`${indent}${item.name || item.key} (ID: ${item.id})`);
                if (item.children && item.children.length > 0) {
                  logTreeStructure(item.children, level + 1);
                }
              });
            };
            console.log('\n=== Tree Structure ===');
            logTreeStructure(categories);
            if (selectedIds.length > 0) {
              console.log('\n=== Testing Current Selection ===');
              selectedIds.forEach((id: string) => {
                const parents = this.findCategoryParentChain(categories, id);
                console.log(`Category ${id} has parents:`, parents);
              });
            }
          }).catch(error => {
            console.error('Error loading category tree:', error);
          });
        }
        break;
        
      case 'attribute':
        const vmAttr = this.viewModel();
        console.log('Available attribute names:', vmAttr?.attributeNames);
        this.variantAttributes.controls.forEach((attr, i) => {
          const nameKeyOrText = attr.get('nameKeyOrText')?.value;
          console.log(`Attribute ${i} nameKeyOrText:`, nameKeyOrText);
          console.log(`Is in attributeNames:`, vmAttr?.attributeNames?.includes(nameKeyOrText));
        });
        break;
    }
    
    console.groupEnd();
  }

  protected debugVariantState = () => this.debugState('variant');
  protected debugMediaState = () => this.debugState('media');
  protected debugCategoryState = () => this.debugState('category');
  protected debugCategoryTree = () => this.debugState('category', 'tree');
  protected debugAttributeState = () => this.debugState('attribute');

  protected async testCategoryParents(): Promise<void> {
    const selectedIds = this.productForm.get('categoryIds')?.value || [];
    if (selectedIds.length === 0) {
      console.log('No categories selected to test');
      return;
    }

    console.log('Testing parent selection for:', selectedIds);
    const withParents = await this.ensureCategoryParentsSelected(selectedIds);
    console.log('Result with parents:', withParents);

    this.productForm.get('categoryIds')?.setValue(withParents);
  }

  // === Form Creation Helpers ===
private createFormControl<T>(value: T, validators: ValidatorFn[] = []) {
  return this.fb.control(value, validators);
}

private createRequiredControl<T>(value: T, additionalValidators: ValidatorFn[] = []) {
  return this.fb.control(value, [Validators.required, ...additionalValidators]);
}


  // === Private Methods ===
  private initializeForm(): void {
    this.productForm = this.fb.group({
      type: [ProductType.PHYSICAL, Validators.required], name: ['', Validators.required], description: [''], shortDescription: [null],
      status: [ProductStatus.DRAFT, Validators.required], isActive: [true], isFeatured: [false], currency: ['EUR', Validators.required],
      appScope: ['plushie-paradise'], tags: [[]], categoryIds: [[]], mediaIds: this.fb.control([]), featuredImageId: [null],
      variantAttributes: this.fb.array([]), variantCombinations: this.fb.array([], { validators: [this.combinationsValidator()] }),
      customAttributes: this.fb.group({}), displaySpecifications: this.fb.array([]),
      physicalProductConfig: this.fb.group({
        pricing: this.fb.group({ price: [null], originalPrice: [null] }, { validators: this.priceValidator() }),
        sku: [null], brand: [null], manageStock: [true], stockQuantity: [null], allowBackorders: [false], lowStockThreshold: [null],
        availabilityRules: this.fb.group({ minOrderQuantity: [null], maxOrderQuantity: [null], quantityIncrements: [null], isActive: [true] }, { validators: this.createMinMaxValidator('minOrderQuantity', 'maxOrderQuantity') }),
        ageRestrictions: this.fb.group({ minAge: [null], maxAge: [null] }, { validators: this.createMinMaxValidator('minAge', 'maxAge') })
      }, { validators: this.physicalProductConfigValidator() }),
      seo: this.fb.group({ title: [null], description: [null], keywords: [null], imageUrl: [null] })
    });
  }

  private setupEffects(): void {
    effect(() => {
      const productToEdit = this.product();
      const vm = this.viewModel();
      if (productToEdit && this.productForm && vm?.predefinedAttributes) {
        if (!this.hasBeenPatched || this.lastPatchedProductId !== productToEdit.id) {
          this.patchFormForEdit(productToEdit);
          this.hasBeenPatched = true;
          this.lastPatchedProductId = productToEdit.id;
        }
      }
    });

    effect(() => {
      const vm = this.viewModel();
      if (vm?.customAttributeDefinitions && this.productForm && !this.customAttributesInitialized) {
        const productToEdit = this.product();
        if (productToEdit?.customAttributes) {
          this.initializeCustomAttributes(productToEdit.customAttributes);
        } this.customAttributesInitialized = true;
      }
    });
  }

  private async loadCategoryMapping(): Promise<void> {
    try {
      const categories = await this.categoryTreeService.getCategoryTreeAsync();
      this.buildCategoryKeyMap(categories);
    } catch (error) {
      console.warn('Could not load category mapping:', error);
    }
  }

  private buildCategoryKeyMap(categories: any[]): void {
    const processCategory = (cat: any) => {
      this.categoryKeyMap.set(cat.id, cat.key);
      if (cat.children) {
        cat.children.forEach(processCategory);
      }
    };
    categories.forEach(processCategory);
  }

  private setupMediaSync(): void {
    this.mediaFacade.allMedia$.pipe(startWith([] as readonly Media[]), pairwise(), takeUntilDestroyed(this.destroyRef)).subscribe(([prev, curr]) => {
      const idMap = new Map<string, string>();
      const newFinalMedia = curr.filter(c => !c.id.startsWith('temp_') && !prev.some(p => p.id === c.id));
      newFinalMedia.forEach(final => {
        const tempMatch = prev.find(p => p.id.startsWith('temp_') && p.title === final.title);
        if (tempMatch) idMap.set(tempMatch.id, final.id);
      });
      if (idMap.size > 0) this.syncMediaIdsInForm(idMap);
    });
  }

  private setupFormMonitoring(): void {
    this.variantAttributes.valueChanges.pipe(
        auditTime(0),
        filter(() => this.isVariantInputComplete()),
        distinctUntilChanged((prev, curr) => JSON.stringify(prev) === JSON.stringify(curr)),
        takeUntilDestroyed(this.destroyRef)
    ).subscribe(() => {
        if (!this.isPatching) {
            this.generateCombinations();
        }
    });

    this.displaySpecifications.controls.forEach(c => this.monitorSpecificationKey(c as FormGroup));

    this.productForm.get('physicalProductConfig.manageStock')?.valueChanges.pipe(
        takeUntilDestroyed(this.destroyRef)
    ).subscribe(() => this.productForm.get('physicalProductConfig')?.updateValueAndValidity());

    this.productForm.get('name')?.valueChanges.pipe(
        debounceTime(500), 
        distinctUntilChanged(), 
        takeUntilDestroyed(this.destroyRef)
    ).subscribe(() => { 
        if (this.variantCombinations.length > 0) {
            this.regenerateSkus(); 
        }
    });

    this.productForm.get('categoryIds')?.valueChanges.pipe(
        debounceTime(100),
        distinctUntilChanged((prev: string[], curr: string[]) => {
            if (!prev && !curr) return true;
            if (!prev || !curr) return false;
            if (prev.length !== curr.length) return false;
            return prev.every((id: string, index: number) => id === curr[index]);
        }),
        filter((selectedIds: string[]) => {
            return !this.isPatching && selectedIds && selectedIds.length > 0;
        }),
        takeUntilDestroyed(this.destroyRef)
    ).subscribe(async (selectedIds: string[]) => {
        console.log('[ProductFormComponent] Category change detected (non-patch):', selectedIds);
        await this.handleCategoryChange(selectedIds);
    });
  }

  private async handleCategoryChange(selectedIds: string[]): Promise<void> {
    console.log('[ProductFormComponent] Handling category change:', selectedIds);
    
    try {
        const categories = await this.categoryTreeService.getCategoryTreeAsync();
        const allRequiredIds = new Set<string>();
        let hasNewParents = false;
        
        for (const categoryId of selectedIds) {
            console.log(`Processing category: ${categoryId}`);
            
            const parents = this.findCategoryParentChain(categories, categoryId);
            console.log(`Found parents for ${categoryId}:`, parents);
            
            for (const parentId of parents) {
                if (!selectedIds.includes(parentId)) {
                    hasNewParents = true;
                    console.log(`New parent found: ${parentId}`);
                }
                allRequiredIds.add(parentId);
            }
            
            allRequiredIds.add(categoryId);
        }
        
        const result = Array.from(allRequiredIds);
        console.log('Final result:', result);
        console.log('Has new parents:', hasNewParents);
        
        if (hasNewParents) {
            console.log('Updating form with new parents');
            this.productForm.get('categoryIds')?.setValue(result, { emitEvent: false });
            this.notificationService.showInfo(`Auto-selected ${result.length - selectedIds.length} parent categories`);
        } else {
            console.log('No new parents to add');
        }
        
    } catch (error) {
        console.error('Error in category change handling:', error);
    }
  }

  private isVariantInputComplete(): boolean {
    const attrs = this.variantAttributes.value as AttributeFormValue[];
    if (!attrs.length) return true;
    return attrs.every(attr => !!attr.nameKeyOrText && Array.isArray(attr.values) && attr.values.length > 0 && attr.values.every(val => (val.predefinedValue === CUSTOM_ATTRIBUTE_VALUE && !!val.displayNameKeyOrText?.trim()) || (typeof val.predefinedValue === 'object' && val.predefinedValue !== null)));
  }

  private monitorSpecificationKey(group: FormGroup): void {
    group.get('specKey')?.valueChanges.pipe(takeUntilDestroyed(this.destroyRef)).subscribe(key => {
      const def = this.viewModel()?.displaySpecificationDefinitions.find(d => d.specKey === key);
      if (def) group.patchValue({ labelKeyOrText: def.labelKeyOrText, groupKeyOrText: def.groupKeyOrText }, { emitEvent: false });
    });
  }

  private syncMediaIdsInForm(idMap: Map<string, string>): void {
    const syncIds = (currentIds: string[]): { changed: boolean; ids: string[] } => {
      let changed = false;
      const newIds = currentIds.map(id => {
        if (idMap.has(id)) {
          changed = true;
          return idMap.get(id)!;
        }
        return id;
      });
      return { changed, ids: newIds };
    };

    const rootMediaControl = this.productForm.get('mediaIds');
    if (rootMediaControl) {
      const { changed, ids } = syncIds(rootMediaControl.value || []);
      if (changed) rootMediaControl.setValue(ids, { emitEvent: false });
    }

    this.variantCombinations.controls.forEach(combo => {
      const c = combo.get('mediaIds');
      if (c) {
        const { changed, ids } = syncIds(c.value || []);
        if (changed) c.setValue(ids, { emitEvent: false });
      }
    });
  }

  private initializeCustomAttributes(customAttributes: Record<string, any>): void {
    const group = this.productForm.get('customAttributes') as FormGroup;

    Object.keys(group.controls).forEach(key => group.removeControl(key));

    if (customAttributes) {
      Object.entries(customAttributes).forEach(([key, value]) => {
        const numericValue = typeof value === 'number' ?
          Math.max(1, Math.min(10, value)) : 5;

        group.addControl(key, this.fb.control(numericValue, [
          Validators.required,
          Validators.min(1),
          Validators.max(10)
        ]));
      });
    }
  }

  private patchFormForEdit(product: Product): void {
    console.log('%c[ProductFormComponent] STARTING PATCH PROCESS FOR PRODUCT:', 'color: #03A9F4; font-weight: bold; font-size: 14px;', structuredClone(product));
    
    this.loadProductMediaIntoState(product);
    
    this.isPatching = true;
    const vm = this.viewModel();
    if (!vm?.predefinedAttributes) {
        console.error('[ProductFormComponent] Patch aborted: Predefined attributes map is not available in the ViewModel.');
        this.isPatching = false;
        return;
    }

    const allPredefinedValues = new Map<string, PredefinedAttributeValueDto>();
    Object.values(vm.predefinedAttributes).forEach(valueArray => 
        valueArray.forEach(value => allPredefinedValues.set(value.id, value))
    );
    console.log('[ProductFormComponent] Created lookup map with', allPredefinedValues.size, 'predefined values.');

    this.productForm.patchValue({
        type: product.type, 
        name: product.name, 
        description: product.description,
        shortDescription: product.shortDescription, 
        status: product.status,
        isActive: product.isActive, 
        isFeatured: product.isFeatured,
        currency: product.currency, 
        appScope: product.appScope,
        tags: product.tags ? [...product.tags] : [],
        categoryIds: product.categoryIds ? [...product.categoryIds] : [],
        mediaIds: (product.media?.map(m => m.id)) ?? [],
        featuredImageId: product.media?.find(m => m.id === (product as any).featuredImage?.id)?.id ?? null,
        seo: {
            title: product.metaTitle,
            description: product.metaDescription,
            keywords: product.metaKeywords?.join(', ') ?? ''
        },
    }, { emitEvent: false });

    if (isPhysicalProduct(product)) {
        this.productForm.get('physicalProductConfig')?.patchValue({
            pricing: { price: product.price, originalPrice: product.originalPrice },
            sku: product.sku, 
            brand: product.brand, 
            manageStock: product.manageStock ?? true,
            stockQuantity: product.stockQuantity, 
            allowBackorders: product.allowBackorders,
            lowStockThreshold: product.lowStockThreshold,
            availabilityRules: product.availabilityRules ?? {},
            ageRestrictions: (product as any).ageRestrictions ?? {}
        }, { emitEvent: false });
        
        if (product.customAttributes) {
            this.initializeCustomAttributes(product.customAttributes);
        }
    }

    if (product.categoryIds && product.categoryIds.length > 0) {
        setTimeout(async () => {
            try {
                const idsWithParents = await this.ensureCategoryParentsSelected(product.categoryIds!);
                if (idsWithParents.length > product.categoryIds!.length) {
                    console.log('[ProductFormComponent] Auto-selecting parents during patch:', {
                        original: product.categoryIds,
                        withParents: idsWithParents
                    });
                    this.productForm.get('categoryIds')?.setValue(idsWithParents, { emitEvent: false });
                }
            } catch (error) {
                console.warn('[ProductFormComponent] Could not auto-select parents during patch:', error);
            }
        }, 0);
    }

    const usedAttributeIds = new Set<string>();
    product.variantCombinations?.forEach(combo => {
        combo.attributes.forEach(attrSelection => usedAttributeIds.add(attrSelection.attributeId));
    });
    console.log('[ProductFormComponent] Identified used attribute IDs:', Array.from(usedAttributeIds));

    const relevantAttributes = (product.variantAttributes ?? []).filter(attr => usedAttributeIds.has(attr.id));
    console.log(`[ProductFormComponent] Filtered down to ${relevantAttributes.length} relevant attributes.`);

    this.variantAttributes.clear({ emitEvent: false });
    relevantAttributes.forEach(attr => {
        const valuesFormGroups = (attr.values ?? []).map(val => {
            const predefinedValueObject = allPredefinedValues.get(val.id);
            return this.createAttributeValue(val, predefinedValueObject ?? null);
        });
        
        const normalizedNameKeyOrText = this.normalizeAttributeName(attr.nameKeyOrText || attr.name);
        const attrFormGroup = this.createVariantAttribute({
            ...attr,
            nameKeyOrText: normalizedNameKeyOrText
        }, valuesFormGroups);
        this.variantAttributes.push(attrFormGroup, { emitEvent: false });
    });
    console.log(`[ProductFormComponent] Patched ${this.variantAttributes.length} variant attributes into FormArray.`);

    this.variantCombinations.clear({ emitEvent: false });
    product.variantCombinations?.forEach(combo => {
        this.variantCombinations.push(this.createVariantCombination(combo), { emitEvent: false });
    });
    console.log(`[ProductFormComponent] Patched ${this.variantCombinations.length} variant combinations.`);

    this.displaySpecifications.clear({ emitEvent: false });
    if (isPhysicalProduct(product)) {
        product.displaySpecifications?.forEach(spec => {
            this.displaySpecifications.push(this.createDisplaySpecification(spec), { emitEvent: false });
        });
    }

    this.productForm.markAsPristine();
    this.productForm.updateValueAndValidity({ emitEvent: false });
    this.isPatching = false;
    console.log('%c[ProductFormComponent] PATCH PROCESS COMPLETED.', 'color: #4CAF50; font-weight: bold;');
  }

  private normalizeAttributeName(name: string | undefined): string {
    if (!name) return '';

    const vm = this.viewModel();
    if (!vm?.attributeNames) return name;

    if (vm.attributeNames.includes(name)) {
      return name;
    }

    const variations: string[] = [
      name.toLowerCase(),
      name.charAt(0).toUpperCase() + name.slice(1).toLowerCase(),
      name.replace(/[._-]/g, ' ').replace(/\b\w/g, l => l.toUpperCase())
    ];

    const lastPart = name.split('.').pop();
    if (lastPart) {
      variations.push(lastPart.charAt(0).toUpperCase() + lastPart.slice(1).toLowerCase());
    }

    for (const variation of variations.filter(Boolean)) {
      if (vm.attributeNames.includes(variation)) {
        console.log(`[ProductFormComponent] Normalized "${name}" to "${variation}"`);
        return variation;
      }
    }

    console.warn(`[ProductFormComponent] Could not normalize attribute name: "${name}". Available: `, vm.attributeNames);
    return name;
  }

  private async ensureCategoryParentsSelected(selectedCategoryIds: string[]): Promise<string[]> {
    if (!selectedCategoryIds || selectedCategoryIds.length === 0) {
      return [];
    }

    try {
      const categories = await this.categoryTreeService.getCategoryTreeAsync();
      const allRequiredIds = new Set<string>();

      for (const categoryId of selectedCategoryIds) {
        const parentChain = this.findCategoryParentChain(categories, categoryId);
        parentChain.forEach(parentId => allRequiredIds.add(parentId));
        allRequiredIds.add(categoryId);
      }

      const result = Array.from(allRequiredIds);

      if (result.length > selectedCategoryIds.length) {
        console.log('[ProductFormComponent] Auto-selected category parents:', {
          original: selectedCategoryIds,
          withParents: result,
          addedParents: result.filter(id => !selectedCategoryIds.includes(id))
        });
      }

      return result;
    } catch (error) {
      console.warn('[ProductFormComponent] Could not auto-select category parents:', error);
      return selectedCategoryIds;
    }
  }

  private findCategoryParentChain(categories: any[], targetCategoryId: string): string[] {
    if (this.categoryParentCache.has(targetCategoryId)) {
      return this.categoryParentCache.get(targetCategoryId)!;
    }

    const findInTree = (items: any[], targetId: string, currentPath: string[] = []): string[] | null => {
      for (const item of items) {
        const newPath = [...currentPath, item.id];

        if (item.id === targetId) {
          return currentPath;
        }

        if (item.children && Array.isArray(item.children) && item.children.length > 0) {
          const found = findInTree(item.children, targetId, newPath);
          if (found !== null) {
            return found;
          }
        }
      }
      return null;
    };

    const parentChain = findInTree(categories, targetCategoryId) || [];
    this.categoryParentCache.set(targetCategoryId, parentChain);
    return parentChain;
  }

  private createVariantAttribute(attr: Partial<VariantAttribute>, values: FormGroup[] = []): FormGroup {
    const arr = values.length ? this.fb.array(values) : this.fb.array((attr.values ?? []).map(v => this.createAttributeValue(v)));
    return this.fb.group({ 
      tempId: [attr.id ?? uuidv4()], 
      nameKeyOrText: [attr.nameKeyOrText ?? attr.name, Validators.required], 
      type: [attr.type ?? VariantAttributeType.CUSTOM, Validators.required], 
      displayType: [attr.displayType], 
      isRequired: [attr.isRequired ?? true], 
      values: arr 
    });
  }

  private createAttributeValue(val: Partial<VariantAttributeValue>, initialPredefinedValue: PredefinedAttributeValueDto | null = null): FormGroup {
    const initialDisplayName = val.displayName ?? initialPredefinedValue?.displayName ?? '';

    const group = this.fb.group({
      tempId: [val.id ?? uuidv4()],
      predefinedValue: [initialPredefinedValue],
      displayNameKeyOrText: [initialDisplayName],
      colorHex: [val.colorHex ?? initialPredefinedValue?.colorHex ?? null],
      priceModifier: [val.priceModifier ?? initialPredefinedValue?.priceModifier ?? null],
      isAvailable: [val.isAvailable ?? true]
    });

    group.get('predefinedValue')?.valueChanges.pipe(
      takeUntilDestroyed(this.destroyRef),
      distinctUntilChanged()
    ).subscribe(v => {
      if (v && typeof v === 'object' && v !== null) {
        group.patchValue({
          displayNameKeyOrText: v.displayName || v.name || '',
          colorHex: v.colorHex ?? null,
          priceModifier: v.priceModifier ?? null
        });
      } else if (v === CUSTOM_ATTRIBUTE_VALUE) {
        group.get('displayNameKeyOrText')?.enable();
        group.patchValue({ displayNameKeyOrText: '' });
      }
    });
    return group;
  }

  private createVariantCombination(combo?: Partial<ProductVariantCombination>): FormGroup {
    return this.fb.group({
      sku: this.createRequiredControl(combo?.sku ?? ''),
      price: this.createRequiredControl(combo?.price),
      originalPrice: this.createFormControl(combo?.originalPrice),
      stockQuantity: this.createRequiredControl(combo?.stockQuantity),
      stockStatus: this.createRequiredControl(combo?.stockStatus ?? StockStatus.IN_STOCK),
      isActive: this.createRequiredControl(combo?.isActive ?? true),
      isDefault: this.createFormControl(combo?.isDefault ?? false),
      attributes: this.fb.array((combo?.attributes ?? []).map(a => this.fb.group(a))),
      mediaIds: this.createFormControl(combo?.mediaIds ?? [])
    });
  }

  private createDisplaySpecification(spec?: Partial<ProductDisplaySpecification>): FormGroup {
    return this.fb.group({ 
      tempId: [uuidv4()], 
      specKey: [spec?.specKey ?? '', Validators.required], 
      labelKeyOrText: [{ value: spec?.labelKeyOrText ?? '', disabled: true }], 
      valueKeyOrText: [spec?.valueKeyOrText ?? '', Validators.required], 
      groupKeyOrText: [{ value: spec?.groupKeyOrText ?? '', disabled: true }] 
    });
  }

  private generateCombinations(): void {
    const formValues = this.variantAttributes.getRawValue() as AttributeFormValue[];
    const combinations = this.variantCombinations;
    if (formValues.length === 0 || !this.viewModel()?.predefinedAttributes) {
      combinations.clear();
      combinations.updateValueAndValidity();
      return;
    }

    const attributeDataForGeneration = formValues.map(attr => ({
      attributeId: attr.tempId,
      attributeName: attr.nameKeyOrText,
      values: attr.values.map(val => {
        if (val.predefinedValue === CUSTOM_ATTRIBUTE_VALUE) {
          return {
            valueId: val.tempId,
            displayName: val.displayNameKeyOrText,
            priceModifier: val.priceModifier ?? 0
          };
        }
        if (typeof val.predefinedValue === 'object' && val.predefinedValue !== null) {
          return {
            valueId: val.predefinedValue.id,
            displayName: val.predefinedValue.displayName,
            priceModifier: val.predefinedValue.priceModifier ?? 0
          };
        }
        return null;
      }).filter((v): v is { valueId: string; displayName: string; priceModifier: number; } => v !== null)
    })).filter(attr => attr.values.length > 0);

    const valueArrays = attributeDataForGeneration.map(attr =>
      attr.values.map(val => ({
        attributeId: attr.attributeId,
        ...val
      }))
    );

    const newCombinations = this.cartesianProduct(valueArrays);
    const existingCombos = new Map(combinations.controls.map(c => [this.getCombinationKey(c.get('attributes')?.value), c.getRawValue()]));

    combinations.clear();
    const prodName = this.sanitizeForSku(this.productForm.get('name')?.value || 'PRODUCT');
    const basePrice = Number(this.productForm.get('physicalProductConfig.pricing.price')?.value) || 0;

    newCombinations.forEach((comboParts: any[], i: number) => {
      const attributesForCombo = comboParts.map(p => ({ attributeId: p.attributeId, attributeValueId: p.valueId }));
      const key = this.getCombinationKey(attributesForCombo);
      const prev = existingCombos.get(key);

      const skuParts = attributeDataForGeneration.map(attr => {
        const part = comboParts.find(p => p.attributeId === attr.attributeId);
        return this.sanitizeForSku(part?.displayName ?? '');
      }).filter(p => p);

      const genSku = `SKU-${prodName}${skuParts.length ? '-' + skuParts.join('-') : ''}`;
      const finalSku = prev?.sku ?? genSku;
      const priceModifierSum = comboParts.reduce((sum, part) => sum + (part.priceModifier || 0), 0);
      const calculatedPrice = basePrice + priceModifierSum;
      const finalPrice = prev?.price ?? (calculatedPrice > 0 ? calculatedPrice : 0.01);

      combinations.push(this.createVariantCombination({
        sku: finalSku, price: finalPrice, originalPrice: prev?.originalPrice,
        stockQuantity: prev?.stockQuantity ?? 10, stockStatus: prev?.stockStatus ?? StockStatus.IN_STOCK,
        isActive: prev?.isActive ?? true, isDefault: prev?.isDefault ?? i === 0,
        attributes: attributesForCombo, mediaIds: prev?.mediaIds ?? []
      }), { emitEvent: false });
    });

    if (combinations.length > 0 && !combinations.controls.some(c => c.get('isDefault')?.value)) {
      combinations.controls[0].get('isDefault')?.setValue(true, { emitEvent: false });
    }
    combinations.updateValueAndValidity();
  }

  private getDisplayNameFromValueControl(valueControl: AbstractControl | AttributeValueFormValue): string {
    const raw = 'getRawValue' in valueControl ? valueControl.getRawValue() : valueControl;
    const dn = raw.displayNameKeyOrText;
    if (dn) return dn;
    const pv = raw.predefinedValue;
    return (pv && typeof pv === 'object') ? (pv.displayName || pv.name || 'Unknown') : 'Unknown';
  }

  private sanitizeForSku(text: string): string {
    if (!text) return 'UNKNOWN';
    const noDiacritics = text.normalize('NFD').replace(/\p{Diacritic}/gu, '');
    return noDiacritics.toUpperCase().replace(/[^A-Z0-9\s-]/g, '').trim().replace(/\s+/g, '-').replace(/-+/g, '-').substring(0, 15);
  }

  private getCombinationKey(attrs: any[]): string { return attrs ? attrs.map(a => a.attributeValueId).sort().join('|') : ''; }

  regenerateSkus(): void {
    const prodName = this.sanitizeForSku(this.productForm.get('name')?.value || 'PRODUCT');
    this.variantCombinations.controls.forEach((combo, i) => {
      const attrs = (combo.get('attributes') as FormArray).getRawValue();
      const parts: string[] = [];
      attrs.forEach((attr: any) => {
        const attrCtrl = this.variantAttributes.controls.find(c => c.get('tempId')?.value === attr.attributeId);
        if (attrCtrl) {
          const valCtrl = (attrCtrl.get('values') as FormArray).controls.find(v => v.get('tempId')?.value === attr.attributeValueId);
          if (valCtrl) parts.push(this.sanitizeForSku(this.getDisplayNameFromValueControl(valCtrl)));
        }
      });
      combo.get('sku')?.setValue(`SKU-${prodName}${parts.length > 0 ? '-' + parts.join('-') : `-V${i + 1}`}`, { emitEvent: false });
    });
    this.variantCombinations.updateValueAndValidity();
    this.notificationService.showInfo('All SKUs have been regenerated');
  }

  private mapFormToPayload(): CreateProductPayload | UpdateProductPayload {
    const formValue = this.productForm.getRawValue();

    const safeNullableArray = (arr?: any[]): any[] | null => Array.isArray(arr) && arr.length > 0 ? arr : null;

    const seo = (formValue.seo?.title || formValue.seo?.description || formValue.seo?.keywords) ? {
      title: formValue.seo.title || null,
      description: formValue.seo.description || null,
      keywords: formValue.seo.keywords ? formValue.seo.keywords.split(',').map((k: string) => k.trim()).filter(Boolean) : null,
      imageUrl: formValue.seo.imageUrl || null
    } : null;

    const variantAttributes = safeNullableArray(formValue.variantAttributes)?.map((attr: any) => ({
      tempId: attr.tempId,
      nameKeyOrText: attr.nameKeyOrText,
      type: attr.type,
      displayType: attr.displayType,
      isRequired: attr.isRequired,
      values: (attr.values || []).map((val: any) => {
        const isCustom = val.predefinedValue === CUSTOM_ATTRIBUTE_VALUE;
        return {
          tempId: val.tempId,
          value: isCustom ? val.displayNameKeyOrText.toLowerCase().replace(/\s+/g, '-') : (val.predefinedValue?.value ?? ''),
          displayNameKeyOrText: isCustom ? val.displayNameKeyOrText : (val.predefinedValue?.displayName ?? ''),
          colorHex: val.colorHex,
          priceModifier: val.priceModifier,
          isAvailable: val.isAvailable,
          predefinedValue: isCustom || !val.predefinedValue ? null : val.predefinedValue
        };
      })
    }));

    const variantOverrides = safeNullableArray(formValue.variantCombinations)?.map((combo: any) => ({
      tempAttributeValueIds: (combo.attributes || []).map((a: any) => a.attributeValueId),
      price: Number(combo.price),
      originalPrice: combo.originalPrice ? Number(combo.originalPrice) : null,
      stockQuantity: Number(combo.stockQuantity),
      sku: combo.sku,
      isDefault: combo.isDefault,
      isActive: combo.isActive,
      mediaIds: safeNullableArray(combo.mediaIds),
      stockStatus: combo.stockStatus
    }));

    const basePayload = {
      ...formValue,
      seo,
      variantAttributes,
      variantOverrides,
      tags: safeNullableArray(formValue.tags),
      categoryIds: safeNullableArray(formValue.categoryIds),
      mediaIds: safeNullableArray(formValue.mediaIds)
    };

    if (formValue.type === ProductType.PHYSICAL && formValue.physicalProductConfig) {
      basePayload.physicalProductConfig = {
        ...formValue.physicalProductConfig,
        pricing: {
          price: Number(formValue.physicalProductConfig.pricing.price) || null,
          originalPrice: Number(formValue.physicalProductConfig.pricing.originalPrice) || null
        },
        stockQuantity: formValue.physicalProductConfig.stockQuantity ?? null,
        displaySpecifications: safeNullableArray(formValue.displaySpecifications?.map((s: any) => ({
          ...s,
          icon: null,
          displayOrder: 0
        }))),
        ageRestrictions: (formValue.physicalProductConfig.ageRestrictions?.minAge || formValue.physicalProductConfig.ageRestrictions?.maxAge)
          ? formValue.physicalProductConfig.ageRestrictions
          : null
      };
    }

    basePayload.customAttributes = Object.keys(formValue.customAttributes || {}).length > 0
      ? formValue.customAttributes
      : null;

    delete (basePayload as any).variantCombinations;

    return this.isEditMode() ? basePayload as UpdateProductPayload : { ...basePayload, type: formValue.type } as CreateProductPayload;
  }

  protected cartesianProduct<T>(arrays: T[][]): T[][] { return arrays.reduce<T[][]>((a, b) => a.flatMap(x => b.map(y => [...x, y])), [[]]); }

  private showValidationErrors(): void {
    const controlLabelMap: Record<string, string> = { 
      'name': 'admin.products.form.productName', 
      'physicalProductConfig.pricing.price': 'admin.products.form.price', 
      'currency': 'admin.products.form.currency', 
      'physicalProductConfig.stockQuantity': 'admin.products.form.stockQuantity', 
      'variantCombinations.*.sku': 'admin.products.form.tableHeaders.SKU', 
      'variantCombinations.*.price': 'admin.products.form.tableHeaders.Price', 
      'variantCombinations.*.stockQuantity': 'admin.products.form.tableHeaders.Stock', 
      'displaySpecifications.*.valueKeyOrText': 'admin.products.form.displayValue', 
      'displaySpecifications.*.specKey': 'admin.products.form.specKeyInternal', 
      'variantAttributes.*.values.*.displayNameKeyOrText': 'admin.products.form.displayNameNew' 
    };
    this.overlayService.open({ 
      component: ValidationSummaryDialogComponent, 
      data: { 
        errors: this.validationService.getFormErrors(this.productForm, controlLabelMap), 
        fullFormData: this.productForm.getRawValue() 
      }, 
      backdropType: 'dark' 
    });
  }

  private inferAttributeType(name: string): VariantAttributeType { 
    const map: Record<string, VariantAttributeType> = { 
      'Color': VariantAttributeType.COLOR, 
      'Size': VariantAttributeType.SIZE, 
      'Material': VariantAttributeType.MATERIAL, 
      'Style': VariantAttributeType.STYLE 
    }; 
    return map[name] ?? VariantAttributeType.CUSTOM; 
  }

  // === CONSOLIDATED VALIDATORS ===
  private createMinMaxValidator(minField: string, maxField: string, errorKey = 'minMaxInvalid'): ValidatorFn {
    return (group: AbstractControl): ValidationErrors | null => {
      if (!(group instanceof FormGroup)) return null;
      
      const min = group.get(minField)?.value;
      const max = group.get(maxField)?.value;
      
      return (min !== null && max !== null && min > max) 
        ? { [errorKey]: true } 
        : null;
    };
  }

  private priceValidator(): ValidatorFn {
    return (group: AbstractControl): ValidationErrors | null => {
      if (!(group instanceof FormGroup) || !group.parent) return null;
      const priceControl = group.get('price');
      const originalPriceControl = group.get('originalPrice');
      const price = priceControl?.value;
      const originalPrice = originalPriceControl?.value;
      const rootForm = group.root as FormGroup;
      const variantCombinations = (rootForm.get('variantCombinations') as FormArray);
      priceControl?.setErrors(null);
      if ((!variantCombinations || variantCombinations.length === 0) && (price === null || price === undefined || price < 0)) {
        priceControl?.setErrors({ required: true });
      }
      if (price !== null && originalPrice !== null && price > originalPrice) {
        priceControl?.setErrors({ ...(priceControl.errors || {}), priceInvalid: true });
      }
      return priceControl?.errors ? { ...priceControl.errors } : null;
    };
  }

  private physicalProductConfigValidator(): ValidatorFn {
    return (group: AbstractControl): ValidationErrors | null => {
      if (!(group instanceof FormGroup) || !group.parent) return null;
      const manageStockControl = group.get('manageStock');
      const stockQuantityControl = group.get('stockQuantity');
      const rootForm = group.root as FormGroup;
      const variantCombinations = (rootForm.get('variantCombinations') as FormArray);
      if (stockQuantityControl) {
        stockQuantityControl.setErrors(null);
      }
      if (manageStockControl?.value && (!variantCombinations || variantCombinations.length === 0)) {
        if (stockQuantityControl?.value === null || stockQuantityControl?.value === undefined || stockQuantityControl.value < 0) {
          const error = { required: true, stockQuantityRequired: true };
          if (stockQuantityControl) {
            stockQuantityControl.setErrors(error);
          }
          return error;
        }
      }
      return null;
    };
  }

  private combinationsValidator(): ValidatorFn {
    return (formArray: AbstractControl): ValidationErrors | null => {
      if (!(formArray instanceof FormArray)) return null;
      const controls = formArray.controls;
      if (controls.length === 0 && (formArray.parent?.get('variantAttributes') as FormArray)?.length > 0) {
        return { noCombinationsGenerated: true };
      }
      const skuMap = new Map<string, AbstractControl[]>();
      let hasDefault = false;
      controls.forEach(c => c.get('sku')?.setErrors(null));
      for (const control of controls) {
        const sku = control.get('sku')?.value;
        if (sku) {
          if (!skuMap.has(sku)) skuMap.set(sku, []);
          skuMap.get(sku)!.push(control);
        }
        if (control.get('isDefault')?.value) hasDefault = true;
      }
      let hasDuplicateSku = false;
      skuMap.forEach(ctrls => {
        if (ctrls.length > 1) {
          hasDuplicateSku = true;
          ctrls.forEach(c => c.get('sku')?.setErrors({ duplicate: true }));
        }
      });
      const errors: ValidationErrors = {};
      if (hasDuplicateSku) errors['duplicateSku'] = true;
      if (controls.length > 0 && !hasDefault) errors['noDefaultVariant'] = true;
      return Object.keys(errors).length > 0 ? errors : null;
    };
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/settings-admin-panel/settings-admin-panel.component.ts ---
/**
 * @file settings-admin-panel.component.ts
 * @Version 1.0.0
 * @Description Component for managing settings specific to the Admin Panel itself.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { SettingsDataService, AdminPanelSettings } from '../../services/settings-data.service';
import { SettingsCardComponent } from '@royal-code/ui/card';
import { SettingsFieldComponent } from '../settings-field/settings-field.component';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiToggleButtonComponent } from '@royal-code/ui/button';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { UiSelectComponent, SelectOption } from '@royal-code/ui/forms';
import { AppIcon } from '@royal-code/shared/domain';

@Component({
  selector: 'admin-settings-admin-panel',
  standalone: true,
  imports: [
    CommonModule, ReactiveFormsModule, SettingsCardComponent, SettingsFieldComponent,
    UiInputComponent, UiButtonComponent, UiToggleButtonComponent, UiSpinnerComponent,
    UiSelectComponent
  ],
  template: `
    <form [formGroup]="settingsForm" (ngSubmit)="saveSettings()">
      <div class="space-y-6">
        <!-- Card 1: Uiterlijk Admin Panel -->
        <admin-settings-card title="Uiterlijk Admin Panel" description="Personaliseer de look en feel van het Admin Panel.">
          <admin-settings-field label="Standaard Thema" helpText="Het standaard kleurschema voor het Admin Panel.">
            <royal-code-ui-select 
              formControlName="defaultTheme" 
              [options]="themeOptions" 
              id="admin-default-theme" />
          </admin-settings-field>
          <admin-settings-field label="Custom Branding Actief" forInputId="custom-branding-toggle" helpText="Schakel uw eigen logo en kleuren in.">
            <royal-code-ui-toggle-button formControlName="customBrandingEnabled" label="Activeren" id="custom-branding-toggle" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>

        <!-- Card 2: Notificaties Admin Panel -->
        <admin-settings-card title="Notificaties Admin Panel" description="Beheer welke meldingen beheerders ontvangen.">
          <div formGroupName="newOrderNotifications">
            <admin-settings-field label="Nieuwe Order Notificaties (E-mail)" forInputId="new-order-email-toggle">
              <royal-code-ui-toggle-button formControlName="email" label="E-mail" id="new-order-email-toggle" />
            </admin-settings-field>
            <admin-settings-field label="Nieuwe Order Notificaties (In-app)" forInputId="new-order-inapp-toggle">
              <royal-code-ui-toggle-button formControlName="inApp" label="In-app" id="new-order-inapp-toggle" />
            </admin-settings-field>
          </div>
          <div formGroupName="lowStockNotifications">
            <admin-settings-field label="Lage Voorraad Notificaties (E-mail)" forInputId="low-stock-email-toggle">
              <royal-code-ui-toggle-button formControlName="email" label="E-mail" id="low-stock-email-toggle" />
            </admin-settings-field>
            <admin-settings-field label="Lage Voorraad Notificaties (In-app)" forInputId="low-stock-inapp-toggle">
              <royal-code-ui-toggle-button formControlName="inApp" label="In-app" id="low-stock-inapp-toggle" />
            </admin-settings-field>
          </div>
          <div formGroupName="newReviewNotifications">
            <admin-settings-field label="Nieuwe Review Notificaties (E-mail)" forInputId="new-review-email-toggle">
              <royal-code-ui-toggle-button formControlName="email" label="E-mail" id="new-review-email-toggle" />
            </admin-settings-field>
            <admin-settings-field label="Nieuwe Review Notificaties (In-app)" forInputId="new-review-inapp-toggle">
              <royal-code-ui-toggle-button formControlName="inApp" label="In-app" id="new-review-inapp-toggle" />
            </admin-settings-field>
          </div>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>
      </div>
    </form>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SettingsAdminPanelComponent implements OnInit {
  protected readonly AppIcon = AppIcon;
  private readonly fb = inject(FormBuilder);
  private readonly settingsService = inject(SettingsDataService);

  settingsForm!: FormGroup;

  themeOptions: SelectOption[] = [
    { value: 'light', label: 'Light Theme' },
    { value: 'dark', label: 'Dark Theme' },
  ];

  ngOnInit(): void {
    this.initializeForm();
    this.loadData();
  }

  initializeForm(): void {
    this.settingsForm = this.fb.group({
      defaultTheme: ['dark', Validators.required],
      customBrandingEnabled: [false],
      newOrderNotifications: this.fb.group({
        email: [true],
        inApp: [true],
      }),
      lowStockNotifications: this.fb.group({
        email: [false],
        inApp: [true],
      }),
      newReviewNotifications: this.fb.group({
        email: [true],
        inApp: [false],
      }),
    });
  }

  loadData(): void {
    this.settingsService.getAdminPanelSettings().subscribe(data => {
      this.settingsForm.patchValue(data);
    });
  }

  saveSettings(): void {
    if (this.settingsForm.valid) {
      console.log('Dummy Save Admin Panel Settings:', this.settingsForm.value);
      this.settingsForm.markAsPristine();
      // Toon notificatie in echte implementatie
    }
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/settings-compliance/settings-compliance.component.ts ---
/**
 * @file settings-compliance.component.ts
 * @Version 1.0.0
 * @Description Component for managing drone-specific compliance and regulatory settings.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { SettingsDataService, ComplianceSettings } from '../../services/settings-data.service';
import { SettingsCardComponent } from '@royal-code/ui/card';
import { SettingsFieldComponent } from '../settings-field/settings-field.component';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiToggleButtonComponent } from '@royal-code/ui/button';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { UiSelectComponent, SelectOption } from '@royal-code/ui/forms'; // Gebruik select indien nodig
import { AppIcon } from '@royal-code/shared/domain';


@Component({
  selector: 'admin-settings-compliance',
  standalone: true,
  imports: [
    CommonModule, ReactiveFormsModule, SettingsCardComponent, SettingsFieldComponent,
    UiInputComponent, UiButtonComponent, UiToggleButtonComponent, UiSpinnerComponent,
    UiSelectComponent
  ],
  template: `
    <form [formGroup]="settingsForm" (ngSubmit)="saveSettings()">
      <div class="space-y-6">
        <!-- Card 1: Drone Registratie & Classificatie (EASA/FAA) -->
        <admin-settings-card title="Drone Registratie & Classificatie" description="Instellingen voor EASA/FAA regelgeving en identificatie.">
          <admin-settings-field label="EASA Classificatiebeheer Inschakelen" forInputId="easa-classification-toggle" helpText="Beheer classificatie (C0-C4) voor drones.">
            <royal-code-ui-toggle-button formControlName="easaClassificationManagementEnabled" label="Inschakelen" id="easa-classification-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Operator ID Zichtbaarheid Vereisen" forInputId="operator-id-visibility-toggle" helpText="Verplicht tonen van operator ID op drones.">
            <royal-code-ui-toggle-button formControlName="requireOperatorIdVisibility" label="Vereisen" id="operator-id-visibility-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Geo-awareness Informatie Actief" forInputId="geo-awareness-info-toggle" helpText="Toon informatie over no-fly zones en restricties.">
            <royal-code-ui-toggle-button formControlName="geoAwarenessInfoEnabled" label="Activeren" id="geo-awareness-info-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Drone Registratie Vereist" forInputId="drone-registration-required-toggle" helpText="Klanten moeten drones registreren (indien van toepassing).">
            <royal-code-ui-toggle-button formControlName="droneRegistrationRequired" label="Vereisen" id="drone-registration-required-toggle" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>

        <!-- Card 2: Leeftijdsverificatie -->
        <admin-settings-card title="Leeftijdsverificatie" description="Verifieer de leeftijd van klanten voor specifieke producten.">
          <admin-settings-field label="Leeftijdsverificatie Inschakelen" forInputId="age-verification-enabled-toggle">
            <royal-code-ui-toggle-button formControlName="ageVerificationEnabled" label="Inschakelen" id="age-verification-enabled-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Verificatie Drempel (jaren)" helpText="Minimale leeftijd voor leeftijd-gebonden producten.">
            <royal-code-ui-input formControlName="ageVerificationThreshold" type="number" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>
        
        <!-- Card 3: Export/Import & CE-markering -->
        <admin-settings-card title="Export/Import & CE-markering" description="Regelgeving voor internationale handel en productcertificering.">
          <admin-settings-field label="Export Restricties Actief" forInputId="export-restrictions-toggle" helpText="Pas restricties toe op export naar specifieke landen.">
            <royal-code-ui-toggle-button formControlName="exportRestrictionsEnabled" label="Activeren" id="export-restrictions-toggle" />
          </admin-settings-field>
          <admin-settings-field label="ITAR/Dual-Use Vlaggen Actief" forInputId="itar-dual-use-toggle" helpText="Beheer producten die onder ITAR/Dual-Use wetgeving vallen.">
            <royal-code-ui-toggle-button formControlName="itarDualUseFlagsEnabled" label="Activeren" id="itar-dual-use-toggle" />
          </admin-settings-field>
          <admin-settings-field label="CE-markering Verificatie Inschakelen" forInputId="ce-marking-verification-toggle" helpText="Verifieer CE-markering status van producten.">
            <royal-code-ui-toggle-button formControlName="ceMarkingVerificationEnabled" label="Inschakelen" id="ce-marking-verification-toggle" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>
      </div>
    </form>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SettingsComplianceComponent implements OnInit {
  protected readonly AppIcon = AppIcon;
  private readonly fb = inject(FormBuilder);
  private readonly settingsService = inject(SettingsDataService);

  settingsForm!: FormGroup;

  ngOnInit(): void {
    this.initializeForm();
    this.loadData();
  }

  initializeForm(): void {
    this.settingsForm = this.fb.group({
      easaClassificationManagementEnabled: [false],
      requireOperatorIdVisibility: [false],
      geoAwarenessInfoEnabled: [false],
      droneRegistrationRequired: [false],
      ageVerificationEnabled: [false],
      ageVerificationThreshold: [18, [Validators.required, Validators.min(1)]],
      exportRestrictionsEnabled: [false],
      itarDualUseFlagsEnabled: [false],
      ceMarkingVerificationEnabled: [false],
    });
  }

  loadData(): void {
    this.settingsService.getComplianceSettings().subscribe(data => {
      this.settingsForm.patchValue(data);
    });
  }

  saveSettings(): void {
    if (this.settingsForm.valid) {
      console.log('Dummy Save Compliance Settings:', this.settingsForm.value);
      this.settingsForm.markAsPristine();
      // Toon notificatie in echte implementatie
    }
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/settings-deployment/settings-deployment.component.ts ---
/**
 * @file settings-deployment.component.ts
 * @Version 1.0.0
 * @Description Component for managing deployment and configuration management settings.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { SettingsDataService, DeploymentSettings } from '../../services/settings-data.service';
import { SettingsCardComponent } from '@royal-code/ui/card';
import { SettingsFieldComponent } from '../settings-field/settings-field.component';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiToggleButtonComponent } from '@royal-code/ui/button';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { AppIcon } from '@royal-code/shared/domain';

@Component({
  selector: 'admin-settings-deployment',
  standalone: true,
  imports: [
    CommonModule, ReactiveFormsModule, SettingsCardComponent, SettingsFieldComponent,
    UiInputComponent, UiButtonComponent, UiToggleButtonComponent, UiSpinnerComponent
  ],
  template: `
    <form [formGroup]="settingsForm" (ngSubmit)="saveSettings()">
      <div class="space-y-6">
        <!-- Card 1: Feature Flags -->
        <admin-settings-card title="Feature Flags" description="Beheer de activering en deactivering van specifieke functionaliteiten.">
          <admin-settings-field label="Feature Flags Inschakelen" forInputId="feature-flags-enabled-toggle" helpText="Schakel het systeem voor feature flags in/uit.">
            <royal-code-ui-toggle-button formControlName="featureFlagsEnabled" label="Inschakelen" id="feature-flags-enabled-toggle" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>

        <!-- Card 2: Configuratie Versiebeheer -->
        <admin-settings-card title="Configuratie Versiebeheer" description="Beheer en herstel eerdere configuratieversies.">
          <admin-settings-field label="Configuratie Versiebeheer Inschakelen" forInputId="config-versioning-enabled-toggle" helpText="Houd verschillende versies van instellingen bij.">
            <royal-code-ui-toggle-button formControlName="configVersioningEnabled" label="Inschakelen" id="config-versioning-enabled-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Staging naar Productie Migratie Wizard" forInputId="staging-to-prod-migration-wizard-toggle" helpText="Schakel de wizard in voor het overzetten van instellingen.">
            <royal-code-ui-toggle-button formControlName="stagingToProdMigrationWizardEnabled" label="Inschakelen" id="staging-to-prod-migration-wizard-toggle" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>
      </div>
    </form>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SettingsDeploymentComponent implements OnInit {
  protected readonly AppIcon = AppIcon;
  private readonly fb = inject(FormBuilder);
  private readonly settingsService = inject(SettingsDataService);

  settingsForm!: FormGroup;

  ngOnInit(): void {
    this.initializeForm();
    this.loadData();
  }

  initializeForm(): void {
    this.settingsForm = this.fb.group({
      featureFlagsEnabled: [false],
      configVersioningEnabled: [false],
      stagingToProdMigrationWizardEnabled: [false],
    });
  }

  loadData(): void {
    this.settingsService.getDeploymentSettings().subscribe(data => {
      this.settingsForm.patchValue(data);
    });
  }

  saveSettings(): void {
    if (this.settingsForm.valid) {
      console.log('Dummy Save Deployment Settings:', this.settingsForm.value);
      this.settingsForm.markAsPristine();
      // Toon notificatie in echte implementatie
    }
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/settings-field/settings-field.component.ts ---
/**
 * @file settings-field.component.ts
 * @Version 1.0.0
 * @Description Reusable layout component for a single setting field with label, help text, and input slot.
 */
import { Component, ChangeDetectionStrategy, input } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'admin-settings-field',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div class="grid grid-cols-1 md:grid-cols-3 gap-2 md:gap-6">
      <div class="md:col-span-1 pt-1">
        <label [for]="forInputId()" class="font-medium text-foreground">{{ label() }}</label>
        @if (helpText()) {
          <p class="text-sm text-secondary mt-1">{{ helpText() }}</p>
        }
      </div>
      <div class="md:col-span-2">
        <ng-content />
      </div>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SettingsFieldComponent {
  label = input.required<string>();
  helpText = input<string>();
  forInputId = input<string>();
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/settings-general/settings-general.component.ts ---
/**
 * @file settings-general.component.ts
 * @Version 1.2.0 (Fixed SettingsCardComponent Import & UiToggleButtonComponent Label)
 * @Description Component for managing general shop settings.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { SettingsDataService, GeneralSettings } from '../../services/settings-data.service';
import { SettingsFieldComponent } from '../settings-field/settings-field.component'; // Correcte relatieve import
import { UiInputComponent } from '@royal-code/ui/input';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiToggleButtonComponent } from '@royal-code/ui/button';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { AppIcon } from '@royal-code/shared/domain';
import { SettingsCardComponent } from '@royal-code/ui/card'; // << DE FIX: Correcte import voor SettingsCardComponent >>

@Component({
  selector: 'admin-settings-general',
  standalone: true,
  imports: [
    CommonModule, ReactiveFormsModule, SettingsCardComponent, SettingsFieldComponent,
    UiInputComponent, UiButtonComponent, UiToggleButtonComponent, UiSpinnerComponent
  ],
  template: `
    <form [formGroup]="settingsForm" (ngSubmit)="saveSettings()">
      <div class="space-y-6">
        <!-- Card 1: Winkel Details -->
        <admin-settings-card title="Winkel Details" description="Basisgegevens van uw webshop.">
          <admin-settings-field label="Winkelnaam" helpText="De naam die klanten zien.">
            <royal-code-ui-input formControlName="shopName" />
          </admin-settings-field>
          <admin-settings-field label="Contact E-mailadres" helpText="Voor klantcontact en systeemmeldingen.">
            <royal-code-ui-input formControlName="contactEmail" type="email" />
          </admin-settings-field>
          <admin-settings-field label="Telefoonnummer Klantenservice" helpText="Optioneel, voor weergave op contactpagina.">
            <royal-code-ui-input formControlName="customerServicePhone" />
          </admin-settings-field>
          <admin-settings-field label="Bedrijfsadres" helpText="Geregistreerd adres, gebruikt voor facturen.">
            <royal-code-ui-input formControlName="companyAddress" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>

        <!-- Card 2: Lokalisatie -->
        <admin-settings-card title="Lokalisatie" description="Valuta, taal en regio instellingen.">
          <admin-settings-field label="Standaard Valuta" helpText="De valuta waarin prijzen worden getoond.">
            <royal-code-ui-input formControlName="defaultCurrency" />
          </admin-settings-field>
          <admin-settings-field label="Standaard Taal" helpText="De taal waarin de shop standaard wordt geladen.">
            <royal-code-ui-input formControlName="defaultLanguage" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>
        
        <!-- Card 3: Juridische Pagina's -->
        <admin-settings-card title="Juridische Documenten" description="Links naar uw algemene voorwaarden, privacybeleid en retourbeleid.">
          <div formGroupName="legalUrls">
            <admin-settings-field label="Algemene Voorwaarden URL">
              <royal-code-ui-input formControlName="termsOfService" placeholder="/legal/terms-of-service" />
            </admin-settings-field>
            <admin-settings-field label="Privacybeleid URL">
              <royal-code-ui-input formControlName="privacyPolicy" placeholder="/legal/privacy-policy" />
            </admin-settings-field>
             <admin-settings-field label="Retourbeleid URL">
              <royal-code-ui-input formControlName="returnPolicy" placeholder="/legal/return-policy" />
            </admin-settings-field>
          </div>
           <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>

        <!-- Card 4: Onderhoudsmodus -->
        <admin-settings-card title="Onderhoudsmodus" description="Schakel de frontend tijdelijk uit voor bezoekers.">
          <div formGroupName="maintenanceMode">
            <admin-settings-field label="Onderhoudsmodus Actief" forInputId="maintenance-mode-toggle">
              <royal-code-ui-toggle-button formControlName="enabled" label="Modus inschakelen" id="maintenance-mode-toggle" />
            </admin-settings-field>
            <admin-settings-field label="Onderhoudsbericht" helpText="Bericht dat wordt getoond aan bezoekers.">
              <royal-code-ui-input formControlName="message" />
            </admin-settings-field>
            <admin-settings-field label="Toegestane IP-adressen" helpText="Komma-gescheiden lijst van IP-adressen die de site wel mogen zien.">
              <royal-code-ui-input formControlName="allowedIpAddresses" />
            </admin-settings-field>
          </div>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>
      </div>
    </form>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SettingsGeneralComponent implements OnInit {
  protected readonly AppIcon = AppIcon;
  private readonly fb = inject(FormBuilder);
  private readonly settingsService = inject(SettingsDataService);

  settingsForm!: FormGroup;

  ngOnInit(): void {
    this.initializeForm();
    this.loadData();
  }

  initializeForm(): void {
    this.settingsForm = this.fb.group({
      shopName: ['', Validators.required],
      contactEmail: ['', [Validators.required, Validators.email]],
      customerServicePhone: [''],
      companyAddress: ['', Validators.required],
      defaultLanguage: ['nl', Validators.required],
      defaultCurrency: ['EUR', Validators.required],
      legalUrls: this.fb.group({
        termsOfService: [''],
        privacyPolicy: [''],
        returnPolicy: [''],
      }),
      maintenanceMode: this.fb.group({
        enabled: [false],
        message: [''],
        allowedIpAddresses: [''],
      }),
    });
  }

  loadData(): void {
    this.settingsService.getGeneralSettings().subscribe(data => {
      this.settingsForm.patchValue(data);
    });
  }

  saveSettings(): void {
    if (this.settingsForm.valid) {
      console.log('Dummy Save:', this.settingsForm.value);
      this.settingsForm.markAsPristine();
      // Toon notificatie in echte implementatie
    }
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/settings-governance/settings-governance.component.ts ---
/**
 * @file settings-governance.component.ts
 * @Version 1.0.0
 * @Description Component for managing security, governance, and audit settings.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { SettingsDataService, GovernanceSettings } from '../../services/settings-data.service';
import { SettingsCardComponent } from '@royal-code/ui/card';
import { SettingsFieldComponent } from '../settings-field/settings-field.component';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiToggleButtonComponent } from '@royal-code/ui/button';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { AppIcon } from '@royal-code/shared/domain';

@Component({
  selector: 'admin-settings-governance',
  standalone: true,
  imports: [
    CommonModule, ReactiveFormsModule, SettingsCardComponent, SettingsFieldComponent,
    UiInputComponent, UiButtonComponent, UiToggleButtonComponent, UiSpinnerComponent
  ],
  template: `
    <form [formGroup]="settingsForm" (ngSubmit)="saveSettings()">
      <div class="space-y-6">
        <!-- Card 1: Rolgebaseerd Toegangsbeheer (RBAC) -->
        <admin-settings-card title="Rolgebaseerd Toegangsbeheer (RBAC)" description="Beheer de toegang en permissies van gebruikersrollen.">
          <admin-settings-field label="RBAC Inschakelen" forInputId="rbac-enabled-toggle" helpText="Schakel rolgebaseerd toegangsbeheer in voor de applicatie.">
            <royal-code-ui-toggle-button formControlName="rbacEnabled" label="Inschakelen" id="rbac-enabled-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Audit Logging Inschakelen" forInputId="audit-logging-toggle" helpText="Leg alle belangrijke wijzigingen en acties vast voor auditdoeleinden.">
            <royal-code-ui-toggle-button formControlName="auditLoggingEnabled" label="Inschakelen" id="audit-logging-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Goedkeuringsworkflow Actief" forInputId="high-risk-approval-toggle" helpText="Vereis goedkeuring voor high-risk instellingswijzigingen (4-ogenprincipe).">
            <royal-code-ui-toggle-button formControlName="highRiskApprovalWorkflowEnabled" label="Activeren" id="high-risk-approval-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Admin IP Rate Limiting Actief" forInputId="admin-ip-rate-limiting-toggle" helpText="Beperk het aantal verzoeken vanaf een IP-adres naar de admin.">
            <royal-code-ui-toggle-button formControlName="adminIpRateLimitingEnabled" label="Activeren" id="admin-ip-rate-limiting-toggle" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>
      </div>
    </form>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SettingsGovernanceComponent implements OnInit {
  protected readonly AppIcon = AppIcon;
  private readonly fb = inject(FormBuilder);
  private readonly settingsService = inject(SettingsDataService);

  settingsForm!: FormGroup;

  ngOnInit(): void {
    this.initializeForm();
    this.loadData();
  }

  initializeForm(): void {
    this.settingsForm = this.fb.group({
      rbacEnabled: [true],
      auditLoggingEnabled: [true],
      highRiskApprovalWorkflowEnabled: [false],
      adminIpRateLimitingEnabled: [true],
    });
  }

  loadData(): void {
    this.settingsService.getGovernanceSettings().subscribe(data => {
      this.settingsForm.patchValue(data);
    });
  }

  saveSettings(): void {
    if (this.settingsForm.valid) {
      console.log('Dummy Save Governance Settings:', this.settingsForm.value);
      this.settingsForm.markAsPristine();
      // Toon notificatie in echte implementatie
    }
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/settings-marketing/settings-marketing.component.ts ---
/**
 * @file settings-marketing.component.ts
 * @Version 1.0.0
 * @Description Component for managing marketing and SEO settings.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators, FormArray } from '@angular/forms';
import { SettingsDataService, MarketingSettings } from '../../services/settings-data.service';
import { SettingsCardComponent } from '@royal-code/ui/card';
import { SettingsFieldComponent } from '../settings-field/settings-field.component';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiToggleButtonComponent } from '@royal-code/ui/button';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { UiIconComponent } from '@royal-code/ui/icon';
import { AppIcon } from '@royal-code/shared/domain';


@Component({
  selector: 'admin-settings-marketing',
  standalone: true,
  imports: [
    CommonModule, ReactiveFormsModule, SettingsCardComponent, SettingsFieldComponent,
    UiInputComponent, UiButtonComponent, UiToggleButtonComponent, UiSpinnerComponent,
    UiIconComponent
  ],
  template: `
    <form [formGroup]="settingsForm" (ngSubmit)="saveSettings()">
      <div class="space-y-6">
        <!-- Card 1: Tracking & Analyse -->
        <admin-settings-card title="Tracking & Analyse" description="Integratie met externe tracking- en analysehulpmiddelen.">
          <admin-settings-field label="Google Analytics Tracking ID" helpText="Voor Google Universal Analytics (UA-XXXXX-Y).">
            <royal-code-ui-input formControlName="googleAnalyticsId" />
          </admin-settings-field>
          <admin-settings-field label="Google Tag Manager Container ID" helpText="Voor Google Tag Manager (GTM-XXXXXX).">
            <royal-code-ui-input formControlName="googleTagManagerId" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>

        <!-- Card 2: SEO Standaarden -->
        <admin-settings-card title="SEO Standaarden" description="Standaard meta-informatie voor zoekmachines.">
          <admin-settings-field label="Standaard Meta Titel" helpText="De titel voor pagina's zonder specifieke SEO-titel.">
            <royal-code-ui-input formControlName="defaultMetaTitle" />
          </admin-settings-field>
          <admin-settings-field label="Standaard Meta Beschrijving" helpText="De beschrijving voor pagina's zonder specifieke SEO-beschrijving.">
            <royal-code-ui-input formControlName="defaultMetaDescription" />
          </admin-settings-field>
          <admin-settings-field label="Globale Meta Trefwoorden" helpText="Komma-gescheiden lijst van trefwoorden.">
            <royal-code-ui-input formControlName="globalMetaKeywords" />
          </admin-settings-field>
          <admin-settings-field label="Sitemap Automatisch Genereren" forInputId="sitemap-auto-generate-toggle" helpText="Schakel het automatisch genereren van een sitemap in.">
            <royal-code-ui-toggle-button formControlName="sitemapAutoGenerate" label="Inschakelen" id="sitemap-auto-generate-toggle" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>

        <!-- Card 3: Social Media Links -->
        <admin-settings-card title="Social Media Links" description="Links naar uw sociale media profielen.">
          <div formArrayName="socialMediaLinks" class="space-y-3">
            @for (link of socialMediaLinks.controls; track link.get('platform')?.value; let i = $index) {
              <div [formGroupName]="i" class="flex items-center gap-2">
                <royal-code-ui-input [label]="link.get('platform')?.value + ' URL'" formControlName="url" class="flex-grow" />
                <royal-code-ui-button type="fire" sizeVariant="icon" (clicked)="removeSocialMediaLink(i)">
                  <royal-code-ui-icon [icon]="AppIcon.Trash2" />
                </royal-code-ui-button>
              </div>
            }
          </div>
          <royal-code-ui-button type="outline" sizeVariant="sm" (clicked)="addSocialMediaLink()" class="mt-4">
            <royal-code-ui-icon [icon]="AppIcon.Plus" class="mr-2" /> Link Toevoegen
          </royal-code-ui-button>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>
      </div>
    </form>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SettingsMarketingComponent implements OnInit {
  protected readonly AppIcon = AppIcon;
  private readonly fb = inject(FormBuilder);
  private readonly settingsService = inject(SettingsDataService);

  settingsForm!: FormGroup;

  ngOnInit(): void {
    this.initializeForm();
    this.loadData();
  }

  initializeForm(): void {
    this.settingsForm = this.fb.group({
      googleAnalyticsId: [''],
      googleTagManagerId: [''],
      defaultMetaTitle: [''],
      defaultMetaDescription: [''],
      globalMetaKeywords: [''],
      sitemapAutoGenerate: [true],
      socialMediaLinks: this.fb.array([]),
    });
  }

  get socialMediaLinks() {
    return this.settingsForm.get('socialMediaLinks') as FormArray;
  }

  loadData(): void {
    this.settingsService.getMarketingSettings().subscribe(data => {
      this.settingsForm.patchValue(data);
      this.socialMediaLinks.clear();
      data.socialMediaLinks.forEach(link => this.socialMediaLinks.push(this.fb.group(link)));
    });
  }

  addSocialMediaLink(): void {
    this.socialMediaLinks.push(this.fb.group({ platform: ['New Platform', Validators.required], url: ['', Validators.required] }));
  }

  removeSocialMediaLink(index: number): void {
    this.socialMediaLinks.removeAt(index);
  }

  saveSettings(): void {
    if (this.settingsForm.valid) {
      console.log('Dummy Save Marketing Settings:', this.settingsForm.value);
      this.settingsForm.markAsPristine();
      // Toon notificatie in echte implementatie
    }
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/settings-orders/settings-orders.component.ts ---
/**
 * @file settings-orders.component.ts
 * @Version 1.0.0
 * @Description Component for managing order and checkout settings, including drone-specific shipping.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormArray, FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { SettingsDataService, OrderSettings } from '../../services/settings-data.service';
import { SettingsCardComponent } from '@royal-code/ui/card'; // << DE FIX: Correcte import >>
import { SettingsFieldComponent } from '../settings-field/settings-field.component'; // Correcte relatieve import
import { UiInputComponent } from '@royal-code/ui/input';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiToggleButtonComponent } from '@royal-code/ui/button';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { UiSelectComponent, SelectOption } from '@royal-code/ui/forms';
import { UiIconComponent } from '@royal-code/ui/icon';
import { AppIcon } from '@royal-code/shared/domain';


@Component({
  selector: 'admin-settings-orders',
  standalone: true,
  imports: [
    CommonModule, ReactiveFormsModule, SettingsCardComponent, SettingsFieldComponent,
    UiInputComponent, UiButtonComponent, UiToggleButtonComponent, UiSpinnerComponent,
    UiSelectComponent, UiIconComponent
  ],
  template: `
    <form [formGroup]="settingsForm" (ngSubmit)="saveSettings()">
      <div class="space-y-6">
        <!-- Card 1: Algemene Orderinstellingen -->
        <admin-settings-card title="Algemene Orderinstellingen" description="Basisgedrag voor orderverwerking.">
          <admin-settings-field label="Ordernummer Voorvoegsel" helpText="Prefix voor nieuwe ordernummers (bv. 'RC-DRONE-').">
            <royal-code-ui-input formControlName="orderNumberPrefix" />
          </admin-settings-field>
          <admin-settings-field label="Start Ordernummer" helpText="Het nummer vanaf waar nieuwe orders beginnen te tellen.">
            <royal-code-ui-input formControlName="startOrderNumber" type="number" />
          </admin-settings-field>
          <admin-settings-field label="Gast-checkout Toestaan" forInputId="allow-guest-checkout-toggle" helpText="Sta klanten toe te bestellen zonder account.">
            <royal-code-ui-toggle-button formControlName="allowGuestCheckout" label="Gast-checkout inschakelen" id="allow-guest-checkout-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Onbetaalde Order Timeout (min)" helpText="Tijd totdat een onbetaalde order wordt geannuleerd.">
            <royal-code-ui-input formControlName="unpaidOrderTimeoutMinutes" type="number" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>

        <!-- Card 2: Retourneren, Garantie & DOA -->
        <admin-settings-card title="Retourneren, Garantie & DOA" description="Beleid en workflows voor productretouren en defecten.">
          <admin-settings-field label="RMA Workflow Inschakelen" forInputId="rma-workflow-toggle" helpText="Schakel het Return Merchandise Authorization proces in.">
            <royal-code-ui-toggle-button formControlName="rmaWorkflowEnabled" label="RMA inschakelen" id="rma-workflow-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Garantievoorwaarden URL" helpText="Link naar de volledige garantievoorwaarden.">
            <royal-code-ui-input formControlName="warrantyTermsUrl" placeholder="/legal/warranty-terms" />
          </admin-settings-field>
          <admin-settings-field label="DOA Beleid URL" helpText="Link naar het Dead On Arrival beleid.">
            <royal-code-ui-input formControlName="doaPolicyUrl" placeholder="/legal/doa-policy" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>

        <!-- Card 3: Verzendproviders -->
        <admin-settings-card title="Verzendproviders" description="API-integraties met externe verzendservices.">
          @for (provider of shippingProviders.controls; track provider.get('id')?.value; let i = $index) {
            <div [formGroupName]="i" class="p-3 border border-dashed border-border rounded-md mb-4 last:mb-0">
              <admin-settings-field [label]="provider.get('name')?.value + ' API Key'">
                <royal-code-ui-input formControlName="apiKey" type="password" />
              </admin-settings-field>
            </div>
          }
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>

        <!-- Card 4: Betaalproviders -->
        <admin-settings-card title="Betaalproviders" description="API-integraties met externe betaalservices.">
          @for (provider of paymentProviders.controls; track provider.get('id')?.value; let i = $index) {
            <div [formGroupName]="i" class="p-3 border border-dashed border-border rounded-md mb-4 last:mb-0">
              <admin-settings-field [label]="provider.get('name')?.value + ' API Key'">
                <royal-code-ui-input formControlName="apiKey" type="password" />
              </admin-settings-field>
            </div>
          }
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>

        <!-- Card 5: Drone-specifieke Verzendopties -->
        <admin-settings-card title="Drone-specifieke Verzendopties" description="Beheer restricties en verzekeringen voor drone-zendingen.">
          <admin-settings-field label="Batterij Verzendrestricties Actief" forInputId="battery-shipping-toggle" helpText="Pas restricties toe op verzending van Li-ion batterijen.">
            <royal-code-ui-toggle-button formControlName="batteryShippingRestrictionsEnabled" label="Activeren" id="battery-shipping-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Bulky Item Handling Actief" forInputId="bulky-item-handling-toggle" helpText="Speciale regels voor grote en zware drones.">
            <royal-code-ui-toggle-button formControlName="bulkyItemHandlingEnabled" label="Activeren" id="bulky-item-handling-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Verplichte Verzekering High-Value Items" forInputId="high-value-insurance-toggle" helpText="Verzekering vereist voor drones boven een bepaalde waarde.">
            <royal-code-ui-toggle-button formControlName="highValueInsuranceRequired" label="Verplicht" id="high-value-insurance-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Dropshipping Actief" forInputId="dropshipping-toggle" helpText="Configureer dropshipping met externe leveranciers.">
            <royal-code-ui-toggle-button formControlName="dropShippingEnabled" label="Activeren" id="dropshipping-toggle" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>
      </div>
    </form>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SettingsOrdersComponent implements OnInit {
  protected readonly AppIcon = AppIcon;
  private readonly fb = inject(FormBuilder);
  private readonly settingsService = inject(SettingsDataService);

  settingsForm!: FormGroup;

  ngOnInit(): void {
    this.initializeForm();
    this.loadData();
  }

  initializeForm(): void {
    this.settingsForm = this.fb.group({
      orderNumberPrefix: ['', Validators.required],
      startOrderNumber: [0, [Validators.required, Validators.min(0)]],
      allowGuestCheckout: [false],
      unpaidOrderTimeoutMinutes: [60, [Validators.required, Validators.min(1)]],
      rmaWorkflowEnabled: [false],
      warrantyTermsUrl: [''],
      doaPolicyUrl: [''],
      shippingProviders: this.fb.array([]), // Lege array, wordt gevuld met data
      paymentProviders: this.fb.array([]), // Lege array, wordt gevuld met data
      batteryShippingRestrictionsEnabled: [false],
      bulkyItemHandlingEnabled: [false],
      highValueInsuranceRequired: [false],
      dropShippingEnabled: [false],
    });
  }

  get shippingProviders() {
    return this.settingsForm.get('shippingProviders') as FormArray;
  }

  get paymentProviders() {
    return this.settingsForm.get('paymentProviders') as FormArray;
  }

  loadData(): void {
    this.settingsService.getOrderSettings().subscribe(data => {
      this.settingsForm.patchValue(data);

      // Vul de FormArray's voor providers
      this.shippingProviders.clear();
      data.shippingProviders.forEach(p => this.shippingProviders.push(this.fb.group(p)));

      this.paymentProviders.clear();
      data.paymentProviders.forEach(p => this.paymentProviders.push(this.fb.group(p)));
    });
  }

  saveSettings(): void {
    if (this.settingsForm.valid) {
      console.log('Dummy Save Order Settings:', this.settingsForm.value);
      this.settingsForm.markAsPristine();
      // Toon notificatie in echte implementatie
    }
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/settings-products/settings-products.component.ts ---
/**
 * @file settings-products.component.ts
 * @Version 1.1.0 (Fixed SettingsCardComponent Import)
 * @Description Component for managing product and inventory settings, including drone-specific details.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { SettingsDataService, ProductSettings } from '../../services/settings-data.service';
import { SettingsFieldComponent } from '../settings-field/settings-field.component'; // Correcte relatieve import
import { UiInputComponent } from '@royal-code/ui/input';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiToggleButtonComponent } from '@royal-code/ui/button';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { UiSelectComponent, SelectOption } from '@royal-code/ui/forms';
import { SettingsCardComponent } from '@royal-code/ui/card'; // << DE FIX: Correcte import voor SettingsCardComponent >>

@Component({
  selector: 'admin-settings-products',
  standalone: true,
  imports: [
    CommonModule, ReactiveFormsModule, SettingsCardComponent, SettingsFieldComponent,
    UiInputComponent, UiButtonComponent, UiToggleButtonComponent, UiSpinnerComponent,
    UiSelectComponent
  ],
  template: `
    <form [formGroup]="settingsForm" (ngSubmit)="saveSettings()">
      <div class="space-y-6">
        <!-- Card 1: Algemene Productinstellingen -->
        <admin-settings-card title="Algemene Productinstellingen" description="Standaard gedrag en weergave van producten.">
          <admin-settings-field label="Standaard Productstatus" helpText="Status van nieuwe producten na aanmaken.">
            <royal-code-ui-select 
              formControlName="defaultStatus" 
              [options]="productStatusOptions" 
              id="default-product-status" />
          </admin-settings-field>
          <admin-settings-field label="Globale Lage Voorraad Drempel" helpText="Trigger voor meldingen als de voorraad hieronder komt.">
            <royal-code-ui-input formControlName="lowStockThreshold" type="number" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>

        <!-- Card 2: Inventaris & Backorders -->
        <admin-settings-card title="Inventaris & Backorders" description="Beheer hoe de voorraad wordt bijgehouden en afgehandeld.">
          <admin-settings-field label="Voorraadbeheer Globaal Actief" forInputId="manage-stock-globally-toggle">
            <royal-code-ui-toggle-button formControlName="manageStockGlobally" label="Voorraadbeheer inschakelen" id="manage-stock-globally-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Backorders Toestaan" forInputId="allow-backorders-toggle" helpText="Klanten kunnen bestellen, zelfs als een product niet op voorraad is.">
            <royal-code-ui-toggle-button formControlName="allowBackorders" label="Backorders toestaan" id="allow-backorders-toggle" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>

        <!-- Card 3: Reviews & Moderatie -->
        <admin-settings-card title="Reviews & Moderatie" description="Beheer hoe productreviews worden verzameld en getoond.">
          <admin-settings-field label="Reviews Inschakelen" forInputId="reviews-enabled-toggle">
            <royal-code-ui-toggle-button formControlName="reviewsEnabled" label="Reviews inschakelen" id="reviews-enabled-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Reviews Automatisch Goedkeuren" forInputId="auto-approve-reviews-toggle" helpText="Nieuwe reviews worden direct gepubliceerd zonder handmatige moderatie.">
            <royal-code-ui-toggle-button formControlName="autoApproveReviews" label="Automatisch goedkeuren" id="auto-approve-reviews-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Drempel Gevlagde Reviews" helpText="Aantal meldingen voordat een review automatisch wordt verborgen.">
            <royal-code-ui-input formControlName="flaggedReviewsThreshold" type="number" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>

        <!-- Card 4: Drone-specifieke Productdetails -->
        <admin-settings-card title="Drone Product Configuratie & Tracking" description="Instellingen voor drone-specifieke informatie en compliance.">
          <admin-settings-field label="Standaard EASA Classificatie" helpText="De standaard classificatie voor nieuwe drones.">
            <royal-code-ui-select 
              formControlName="droneDefaultEasaClassification" 
              [options]="easaClassificationOptions" 
              id="default-easa-classification" />
          </admin-settings-field>
          <admin-settings-field label="Firmware Versie Tracking Inschakelen" forInputId="firmware-tracking-toggle" helpText="Houd bij welke firmwareversies bij producten horen.">
            <royal-code-ui-toggle-button formControlName="droneFirmwareTrackingEnabled" label="Tracking inschakelen" id="firmware-tracking-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Compatibiliteitsmatrix Inschakelen" forInputId="compatibility-matrix-toggle" helpText="Beheer compatibiliteit tussen drones, apps en accessoires.">
            <royal-code-ui-toggle-button formControlName="droneCompatibilityMatrixEnabled" label="Matrix inschakelen" id="compatibility-matrix-toggle" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>
      </div>
    </form>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SettingsProductsComponent implements OnInit {
  private readonly fb = inject(FormBuilder);
  private readonly settingsService = inject(SettingsDataService);

  settingsForm!: FormGroup;

  productStatusOptions: SelectOption[] = [
    { value: 'draft', label: 'Concept' },
    { value: 'published', label: 'Gepubliceerd' },
  ];

  easaClassificationOptions: SelectOption[] = [
    { value: 'C0', label: 'C0' },
    { value: 'C1', label: 'C1' },
    { value: 'C2', label: 'C2' },
    { value: 'C3', label: 'C3' },
    { value: 'C4', label: 'C4' },
    { value: 'OpenCategory', label: 'Open Categorie' },
  ];

  ngOnInit(): void {
    this.initializeForm();
    this.loadData();
  }

  initializeForm(): void {
    this.settingsForm = this.fb.group({
      defaultStatus: ['draft', Validators.required],
      manageStockGlobally: [true],
      lowStockThreshold: [10, [Validators.required, Validators.min(0)]],
      allowBackorders: [false],
      reviewsEnabled: [true],
      autoApproveReviews: [false],
      flaggedReviewsThreshold: [5, [Validators.required, Validators.min(0)]],
      droneDefaultEasaClassification: ['C0', Validators.required],
      droneFirmwareTrackingEnabled: [true],
      droneCompatibilityMatrixEnabled: [true],
    });
  }

  loadData(): void {
    this.settingsService.getProductSettings().subscribe(data => {
      this.settingsForm.patchValue(data);
    });
  }

  saveSettings(): void {
    if (this.settingsForm.valid) {
      console.log('Dummy Save Product Settings:', this.settingsForm.value);
      this.settingsForm.markAsPristine();
      // Toon notificatie in echte implementatie
    }
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/settings-security/settings-security.component.ts ---
/**
 * @file settings-security.component.ts
 * @Version 1.0.0
 * @Description Component for managing security and user account settings.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { SettingsDataService, SecuritySettings } from '../../services/settings-data.service';
import { SettingsCardComponent } from '@royal-code/ui/card'; // << DE FIX: Correcte import >>
import { SettingsFieldComponent } from '../settings-field/settings-field.component'; // Correcte relatieve import
import { UiInputComponent } from '@royal-code/ui/input';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiToggleButtonComponent } from '@royal-code/ui/button';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { UiSelectComponent, SelectOption } from '@royal-code/ui/forms';
import { AppIcon } from '@royal-code/shared/domain';

@Component({
  selector: 'admin-settings-security',
  standalone: true,
  imports: [
    CommonModule, ReactiveFormsModule, SettingsCardComponent, SettingsFieldComponent,
    UiInputComponent, UiButtonComponent, UiToggleButtonComponent, UiSpinnerComponent,
    UiSelectComponent
  ],
  template: `
    <form [formGroup]="settingsForm" (ngSubmit)="saveSettings()">
      <div class="space-y-6">
        <!-- Card 1: Registratie & Authenticatie -->
        <admin-settings-card title="Registratie & Authenticatie" description="Instellingen voor gebruikersregistratie en -verificatie.">
          <admin-settings-field label="Openbare Registratie Toestaan" forInputId="allow-public-registration-toggle" helpText="Laat nieuwe gebruikers zichzelf registreren.">
            <royal-code-ui-toggle-button formControlName="allowPublicRegistration" label="Toestaan" id="allow-public-registration-toggle" />
          </admin-settings-field>
          <admin-settings-field label="E-mail Verificatie Vereisen" forInputId="require-email-verification-toggle" helpText="Gebruikers moeten hun e-mail verifiëren.">
            <royal-code-ui-toggle-button formControlName="requireEmailVerification" label="Vereisen" id="require-email-verification-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Standaard Gebruikersrol" helpText="De rol die nieuwe gebruikers automatisch krijgen toegewezen.">
            <royal-code-ui-select 
              formControlName="defaultUserRole" 
              [options]="userRoleOptions" 
              id="default-user-role" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>

        <!-- Card 2: Wachtwoordbeleid -->
        <admin-settings-card title="Wachtwoordbeleid" description="Definieer de complexiteitseisen voor gebruikerswachtwoorden.">
          <div formGroupName="passwordPolicy">
            <admin-settings-field label="Minimale Lengte" helpText="Minimaal aantal karakters.">
              <royal-code-ui-input formControlName="minLength" type="number" />
            </admin-settings-field>
            <admin-settings-field label="Hoofdletters Vereisen" forInputId="require-uppercase-toggle">
              <royal-code-ui-toggle-button formControlName="requireUppercase" label="Vereisen" id="require-uppercase-toggle" />
            </admin-settings-field>
            <admin-settings-field label="Kleine letters Vereisen" forInputId="require-lowercase-toggle">
              <royal-code-ui-toggle-button formControlName="requireLowercase" label="Vereisen" id="require-lowercase-toggle" />
            </admin-settings-field>
            <admin-settings-field label="Cijfers Vereisen" forInputId="require-numbers-toggle">
              <royal-code-ui-toggle-button formControlName="requireNumbers" label="Vereisen" id="require-numbers-toggle" />
            </admin-settings-field>
            <admin-settings-field label="Symbolen Vereisen" forInputId="require-symbols-toggle">
              <royal-code-ui-toggle-button formControlName="requireSymbols" label="Vereisen" id="require-symbols-toggle" />
            </admin-settings-field>
          </div>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>
        
        <!-- Card 3: Admin Toegangsbeveiliging -->
        <admin-settings-card title="Admin Toegangsbeveiliging" description="Specifieke beveiligingsinstellingen voor het Admin Panel.">
          <admin-settings-field label="Toegestane IP-adressen" helpText="Komma-gescheiden lijst van IP-adressen die toegang hebben tot het Admin Panel.">
            <royal-code-ui-input formControlName="adminIpAllowlist" />
          </admin-settings-field>
          <admin-settings-field label="Admin Sessie Timeout (min)" helpText="Duur van een inactieve sessie voordat opnieuw moet worden ingelogd.">
            <royal-code-ui-input formControlName="adminSessionTimeoutMinutes" type="number" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>
      </div>
    </form>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SettingsSecurityComponent implements OnInit {
  protected readonly AppIcon = AppIcon;
  private readonly fb = inject(FormBuilder);
  private readonly settingsService = inject(SettingsDataService);

  settingsForm!: FormGroup;

  // Dummy rollen, later uit een facade/API
  userRoleOptions: SelectOption[] = [
    { value: 'Customer', label: 'Klant' },
    { value: 'Admin', label: 'Administrator' },
    { value: 'Moderator', label: 'Moderator' },
    { value: 'Warehouse', label: 'Magazijn' },
  ];

  ngOnInit(): void {
    this.initializeForm();
    this.loadData();
  }

  initializeForm(): void {
    this.settingsForm = this.fb.group({
      allowPublicRegistration: [true],
      requireEmailVerification: [false],
      defaultUserRole: ['Customer', Validators.required],
      passwordPolicy: this.fb.group({
        minLength: [12, [Validators.required, Validators.min(8)]],
        requireUppercase: [true],
        requireLowercase: [true],
        requireNumbers: [true],
        requireSymbols: [false],
      }),
      adminIpAllowlist: [''],
      adminSessionTimeoutMinutes: [30, [Validators.required, Validators.min(5)]],
    });
  }

  loadData(): void {
    this.settingsService.getSecuritySettings().subscribe(data => {
      this.settingsForm.patchValue(data);
    });
  }

  saveSettings(): void {
    if (this.settingsForm.valid) {
      console.log('Dummy Save Security Settings:', this.settingsForm.value);
      this.settingsForm.markAsPristine();
      // Toon notificatie in echte implementatie
    }
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/settings-system/settings-system.component.ts ---
/**
 * @file settings-system.component.ts
 * @Version 1.0.0
 * @Description Component for managing system and technical settings.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { SettingsDataService, SystemSettings } from '../../services/settings-data.service';
import { SettingsCardComponent } from '@royal-code/ui/card';
import { SettingsFieldComponent } from '../settings-field/settings-field.component';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiToggleButtonComponent } from '@royal-code/ui/button';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { UiSelectComponent, SelectOption } from '@royal-code/ui/forms';
import { AppIcon } from '@royal-code/shared/domain';

@Component({
  selector: 'admin-settings-system',
  standalone: true,
  imports: [
    CommonModule, ReactiveFormsModule, SettingsCardComponent, SettingsFieldComponent,
    UiInputComponent, UiButtonComponent, UiToggleButtonComponent, UiSpinnerComponent,
    UiSelectComponent
  ],
  template: `
    <form [formGroup]="settingsForm" (ngSubmit)="saveSettings()">
      <div class="space-y-6">
        <!-- Card 1: Logging & Monitoring -->
        <admin-settings-card title="Logging & Monitoring" description="Configureer systeemlogs en externe monitoring.">
          <admin-settings-field label="Globaal Log Niveau" helpText="Het detailniveau voor applicatielogs.">
            <royal-code-ui-select 
              formControlName="globalLogLevel" 
              [options]="logLevelOptions" 
              id="global-log-level" />
          </admin-settings-field>
          <admin-settings-field label="Sentry DSN" helpText="Distributed Sentry Tracking ID voor error monitoring.">
            <royal-code-ui-input formControlName="sentryDsn" type="password" />
          </admin-settings-field>
          <admin-settings-field label="API Health Check Inschakelen" forInputId="api-health-check-toggle" helpText="Actieve monitoring van backend API's.">
            <royal-code-ui-toggle-button formControlName="apiHealthCheckEnabled" label="Inschakelen" id="api-health-check-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Cron Job Monitoring Inschakelen" forInputId="cron-job-monitoring-toggle" helpText="Houd geplande taken in de gaten.">
            <royal-code-ui-toggle-button formControlName="cronJobMonitoringEnabled" label="Inschakelen" id="cron-job-monitoring-toggle" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>

        <!-- Card 2: Cache Beheer -->
        <admin-settings-card title="Cache Beheer" description="Beheer hoe en hoe lang data in de cache wordt bewaard.">
          <admin-settings-field label="Frontend Cache Leegknop Actief" forInputId="frontend-cache-clear-toggle" helpText="Toon knop om browser-cache te legen.">
            <royal-code-ui-toggle-button formControlName="frontendCacheClearButtonEnabled" label="Activeren" id="frontend-cache-clear-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Backend Cache Leegknop Actief" forInputId="backend-cache-clear-toggle" helpText="Toon knop om server-cache te legen.">
            <royal-code-ui-toggle-button formControlName="backendCacheClearButtonEnabled" label="Activeren" id="backend-cache-clear-toggle" />
          </admin-settings-field>
          <admin-settings-field label="Standaard Cache Duur (min)" helpText="De standaard duur voor gecachte data.">
            <royal-code-ui-input formControlName="defaultCacheDurationMinutes" type="number" />
          </admin-settings-field>
          <div footer>
            <royal-code-ui-button type="primary" [disabled]="settingsForm.pristine || settingsForm.invalid">Opslaan</royal-code-ui-button>
          </div>
        </admin-settings-card>
      </div>
    </form>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SettingsSystemComponent implements OnInit {
  protected readonly AppIcon = AppIcon;
  private readonly fb = inject(FormBuilder);
  private readonly settingsService = inject(SettingsDataService);

  settingsForm!: FormGroup;

  logLevelOptions: SelectOption[] = [
    { value: 'Debug', label: 'Debug' },
    { value: 'Info', label: 'Info' },
    { value: 'Warning', label: 'Waarschuwing' },
    { value: 'Error', label: 'Fout' },
    { value: 'Critical', label: 'Kritiek' },
  ];

  ngOnInit(): void {
    this.initializeForm();
    this.loadData();
  }

  initializeForm(): void {
    this.settingsForm = this.fb.group({
      globalLogLevel: ['Info', Validators.required],
      sentryDsn: [''],
      frontendCacheClearButtonEnabled: [true],
      backendCacheClearButtonEnabled: [true],
      defaultCacheDurationMinutes: [60, [Validators.required, Validators.min(0)]],
      apiHealthCheckEnabled: [true],
      cronJobMonitoringEnabled: [true],
    });
  }

  loadData(): void {
    this.settingsService.getSystemSettings().subscribe(data => {
      this.settingsForm.patchValue(data);
    });
  }

  saveSettings(): void {
    if (this.settingsForm.valid) {
      console.log('Dummy Save System Settings:', this.settingsForm.value);
      this.settingsForm.markAsPristine();
      // Toon notificatie in echte implementatie
    }
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/user-form/user-form.component.ts ---
/**
 * @file user-form.component.ts
 * @version 5.0.0 (SuperAdmin Role Protection)
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-07-30
 * @description Reusable form for users, with a disabled checkbox for the 'SuperAdmin' role.
 */
import { Component, ChangeDetectionStrategy, input, output, OnInit, computed, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { RouterModule } from '@angular/router';
import { CreateUserPayload, UpdateUserPayload, AdminUser, Role } from '@royal-code/features/admin-users/domain';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiTextareaComponent } from '@royal-code/ui/textarea';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { AdminUsersFacade, AdminUsersViewModel } from '@royal-code/features/admin-users/core';
import { TranslateModule } from '@ngx-translate/core';
import { effect } from '@angular/core';

@Component({
  selector: 'admin-user-form',
  standalone: true,
  imports: [
    CommonModule, ReactiveFormsModule, RouterModule, TranslateModule,
    UiTitleComponent, UiButtonComponent, UiInputComponent,
    UiTextareaComponent, UiSpinnerComponent
  ],
  template: `
    <form [formGroup]="userForm" (ngSubmit)="onSave()">
      <!-- Header -->
      <div class="sticky top-0 z-10 bg-background/95 backdrop-blur-sm py-4 border-b border-border px-4">
        <div class="flex justify-between items-center">
          <royal-code-ui-title [level]="TitleTypeEnum.H1" [text]="isEditMode() ? ('admin.users.editTitle' | translate) : ('admin.users.createTitle' | translate)" />
          <div class="flex items-center gap-3">
            <royal-code-ui-button type="outline" routerLink="/users">{{ 'common.buttons.cancel' | translate }}</royal-code-ui-button>
            <royal-code-ui-button type="primary" htmlType="submit" [disabled]="!userForm.valid || viewModel().isSubmitting">
              @if (viewModel().isSubmitting) { <royal-code-ui-spinner size="sm" extraClass="mr-2" /><span>{{ 'common.buttons.saving' | translate }}</span> }
              @else { <span>{{ 'common.buttons.save' | translate }}</span> }
            </royal-code-ui-button>
          </div>
        </div>
      </div>

      <div class="p-2 md:p-4 grid grid-cols-1 lg:grid-cols-3 gap-8">
        <!-- Main Content -->
        <div class="lg:col-span-2 space-y-6">
          <!-- Account Info -->
          <div class="p-6 bg-card border border-border rounded-xs">
            <h3 class="text-lg font-medium mb-4">{{ 'admin.users.form.accountInfo' | translate }}</h3>
            <div class="space-y-4">
              <royal-code-ui-input [label]="'admin.users.form.email' | translate" formControlName="email" type="email" [required]="true" />
              <royal-code-ui-input [label]="'admin.users.form.displayName' | translate" formControlName="displayName" [required]="true" />
            </div>
          </div>
          <!-- Profile Info -->
          <div class="p-6 bg-card border border-border rounded-xs">
            <h3 class="text-lg font-medium mb-4">{{ 'admin.users.form.profileInfo' | translate }}</h3>
            <div class="space-y-4">
              <royal-code-ui-input [label]="'admin.users.form.firstName' | translate" formControlName="firstName" />
              <royal-code-ui-input [label]="'admin.users.form.middleName' | translate" formControlName="middleName" />
              <royal-code-ui-input [label]="'admin.users.form.lastName' | translate" formControlName="lastName" />
              <royal-code-ui-textarea [label]="'admin.users.form.bio' | translate" formControlName="bio" [rows]="4" />
            </div>
          </div>
           <!-- Password Section -->
          <div class="p-6 bg-card border border-border rounded-xs">
            <h3 class="text-lg font-medium mb-4">{{ 'admin.users.form.password' | translate }}</h3>
            <div class="space-y-4">
                @if (isEditMode()) {
                    <royal-code-ui-input [label]="'admin.users.form.newPassword' | translate" formControlName="newPassword" type="password" />
                    <div class="flex justify-end">
                        <royal-code-ui-button type="primary" (clicked)="onSetPassword()" [disabled]="!userForm.get('newPassword')?.value">
                            {{ 'admin.users.form.setPasswordButton' | translate }}
                        </royal-code-ui-button>
                    </div>
                } @else {
                    <royal-code-ui-input [label]="'admin.users.form.password' | translate" formControlName="password" type="password" [required]="true" />
                }
            </div>
          </div>
        </div>
        <!-- Sidebar -->
        <aside class="lg:col-span-1 space-y-6 sticky top-24">
          <!-- Roles -->
          <div class="p-6 bg-card border border-border rounded-xs">
            <h3 class="text-lg font-medium mb-4">{{ 'admin.users.form.roles' | translate }}</h3>
            <div class="space-y-2">
              @for(role of viewModel().availableRoles; track role.id) {
                <label class="flex items-center" [class.cursor-not-allowed]="role.name === 'SuperAdmin'" [class.opacity-60]="role.name === 'SuperAdmin'">
                  <input 
                    type="checkbox" 
                    [checked]="isRoleSelected(role)" 
                    (change)="toggleRole(role)" 
                    class="mr-2 h-4 w-4 rounded text-primary focus:ring-primary border-border"
                    [disabled]="role.name === 'SuperAdmin'">
                  <span>{{ role.name }}</span>
                </label>
              }
            </div>
          </div>
          <!-- Account Status -->
          @if (isEditMode() && user()) {
            <div class="p-6 bg-card border border-border rounded-xs">
                <h3 class="text-lg font-medium mb-4">Account Status</h3>
                @if (user()!.isLockedOut) {
                    <p class="text-sm text-warning mb-4">This account is currently locked.</p>
                    <royal-code-ui-button type="primary" (clicked)="onUnlockUser()">
                        Unlock Account
                    </royal-code-ui-button>
                } @else {
                     <p class="text-sm text-secondary mb-4">This account is active.</p>
                    <royal-code-ui-button type="fire" (clicked)="onLockUser()">
                        Lock Account
                    </royal-code-ui-button>
                }
            </div>
          }
        </aside>
      </div>
    </form>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class UserFormComponent implements OnInit {
  user = input<AdminUser>();
  viewModel = input.required<AdminUsersViewModel>();
  save = output<UpdateUserPayload>();
  lockUser = output<void>();
  unlockUser = output<void>();
  setPassword = output<string>();

  isEditMode = computed(() => !!this.user());
  protected readonly TitleTypeEnum = TitleTypeEnum;
  userForm: FormGroup;

  constructor(private fb: FormBuilder) {
    this.userForm = this.fb.group({
      email: ['', [Validators.required, Validators.email]],
      displayName: ['', Validators.required],
      firstName: [''],
      middleName: [null],
      lastName: [''],
      bio: [''],
      roles: this.fb.control([] as string[]),
      password: [''],
      newPassword: [''],
    });

    effect(() => {
        const userData = this.user();
        if (this.isEditMode() && userData) {
            this.userForm.patchValue({
                ...userData,
                roles: userData.roles
            });
            this.userForm.get('email')?.disable();
            this.userForm.get('password')?.clearValidators();
            this.userForm.get('newPassword')?.reset();
        } else {
            this.userForm.reset({ roles: [] });
            this.userForm.get('email')?.enable();
            this.userForm.get('password')?.setValidators([Validators.required, Validators.minLength(6)]);
        }
        this.userForm.get('password')?.updateValueAndValidity();
    }, { allowSignalWrites: true });
  }

  ngOnInit(): void {
    if (!this.isEditMode()) {
        this.userForm.get('password')?.setValidators([Validators.required, Validators.minLength(6)]);
    }
  }

  isRoleSelected(role: Role): boolean {
    return this.userForm.get('roles')?.value.includes(role.name);
  }

  toggleRole(role: Role): void {
    if (role.name === 'SuperAdmin') return; // Voorkom wijziging
    const rolesControl = this.userForm.get('roles');
    if (!rolesControl) return;
    const currentRoles = [...rolesControl.value as string[]];
    const index = currentRoles.indexOf(role.name);
    if (index > -1) {
      currentRoles.splice(index, 1);
    } else {
      currentRoles.push(role.name);
    }
    rolesControl.setValue(currentRoles);
  }

  onSave(): void {
    if (this.userForm.invalid) return;
    const rawValue = this.userForm.getRawValue();
    if (this.isEditMode()) {
        const payload: UpdateUserPayload = {
            displayName: rawValue.displayName,
            firstName: rawValue.firstName,
            middleName: rawValue.middleName,
            lastName: rawValue.lastName,
            bio: rawValue.bio,
            roles: rawValue.roles
        };
        this.save.emit(payload);
    } else {
        const payload: CreateUserPayload = {
            email: rawValue.email,
            password: rawValue.password,
            displayName: rawValue.displayName,
            firstName: rawValue.firstName,
            middleName: rawValue.middleName,
            lastName: rawValue.lastName,
            bio: rawValue.bio,
            roles: rawValue.roles
        };
        this.save.emit(payload as any);
    }
  }

  onLockUser(): void { this.lockUser.emit(); }
  onUnlockUser(): void { this.unlockUser.emit(); }

  onSetPassword(): void {
    const newPassword = this.userForm.get('newPassword')?.value;
    if (newPassword) {
      this.setPassword.emit(newPassword);
      this.userForm.get('newPassword')?.reset();
    }
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/components/variant-media-debugger/variant-media-debugger.component.ts ---
import { Component, ChangeDetectionStrategy, input, OnInit, signal, inject, computed, Signal } from '@angular/core'; // Voeg Signal en computed toe
import { CommonModule, JsonPipe } from '@angular/common';
import { Product, VariantAttribute, VariantAttributeValue } from '@royal-code/features/products/domain';
import { LoggerService } from '@royal-code/core/logging';
import { Media, Image, MediaType } from '@royal-code/shared/domain';
import { MediaFacade } from '@royal-code/features/media/core';
import { AdminProductApiService } from '@royal-code/features/admin-products/data-access';
import { BackendProductDetailDto } from '@royal-code/features/products/core';

@Component({
  selector: 'variant-media-debugger',
  standalone: true,
  imports: [CommonModule, JsonPipe],
  template: `
    <div class="p-4 border-4 border-dashed border-red-700 space-y-6">
      <!-- Bestaande Tekst Debugger -->
      <div>
        <h2 class="text-lg font-bold text-red-700">--- VARIANT MEDIA DEBUGGER (TEKST) ---</h2>
        @if (debugProductData(); as debugData) {
          <h3 class="font-semibold mt-4">Product: {{ debugData.name }} (ID: {{ debugData.id }})</h3>
          <p>Aantal variant attributen: {{ debugData.variantAttributes.length }}</p>
          @for (attr of debugData.variantAttributes; track attr.id) {
            <div class="mt-2 p-2 border border-border rounded">
              <p class="font-semibold">Attribuut: {{ attr.name }}</p>
              @for (val of attr.values; track val.id) {
                <div class="pl-4 mt-1">
                  <p class="font-mono text-sm">Value: {{ val.displayName }}</p>
                  <p class="font-mono text-xs">Media items (lengte): <strong>{{ val.mediaLength }}</strong></p>
                  <pre class="text-xs bg-surface-alt p-1 rounded-md overflow-auto">{{ val.fullMediaObjects | json }}</pre>
                </div>
              }
            </div>
          }
        } @else {
          <p class="text-destructive font-bold mt-4">GEEN PRODUCT ONTVANGEN!</p>
        }
      </div>

      <!-- Bestaande Checkbox Debugger -->
      <div class="p-4 border-4 border-dashed border-sun">
        <h2 class="text-lg font-bold text-sun">--- CHECKBOX DEBUGGER (VISUEEL) ---</h2>
        <p>Deze test leest direct uit het \`product()\` signaal en controleert de \`.media\` eigenschap.</p>
         @if (product(); as p) {
            @for(attr of p.variantAttributes; track attr.id) {
              <div class="mt-2 p-2 border border-border rounded">
                <p class="font-semibold">{{ attr.name }}</p>
                @for(val of attr.values; track val.id) {
                  <div class="pl-4 mt-1">
                    <p class="font-mono text-sm">{{ val.displayName }}</p>
                    <div class="flex flex-wrap gap-2 mt-1">
                      @for(media of uploadedMedia(); track media.id) {
                        <label class="flex items-center gap-1.5 cursor-pointer p-1 border rounded-md" [class.border-primary]="isMediaLinkedDirectly(val, media.id)" [class.border-border]="!isMediaLinkedDirectly(val, media.id)">
                          <input type="checkbox" [checked]="isMediaLinkedDirectly(val, media.id)" disabled class="h-4 w-4">
                          <img [src]="getMediaUrl(media)" [alt]="getMediaAltText(media)" class="w-6 h-6 rounded-sm object-cover">
                        </label>
                      }
                      @if(uploadedMedia().length === 0) {
                        <p class="text-xs text-secondary italic">Geen media in MediaFacade gevonden.</p>
                      }
                    </div>
                  </div>
                }
              </div>
            }
         }
      </div>

      <!-- NIEUWE SECTIE: RAW DTO FULL JSON PRINT -->
      <div class="p-4 border-4 border-dashed border-purple-700">
        <h2 class="text-lg font-bold text-purple-700">--- RAW DTO VOLLEDIGE JSON (DIRECTE API CALL) ---</h2>
        <p>Dit is de complete, onbewerkte DTO precies zoals deze van de backend komt.</p>
        @if (rawDtoFull(); as dto) {
          <pre class="text-xs  p-2 rounded-md overflow-auto">{{ dto | json }}</pre>
          <p class="font-semibold mt-4">Detailcheck: Media in 'blauw' variant:</p>
          <pre class="text-xs  p-2 rounded-md overflow-auto">{{ getBlauwVariantMedia(dto) | json }}</pre>
        } @else if (rawDtoLoading()) {
          <p class="text-blue-500 font-bold mt-4">Laden van ruwe DTO JSON...</p>
        } @else {
          <p class="text-red-700 font-bold mt-4">GEEN RUWE DTO JSON ONTVANGEN OF FOUT!</p>
        }
      </div>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class VariantMediaDebuggerComponent implements OnInit {
  product = input.required<Product>();

  private readonly logger = inject(LoggerService);
  private readonly mediaFacade = inject(MediaFacade);
  private readonly adminProductApiService = inject(AdminProductApiService);

  protected readonly uploadedMedia = this.mediaFacade.allMedia;
  protected rawDtoFull = signal<BackendProductDetailDto | undefined>(undefined);
  protected rawDtoLoading = signal(true);

  debugProductData: Signal<{ id: string; name: string; variantAttributes: { id: string; name: string; values: { id: string; displayName: string; mediaLength: number; fullMediaObjects: Media[]; }[]; }[] } | undefined> = computed(() => {
    const p = this.product();
    if (!p) return undefined;
    
    const debugAttributes = (p.variantAttributes ?? []).map(attr => ({
      id: attr.id,
      name: attr.name,
      values: (attr.values ?? []).map(val => ({
        id: val.id,
        displayName: val.displayName,
        mediaLength: (val.media ?? []).length,
        fullMediaObjects: (val.media ?? []) as Media[]
      }))
    }));
    return { id: p.id, name: p.name, variantAttributes: debugAttributes };
  });

  ngOnInit(): void {
    this.rawDtoLoading.set(true);
    this.adminProductApiService.getProductById(this.product().id).subscribe({
      next: (dto) => {
        this.rawDtoFull.set(dto);
        this.rawDtoLoading.set(false);
        this.logger.debug(`[RAW DTO FULL JSON] Raw DTO loaded into debugger. Media in 'blauw' variant:`, this.getBlauwVariantMedia(dto));
      },
      error: (err) => {
        this.logger.error(`[RAW DTO FULL JSON] Fout bij laden ruwe DTO:`, err);
        this.rawDtoFull.set(undefined);
        this.rawDtoLoading.set(false);
      }
    });
  }

  // Helper voor de RAW DTO sectie om specifieke media te tonen zonder crashes
  getBlauwVariantMedia(dto: BackendProductDetailDto): any | null {
    try {
      const colorAttr = dto.variantAttributes?.find(a => a.nameKeyOrText === 'attribute.color');
      const blauwValue = colorAttr?.values.find(v => v.value === 'blauw');
      return blauwValue?.media ?? null;
    } catch (e) {
      this.logger.error(`[getBlauwVariantMedia] Fout bij ophalen blauwe media uit DTO:`, e);
      return null;
    }
  }

  // Helpers voor de checkbox debugger
  isMediaLinkedDirectly(value: VariantAttributeValue, mediaId: string): boolean {
    const isLinked = (value.media ?? []).some(m => m.id === mediaId);
    return isLinked;
  }

  getMediaUrl(media: Media): string {
    if (media.type === MediaType.IMAGE && (media as Image).variants.length > 0) {
      return (media as Image).variants[0].url;
    }
    return (media as any).url || '';
  }

  getMediaAltText(media: Media): string {
    if (media.type === MediaType.IMAGE) {
      return (media as Image).altText || 'Media';
    }
    return (media as any).title || 'Media';
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/pages/dashboard-page/dashboard-page.component.ts ---
/**
 * @file dashboard-page.component.ts
 * @Version 4.2.1 (Cleaned - Removed Redundant DecimalPipe Import)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Definitive smart component for the admin dashboard, now cleaned of redundant DecimalPipe import.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { TranslateModule } from '@ngx-translate/core';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { UiButtonComponent } from '@royal-code/ui/button';
import { AppIcon } from '@royal-code/shared/domain';
import { UiIconComponent } from '@royal-code/ui/icon';
import { AdminDashboardFacade } from '@royal-code/features/admin-dashboard/core';
import { Kpi } from '@royal-code/features/admin-dashboard/domain';
import { DashboardKpiCardComponent, KpiCardData } from '../../components/dashboard-kpi-card/dashboard-kpi-card.component';
import { DashboardSalesChartComponent } from '../../components/dashboard-sales-chart/dashboard-sales-chart.component';
import { DashboardRecentOrdersComponent } from '../../components/dashboard-recent-orders/dashboard-recent-orders.component';
import { DashboardRecentReviewsComponent } from '../../components/dashboard-recent-reviews/dashboard-recent-reviews.component';
import { DashboardBestsellersComponent } from '../../components/dashboard-bestsellers/dashboard-bestsellers.component';

@Component({
  selector: 'admin-dashboard-page',
  standalone: true,
  imports: [
    CommonModule, RouterModule, TranslateModule,
    UiTitleComponent, UiButtonComponent, UiIconComponent,
    DashboardKpiCardComponent, DashboardSalesChartComponent,
    DashboardRecentOrdersComponent, DashboardRecentReviewsComponent,
    DashboardBestsellersComponent
    // DecimalPipe is verwijderd uit de imports, want CommonModule levert het al
  ],
  template: `
    <div class="space-y-6">
      <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
        <royal-code-ui-title [level]="TitleTypeEnum.H1" text="Welkom terug, Admin!" />
        <div class="flex items-center gap-2">
          <royal-code-ui-button type="outline">
            <royal-code-ui-icon [icon]="AppIcon.Download" extraClass="mr-2" />
            Rapport Downloaden
          </royal-code-ui-button>
          <royal-code-ui-button type="primary" routerLink="/products/new">
             <royal-code-ui-icon [icon]="AppIcon.Plus" extraClass="mr-2" />
            Nieuw Product
          </royal-code-ui-button>
        </div>
      </div>

      <!-- KPI Cards -->
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        @if (viewModel().stats; as stats) {
          <admin-dashboard-kpi-card [data]="mapKpiToCardData(AppIcon.Euro, 'Totale Omzet', stats.totalRevenue, 'currency')" />
          <admin-dashboard-kpi-card [data]="mapKpiToCardData(AppIcon.ShoppingCart, 'Verkopen', stats.totalSales, 'decimal')" />
          <admin-dashboard-kpi-card [data]="mapKpiToCardData(AppIcon.Users, 'Nieuwe Klanten', stats.newCustomers, 'decimal')" />
          <admin-dashboard-kpi-card [data]="{ icon: AppIcon.Star, label: 'Openstaande Reviews', value: stats.pendingReviewsCount, format: 'none' }" />
        } @else if (viewModel().isLoading) {
           @for (_ of [1,2,3,4]; track $index) {
             <div class="bg-card border border-border rounded-xs p-4 h-[92px] animate-pulse"></div>
           }
        }
      </div>

      <!-- Main Grid: Chart & Recent Activities -->
      <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div class="lg:col-span-2">
          <admin-dashboard-sales-chart [data]="viewModel().revenueChartData?.dataPoints" />
        </div>
        <div class="lg:col-span-1">
          <admin-dashboard-recent-orders [orders]="viewModel().recentOrders" />
        </div>
      </div>

      <!-- Second Row: Bestsellers & Reviews -->
       <div class="grid grid-cols-1 lg:col-span-3 gap-6">
        <div class="lg:col-span-2">
          <admin-dashboard-bestsellers [bestsellers]="viewModel().bestsellers" />
        </div>
        <div class="lg:col-span-1">
          <admin-dashboard-recent-reviews [reviews]="viewModel().pendingReviews" />
        </div>
      </div>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class DashboardPageComponent implements OnInit {
  protected readonly TitleTypeEnum = TitleTypeEnum;
  protected readonly AppIcon = AppIcon;
  private readonly facade = inject(AdminDashboardFacade);

  protected readonly viewModel = this.facade.viewModel;

  ngOnInit(): void {
    this.facade.init();
  }

  mapKpiToCardData(icon: AppIcon, label: string, kpi: Kpi, format: 'currency' | 'decimal' | 'none'): KpiCardData {
    return {
      icon: icon,
      label: label,
      value: kpi.value,
      format: format,
      trendData: kpi
    };
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/pages/order-create-page/order-create-page.component.ts ---
/**
 * @file order-create-page.component.ts
 * @Version 1.1.0 (Corrected Facade Access)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-23
 * @Description Simple page for creating a new admin order.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { Router, RouterModule } from '@angular/router';
import { AdminOrdersFacade } from '@royal-code/features/admin-orders/core';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';

@Component({
  selector: 'admin-order-create-page',
  standalone: true,
  imports: [
    CommonModule, RouterModule, ReactiveFormsModule,
    UiTitleComponent, UiButtonComponent, UiInputComponent, UiSpinnerComponent,
  ],
  template: `
    <form [formGroup]="createOrderForm" (ngSubmit)="createOrder()">
      <div class="sticky top-0 z-10 bg-background/95 backdrop-blur-sm py-4 px-4 border-b border-border">
        <div class="flex justify-between items-center">
          <royal-code-ui-title [level]="TitleTypeEnum.H1" text="Nieuwe Order Maken" />
          <div class="flex items-center gap-3">
            <royal-code-ui-button type="outline" routerLink="/orders">Annuleren</royal-code-ui-button>
            <royal-code-ui-button type="primary" htmlType="submit" [disabled]="createOrderForm.invalid || facade.isSubmitting()">
              @if (facade.isSubmitting()) {
                <royal-code-ui-spinner size="sm" extraClass="mr-2" />
                <span>Maken...</span>
              } @else {
                <span>Order Maken</span>
              }
            </royal-code-ui-button>
          </div>
        </div>
      </div>

      <div class="p-2 md:p-4 space-y-6">
        <div class="p-6 bg-card border border-border rounded-xs">
          <h3 class="text-lg font-medium mb-4">Basisgegevens</h3>
          <div class="space-y-4">
            <royal-code-ui-input label="Klant E-mail" formControlName="customerEmail" type="email" [required]="true" />
            <royal-code-ui-input label="Verzendadres ID (mock)" formControlName="shippingAddressId" [required]="true" />
            <royal-code-ui-input label="Product ID (voor test, mock)" formControlName="productId" [required]="true" />
            <royal-code-ui-input label="Aantal (voor test)" formControlName="quantity" type="number" [required]="true" />
          </div>
        </div>
      </div>
    </form>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class OrderCreatePageComponent {
  protected readonly facade = inject(AdminOrdersFacade);
  private readonly fb = inject(FormBuilder);
  private readonly router = inject(Router);

  protected readonly TitleTypeEnum = TitleTypeEnum;

  createOrderForm: FormGroup = this.fb.group({
    customerEmail: ['', [Validators.required, Validators.email]],
    shippingAddressId: ['', Validators.required],
    productId: ['', Validators.required],
    quantity: [1, [Validators.required, Validators.min(1)]],
  });

  createOrder(): void {
    if (this.createOrderForm.invalid) {
      this.createOrderForm.markAllAsTouched();
      alert('Vul alle verplichte velden in.');
      return;
    }
    const formValue = this.createOrderForm.getRawValue();
    const payload = {
      customerEmail: formValue.customerEmail,
      shippingAddressId: formValue.shippingAddressId,
      items: [{ productId: formValue.productId, quantity: formValue.quantity }],
      paymentMethod: 'Credit Card',
      customerNotes: 'Created via admin panel',
    };
    alert('Order aanmaken nog niet geïmplementeerd in de facade. Payload: ' + JSON.stringify(payload, null, 2));
    // this.facade.createOrder(payload);
    this.router.navigate(['/orders']);
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/pages/order-detail-page/order-detail-page.component.ts ---
/**
 * @file order-detail-page.component.ts
 * @Version 4.0.0 (Definitive - Full i18n & Robust Item Array Binding)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description
 *   Definitive smart component fully synced and integrated with all i18n keys for a comprehensive
 *   and translatable order detail view, now with robust binding for the order items array.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit, OnDestroy, effect, signal } from '@angular/core';
import { CommonModule, JsonPipe, KeyValuePipe } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators, FormArray } from '@angular/forms';
import { ActivatedRoute, RouterModule } from '@angular/router';
import { filter, map, Subject, takeUntil } from 'rxjs';
import { Order, OrderItem, OrderStatus } from '@royal-code/features/orders/domain';
import { Address, AppIcon } from '@royal-code/shared/domain';
import { AdminOrdersFacade } from '@royal-code/features/admin-orders/core';
import { NotificationService } from '@royal-code/ui/notifications';
import { TranslateService, TranslateModule } from '@ngx-translate/core';
import { OrderItemUpdate, OrderItemsTableComponent } from '@royal-code/features/admin-orders/ui';

// UI Components
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiIconComponent } from '@royal-code/ui/icon';
import { UiTextareaComponent } from '@royal-code/ui/textarea';

// Dumb presentational components
import { OrderCustomerInfoComponent, OrderActionsCardComponent, AdminOrderFinancialsCardComponent, AdminOrderPaymentDetailsComponent } from '@royal-code/features/admin-orders/ui';
import { DynamicOverlayService } from '@royal-code/ui/overlay';
import { AddProductResult, AddProductToOrderDialogComponent } from '../../../../../../libs/features/admin-orders/ui/src';

@Component({
  selector: 'royal-code-admin-order-detail-page',
  standalone: true,
  imports: [
    CommonModule, RouterModule, ReactiveFormsModule, JsonPipe, TranslateModule, KeyValuePipe,
    UiTitleComponent, UiSpinnerComponent, UiButtonComponent, UiIconComponent, UiTextareaComponent,
    OrderCustomerInfoComponent, OrderItemsTableComponent, OrderActionsCardComponent, AdminOrderFinancialsCardComponent, AdminOrderPaymentDetailsComponent
  ],
    template: `
    <form [formGroup]="orderForm">
      <!-- Header -->
      <div class="sticky top-0 z-10 bg-background/95 backdrop-blur-sm py-4 px-4 border-b border-border">
        <div class="flex justify-between items-center">
          <royal-code-ui-title [level]="TitleTypeEnum.H1" [text]="pageTitle()" />
          <div class="flex items-center gap-3">
            <royal-code-ui-button type="outline" routerLink="/orders">{{ 'common.buttons.back' | translate }}</royal-code-ui-button>
          </div>
        </div>
      </div>

      <!-- Content Grid -->
      <div class="p-2 md:p-4 grid grid-cols-1 lg:grid-cols-3 gap-8">
        @if (facade.isLoading() && !selectedOrder()) {
          <div class="lg:col-span-3 flex justify-center items-center h-64"><royal-code-ui-spinner size="lg" /></div>
        } @else {
          @if (selectedOrder(); as order) {
            <!-- Main Content Column -->
            <div class="lg:col-span-2 space-y-6">
              <div class="p-6 bg-card border border-border rounded-xs flex flex-col">
                <h3 class="text-lg font-medium mb-4">{{ 'admin.orders.detail.products' | translate }}</h3>
                <div>
                  <admin-order-items-table [parentFormGroup]="orderForm" (addItem)="addItem()" (removeItem)="removeOrderItem($event)" (itemUpdated)="updateOrderItem($event)" />
                </div>
                <div class="pt-4 mt-4 border-t border-border flex justify-end gap-2">
                   <royal-code-ui-button type="outline" sizeVariant="sm" (clicked)="addItem()">
                     <royal-code-ui-icon [icon]="AppIcon.Plus" extraClass="mr-2" /> {{ 'admin.orders.detail.addProducts' | translate }}
                   </royal-code-ui-button>
                   <royal-code-ui-button type="primary" sizeVariant="sm" (clicked)="saveOrderItems()" [disabled]="!itemsFormArray.dirty || facade.isSubmitting()">
                      @if (facade.isSubmitting()) { <royal-code-ui-spinner size="xs" extraClass="mr-2"/> }
                      <span>{{ 'common.buttons.save' | translate }} {{ 'admin.orders.detail.products' | translate }}</span>
                   </royal-code-ui-button>
                 </div>
              </div>
              <div class="p-6 bg-card border border-border rounded-xs flex flex-col ">
                <h3 class="text-lg font-medium mb-4 flex-shrink-0">{{ 'admin.orders.detail.notes' | translate }}</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 flex-grow">
                  <div>
                    <h4 class="text-sm font-semibold mb-2">{{ 'admin.orders.detail.customerNotes' | translate }}</h4>
                    <p class="text-sm text-secondary p-3 bg-surface-alt rounded-md min-h-24">{{ order.customerNotes || ('admin.orders.detail.noNotes' | translate) }}</p>
                  </div>
                  <div>
                    <h4 class="text-sm font-semibold mb-2">{{ 'admin.orders.detail.internalNotes' | translate }} ({{ 'common.buttons.edit' | translate }})</h4>
                    <royal-code-ui-textarea formControlName="internalNotes" [rows]="4" />
                  </div>
                </div>
                 <div class="pt-4 mt-4 border-t border-border flex justify-end">
                   <royal-code-ui-button type="primary" sizeVariant="sm" (clicked)="saveInternalNotes()" [disabled]="!orderForm.get('internalNotes')?.dirty || facade.isSubmitting()">
                      @if (facade.isSubmitting()) { <royal-code-ui-spinner size="xs" extraClass="mr-2"/> }
                      <span>{{ 'admin.orders.detail.saveNotes' | translate }}</span>
                   </royal-code-ui-button>
                 </div>
              </div>
            </div>

            <!-- Sidebar Column -->
            <aside class="lg:col-span-1 space-y-6 sticky top-24">
              <div class="p-6 bg-card border border-border rounded-xs">
                 <h3 class="text-lg font-medium mb-4">{{ 'admin.orders.detail.actionsAndDocuments' | translate }}</h3>
                 <admin-order-actions-card [parentFormGroup]="orderForm" [lookups]="facade.lookups()" (cancelOrder)="onCancelOrder(order.id)" (refundOrder)="onRefundOrder(order.id)" />
                 <div class="flex flex-col gap-2 pt-4 mt-4 border-t border-border">
                    <royal-code-ui-button type="outline" (clicked)="onDownloadInvoice(order.id)">{{ 'admin.orders.detail.downloadInvoice' | translate }}</royal-code-ui-button>
                    <royal-code-ui-button type="outline" (clicked)="onExport()">{{ 'admin.orders.detail.exportOrder' | translate }}</royal-code-ui-button>
                 </div>
                 <div class="pt-4 mt-4 border-t border-border flex justify-end">
                    <royal-code-ui-button type="primary" sizeVariant="sm" (clicked)="saveStatusAndTracking()" [disabled]="(!orderForm.get('status')?.dirty && !orderForm.get('shippingDetails')?.dirty) || facade.isSubmitting()">
                        @if (facade.isSubmitting()) { <royal-code-ui-spinner size="xs" extraClass="mr-2"/> }
                        <span>{{ 'admin.orders.detail.saveStatus' | translate }}</span>
                    </royal-code-ui-button>
                 </div>
              </div>
              <div class="p-6 bg-card border border-border rounded-xs">
                <h3 class="text-lg font-medium mb-4">{{ 'admin.orders.detail.financialSummary' | translate }}</h3>
                <admin-order-financials-card [order]="order" />
              </div>
              <div class="p-6 bg-card border border-border rounded-xs">
                <h3 class="text-lg font-medium mb-4">{{ 'admin.orders.detail.paymentDetails' | translate }}</h3>
                <admin-order-payment-details [paymentDetails]="order.paymentDetails" />
              </div>
              <div class="p-6 bg-card border border-border rounded-xs flex flex-col ">
                <h3 class="text-lg font-medium mb-4 flex-shrink-0">{{ 'admin.orders.detail.customerAndAddresses' | translate }}</h3>
                <div class="flex-grow">
                    <admin-order-customer-info [parentFormGroup]="orderForm" />
                </div>
                 <div class="pt-4 mt-4 border-t border-border flex justify-end gap-2">
                   <royal-code-ui-button type="primary" sizeVariant="sm" (clicked)="saveBillingAddress()" [disabled]="!orderForm.get('billingAddress')?.dirty || orderForm.get('billingAddress')?.invalid || facade.isSubmitting()">
                      @if (facade.isSubmitting()) { <royal-code-ui-spinner size="xs" extraClass="mr-2"/> }
                      <span>{{ 'admin.orders.detail.saveAddress' | translate }}</span>
                   </royal-code-ui-button>
                   <royal-code-ui-button type="primary" sizeVariant="sm" (clicked)="saveShippingAddress()" [disabled]="!orderForm.get('shippingAddress')?.dirty || orderForm.get('shippingAddress')?.invalid || facade.isSubmitting()">
                      @if (facade.isSubmitting()) { <royal-code-ui-spinner size="xs" extraClass="mr-2"/> }
                      <span>{{ 'admin.orders.detail.saveAddress' | translate }}</span>
                   </royal-code-ui-button>
                 </div>
              </div>
            </aside>
          } @else if (facade.viewModel().error) {
            <div class="lg:col-span-3 p-4 bg-destructive/10 text-destructive border border-destructive rounded-xs">
              <p class="font-bold">{{ 'admin.errors.loadingOrderFailed' | translate }}</p>
              <p>{{ facade.viewModel().error }}</p>
            </div>
          } @else {
             <p class="lg:col-span-3 text-center">{{ 'admin.orders.detail.orderNotFound' | translate }}</p>
          }
        }
      </div>
    </form>
  `,
  styles: [`:host { display: block; }`],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class OrderDetailPageComponent implements OnInit, OnDestroy {
  protected readonly facade = inject(AdminOrdersFacade);
  private readonly notificationService = inject(NotificationService);
  private readonly translate = inject(TranslateService);
  private readonly route = inject(ActivatedRoute);
  private readonly fb = inject(FormBuilder);
  private readonly overlayService = inject(DynamicOverlayService); 
  private readonly destroy$ = new Subject<void>();

  protected readonly TitleTypeEnum = TitleTypeEnum;
  protected readonly AppIcon = AppIcon;
  protected readonly selectedOrder = this.facade.selectedOrder;

  protected pageTitle = signal<string>('');

  orderForm: FormGroup = this.fb.group({
    status: ['', Validators.required],
    shippingDetails: this.fb.group({ trackingNumber: [''], trackingUrl: [''] }),
    customer: this.fb.group({
        customerName: [{ value: '', disabled: true }],
        customerEmail: [{ value: '', disabled: true }],
    }),
    shippingAddress: this.fb.group({
      street: ['', Validators.required], houseNumber: ['', Validators.required], postalCode: ['', Validators.required], city: ['', Validators.required], countryCode: ['', Validators.required], contactName: ['', Validators.required]
    }),
    billingAddress: this.fb.group({
      street: ['', Validators.required], houseNumber: ['', Validators.required], postalCode: ['', Validators.required], city: ['', Validators.required], countryCode: ['', Validators.required], contactName: ['', Validators.required]
    }),
    internalNotes: [''],
    items: this.fb.array([])
  });

  get itemsFormArray() {
    return this.orderForm.get('items') as FormArray;
  }

  constructor() {
    effect(() => {
      const order = this.selectedOrder();
      if (order) {
        this.pageTitle.set(this.translate.instant('admin.orders.detail.titlePrefix') + ` #${order.orderNumber}`);
        
        this.orderForm.patchValue({
          status: order.status,
          customer: { customerName: order.customerName, customerEmail: order.customerEmail },
          shippingAddress: order.shippingAddress,
          billingAddress: order.billingAddress,
          internalNotes: order.internalNotes ? order.internalNotes[0]?.text : '',
          shippingDetails: {
            trackingNumber: order.shippingDetails?.trackingNumber,
            trackingUrl: order.shippingDetails?.trackingUrl
          }
        }, { emitEvent: false });
        this.buildItemsFormArray(order.items);
        this.orderForm.markAsPristine();
      } else {
         this.pageTitle.set(this.translate.instant('admin.orders.detail.loadingOrderDetails'));
      }
    });
  }


  private buildItemsFormArray(items: readonly OrderItem[]): void {
    this.itemsFormArray.clear();
    items.forEach(item => {
      this.itemsFormArray.push(this.fb.group({
        id: [item.id],
        productName: [{ value: item.productName, disabled: true }],
        sku: [{ value: item.sku, disabled: true }],
        variantInfo: [item.variantInfo],
        productImageUrl: [item.productImageUrl],
        pricePerItem: [item.pricePerItem, [Validators.required, Validators.min(0)]],
        quantity: [item.quantity, [Validators.required, Validators.min(1)]]
      }));
    });
    this.itemsFormArray.markAsPristine();
  }

  ngOnInit(): void {
    this.facade.init();

    this.route.paramMap.pipe(
      map(params => params.get('id')),
      filter((id): id is string => !!id),
      takeUntil(this.destroy$)
    ).subscribe(id => {
      this.facade.openOrderDetailPage(id);
    });
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
    this.facade.selectOrder(null);
  }

  saveStatusAndTracking(): void {
    const statusControl = this.orderForm.get('status');
    const shippingDetailsGroup = this.orderForm.get('shippingDetails');
    const orderId = this.selectedOrder()?.id;
    if (!orderId) return;

    if (!statusControl?.dirty && !shippingDetailsGroup?.dirty) { return; }
    
    this.facade.updateStatus(orderId, statusControl?.value as OrderStatus, shippingDetailsGroup?.get('trackingNumber')?.value, shippingDetailsGroup?.get('trackingUrl')?.value);
    statusControl?.markAsPristine();
    shippingDetailsGroup?.markAsPristine();
  }

  saveShippingAddress(): void {
    const addressGroup = this.orderForm.get('shippingAddress');
    const orderId = this.selectedOrder()?.id;
    if (!orderId) return;
    
    if (!addressGroup || !addressGroup.dirty) { return; }
    
    if (addressGroup.invalid) {
      this.notificationService.showError(this.translate.instant('admin.orders.messages.invalidShippingAddress'));
      addressGroup.markAllAsTouched();
      return;
    }
    this.facade.updateShippingAddress(orderId, addressGroup.value as Address);
    addressGroup.markAsPristine();
  }
  
  saveBillingAddress(): void {
    const addressGroup = this.orderForm.get('billingAddress');
    const orderId = this.selectedOrder()?.id;
    if (!orderId) return;

    if (!addressGroup || !addressGroup.dirty) { return; }

    if (addressGroup.invalid) {
      this.notificationService.showError(this.translate.instant('admin.orders.messages.invalidShippingAddress'));
      addressGroup.markAllAsTouched();
      return;
    }
    this.facade.updateBillingAddress(orderId, addressGroup.value as Address);
    addressGroup.markAsPristine();
  }

  saveInternalNotes(): void {
    const notesControl = this.orderForm.get('internalNotes');
    const orderId = this.selectedOrder()?.id;
    if (!orderId) return;

    if (!notesControl || !notesControl.dirty) { return; }

    this.facade.updateInternalNotes(orderId, notesControl.value);
    notesControl.markAsPristine();
  }

  updateOrderItem(update: OrderItemUpdate): void {
    const itemControl = this.itemsFormArray.controls.find(c => c.value.id === update.itemId);
    if (itemControl) {
      this.itemsFormArray.markAsDirty();
    }
  }

  saveOrderItems(): void {
    const orderId = this.selectedOrder()?.id;
    if (!orderId) return;

    if (!this.itemsFormArray.dirty) {
      this.notificationService.showInfo(this.translate.instant('admin.orders.detail.noChanges'));
      return;
    }

    if (this.itemsFormArray.invalid) {
      this.notificationService.showError(this.translate.instant('admin.orders.detail.formInvalid'));
      this.itemsFormArray.markAllAsTouched();
      return;
    }
    
    this.itemsFormArray.controls.forEach(control => {
      if (control.dirty) {
        const itemValue = control.getRawValue();
        this.facade.updateOrderItem(orderId, itemValue.id, itemValue.quantity);
        control.markAsPristine();
      }
    });

    this.itemsFormArray.markAsPristine();
    this.notificationService.showSuccess(this.translate.instant('common.buttons.save') + ' ' + this.translate.instant('admin.orders.detail.products'));
  }

  removeOrderItem(itemId: string): void {
    if (confirm(this.translate.instant('admin.orders.detail.confirmRemoveItem'))) {
        const orderId = this.selectedOrder()?.id;
        if (!orderId) return;
        this.facade.removeOrderItem(orderId, itemId);
    }
  }
  
  addItem(): void {
    const orderId = this.selectedOrder()?.id;
    if (!orderId) {
      this.notificationService.showError('Kan product niet toevoegen: order ID ontbreekt.');
      return;
    }

    const dialogRef = this.overlayService.open<AddProductResult>({
      component: AddProductToOrderDialogComponent,
      data: {},
      backdropType: 'dark',
      closeOnClickOutside: true,
    });

    dialogRef.afterClosed$.pipe(
      filter((result): result is AddProductResult => !!result),
      takeUntil(this.destroy$)
    ).subscribe(result => {
      this.facade.addItemToOrder(orderId, {
        productId: result.productId,
        variantId: result.variantId,
        quantity: result.quantity,
      });
    });
  }

  onCancelOrder(orderId: string): void {
    if (confirm(this.translate.instant('admin.orders.detail.confirmCancelOrder'))) {
      this.facade.cancelOrder(orderId);
    }
  }
  
  onRefundOrder(orderId: string): void {
    const amountStr = prompt(this.translate.instant('admin.orders.detail.refundAmountPrompt'));
    if (amountStr === null) return;
    const amount = parseFloat(amountStr);
    if (isNaN(amount) || amount <= 0) {
      this.notificationService.showError(this.translate.instant('admin.orders.detail.invalidRefundAmount'));
      return;
    }
    const reason = prompt(this.translate.instant('admin.orders.detail.refundReasonPrompt'));
    if (reason === null) return;
    this.facade.refundOrder(orderId, amount, reason || 'No reason provided');
  }

  onDownloadInvoice(orderId: string): void {
    const orderNumber = this.selectedOrder()?.orderNumber;
    if (orderId && orderNumber) {
      this.facade.downloadInvoice(orderId, orderNumber);
    } else {
      this.notificationService.showError(this.translate.instant('admin.orders.detail.invoiceNotFound'));
    }
  }

  onExport(): void {
    this.notificationService.showInfo(this.translate.instant('admin.orders.detail.exportNotImplemented'));
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/pages/order-management-page/order-management-page.component.ts ---
/**
 * @file order-management-page.component.ts
 * @Version 1.3.0 (With Pagination)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-27
 * @Description Smart component for the admin order management dashboard, now with pagination.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { AdminOrdersFacade } from '@royal-code/features/admin-orders/core';
import { DashboardStatsComponent, OrderFilterComponent, OrderListComponent } from '@royal-code/features/admin-orders/ui';
import { OrderFilters } from '@royal-code/features/orders/domain';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { UiPaginationComponent } from '@royal-code/ui/pagination';

@Component({
  selector: 'admin-order-management-page',
  standalone: true,
  imports: [
    CommonModule, UiTitleComponent, DashboardStatsComponent,
    OrderFilterComponent, OrderListComponent, UiSpinnerComponent,
    UiPaginationComponent
  ],
  template: `
    @if (viewModel(); as vm) {
      <div class="space-y-6">
        <royal-code-ui-title [level]="TitleTypeEnum.H1" text="Orderbeheer" />
        
        <admin-dashboard-stats [stats]="vm.stats" />
        <admin-order-filter [lookups]="vm.lookups" (filtersChanged)="onFiltersChanged($event)" />
        <admin-order-list [orders]="vm.orders" [isLoading]="vm.isLoading" />
        
        <royal-code-ui-pagination
          [totalItems]="vm.totalCount ?? 0"
          [currentPage]="vm.filters?.page ?? 1"
          [pageSize]="vm.filters?.pageSize ?? 20"
          (goToPage)="onPageChange($event)"
        />
      </div>
    } @else {
      <div class="flex justify-center items-center h-64">
        <royal-code-ui-spinner size="lg" />
      </div>
    }
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class OrderManagementPageComponent implements OnInit {
  protected readonly facade = inject(AdminOrdersFacade);
  protected readonly TitleTypeEnum = TitleTypeEnum;

  protected readonly viewModel = this.facade.viewModel;

  ngOnInit(): void {
    this.facade.init();
  }

  onFiltersChanged(filters: Partial<OrderFilters>): void {
    this.facade.changeFilters(filters);
  }

  onPageChange(page: number): void {
    this.facade.changeFilters({ page });
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/pages/product-create-page/product-create-page.component.ts ---
/**
 * @file product-create-page.component.ts
 * @Version 4.0.0 (Definitive Container)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-27
 * @Description The definitive smart container for creating a product. It is now a lean component
 *              that delegates all UI and form logic to the fully implemented ProductFormComponent.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { AdminProductsFacade } from '@royal-code/features/admin-products/core';
import { CreateProductPayload, UpdateProductPayload } from '@royal-code/features/products/domain';
import { ProductFormComponent } from '../../components/product-form/product-form.component';

@Component({
  selector: 'admin-product-create-page',
  standalone: true,
  imports: [CommonModule, ProductFormComponent],
  template: `
    <admin-product-form
      [viewModel]="facade.viewModel()"
      (saveProduct)="onCreate($event)"
    />
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class ProductCreatePageComponent implements OnInit {
  protected readonly facade = inject(AdminProductsFacade);

ngOnInit(): void {
    this.facade.ensureFormLookupsLoaded();
    console.log('[ProductCreatePageComponent] ViewModel on init:', this.facade.viewModel());
}



  onCreate(payload: CreateProductPayload | UpdateProductPayload): void {
    // De output is een union type, maar in de create context is het altijd CreateProductPayload
    this.facade.createProduct(payload as CreateProductPayload);
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/pages/product-edit-page/product-edit-page.component.ts ---
/**
 * @file product-edit-page.component.ts
 * @Version 7.0.0 (Definitive Race Condition Fix)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-04
 * @Description
 *   De definitieve, architectonisch correcte container voor het bewerken van een product.
 *   Lost de hardnekkige race condition op door expliciet te wachten op volledig geladen
 *   productdetails voordat het formulier wordt gerenderd. Dit garandeert data-integriteit.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit, OnDestroy, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute } from '@angular/router';
import { Subject } from 'rxjs';
import { filter, map, takeUntil } from 'rxjs/operators';
import { Store } from '@ngrx/store';

import { AdminProductsFacade } from '@royal-code/features/admin-products/core';
import { CreateProductPayload, UpdateProductPayload, Product } from '@royal-code/features/products/domain';
import { Media } from '@royal-code/shared/domain';
import { MediaActions } from '@royal-code/features/media/core';

import { ProductFormComponent } from '../../components/product-form/product-form.component';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';

@Component({
  selector: 'admin-product-edit-page',
  standalone: true,
  imports: [CommonModule, ProductFormComponent, UiSpinnerComponent],
  template: `
    <!-- === DE FIX: Toon een spinner totdat de VOLLEDIGE productdata is geladen === -->
    @if (isProductDetailLoaded()) {
      <admin-product-form
        [viewModel]="viewModel()"
        [product]="viewModel().selectedProduct"
        (saveProduct)="onUpdate($event)"
      />
    } @else {
      <!-- Fallback voor laden of fouten -->
      <div class="flex justify-center items-center h-64">
        @if (viewModel().isLoading) {
          <royal-code-ui-spinner size="lg" />
        } @else if (viewModel().error) {
          <p class="p-4 text-destructive bg-destructive/10 border border-destructive rounded-md">
              Fout bij het laden van het product: {{ viewModel().error }}
          </p>
        } @else {
           <p class="p-4 text-secondary">Product wordt geladen...</p>
        }
      </div>
    }
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class ProductEditPageComponent implements OnInit, OnDestroy {
  private readonly facade = inject(AdminProductsFacade);
  private readonly store = inject(Store);
  private readonly route = inject(ActivatedRoute);
  private readonly destroy$ = new Subject<void>();

  readonly viewModel = this.facade.viewModel;

  /**
   * @computed isProductDetailLoaded
   * @description
   *   Een cruciale guard die controleert of de `selectedProduct` in de state
   *   daadwerkelijk de VOLLEDIGE data bevat. We beschouwen het als "compleet"
   *   als het de `variantCombinations` array heeft, wat alleen gebeurt na een
   *   succesvolle detail-API call. Dit voorkomt dat incomplete data uit de
   *   productenlijst-cache wordt gebruikt.
   */
  readonly isProductDetailLoaded = computed(() => {
    const vm = this.viewModel();
    // Het product is pas "echt" geladen als het niet laadt, een geselecteerd product heeft,
    // en die selectie de variant-combinaties bevat (een teken van een volledige DTO).
    return !vm.isLoading && !!vm.selectedProduct && Array.isArray(vm.selectedProduct.variantCombinations);
  });

  ngOnInit(): void {
    this.facade.ensureFormLookupsLoaded();
    this.route.paramMap.pipe(
      map(params => params.get('id')),
      filter((id): id is string => !!id),
      takeUntil(this.destroy$)
    ).subscribe(id => {
      // Deze actie triggert de `loadProductDetail` effect, die de volledige data ophaalt.
      this.facade.openProductDetailPage(id);
    });
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
    this.facade.selectProduct(null); // Ruim de selectie op bij het verlaten
  }

  onUpdate(payload: CreateProductPayload | UpdateProductPayload): void {
    const productId = this.viewModel().selectedProduct?.id;
    if (!productId) return;
    this.facade.updateProduct(productId, payload as UpdateProductPayload);
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/pages/product-management-page/product-management-page.component.ts ---
/**
 * @file product-management-page.component.ts
 * @Version 4.8.0 (Definitive - All Fixes Applied & Correct Commenting)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-26
 * @Description Definitive smart component for product management, with all fixes applied and correct commenting.
 */
import { Component, ChangeDetectionStrategy, inject, signal, computed, DestroyRef, OnInit } from '@angular/core'; // OnInit import
import { CommonModule, TitleCasePipe } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Router } from '@angular/router';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { toObservable, takeUntilDestroyed, toSignal } from '@angular/core/rxjs-interop';

import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiIconComponent } from '@royal-code/ui/icon';
import { UiInputComponent } from '@royal-code/ui/input';
import { AppIcon } from '@royal-code/shared/domain';
import { Product, ProductFilters, ProductStatus } from '@royal-code/features/products/domain';

import { AdminProductsFacade, AdminProductListViewModel } from '@royal-code/features/admin-products/core';
import { ProductListComponent } from '@royal-code/features/admin-products/ui';
import { UiPaginationComponent } from '@royal-code/ui/pagination';

@Component({
  selector: 'admin-product-management-page',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    UiTitleComponent,
    ProductListComponent,
    UiButtonComponent,
    UiIconComponent,
    UiInputComponent,
    TitleCasePipe,
    UiPaginationComponent
  ],
  template: `
    <!-- === PRODUCT MANAGEMENT HEADER === -->
    <div class="flex justify-between items-center mb-6">
      <royal-code-ui-title [level]="TitleTypeEnum.H1" text="Productbeheer" />
      <royal-code-ui-button type="primary" (clicked)="createProduct()">
        <royal-code-ui-icon [icon]="AppIcon.Plus" extraClass="mr-2"/>
        Nieuw Product
      </royal-code-ui-button>
    </div>

    <!-- === FILTERS GROUP === -->
    <div class="flex flex-col sm:flex-row gap-4 mb-6 p-4 bg-surface-alt border border-border rounded-xs">
      <royal-code-ui-input
        [ngModel]="searchTerm()"
        (ngModelChange)="onSearchTermChange($event)"
        placeholder="Zoek op naam of SKU..."
        [icon]="AppIcon.Search" iconPosition="left" extraClasses="flex-grow" />
       <select [ngModel]="statusFilter()" (ngModelChange)="statusFilter.set($event)"
        class="w-full sm:w-48 p-2 border border-input rounded-md bg-background text-sm focus:ring-primary focus:border-primary">
        <option value="all">Alle Statussen</option>
        @for (status of productStatuses; track status) {
          <option [value]="status">{{ status | titlecase }}</option>
        }
       </select>
    </div>

    <!-- === PRODUCT LISTING & PAGINATION === -->
    <div class="mt-4">
      <!-- --- Loading State --- -->
      @if (viewModel().isLoading && viewModel().products.length === 0) {
        <p>Producten laden...</p>
      } @else if (viewModel().error) {
        <!-- --- Error State --- -->
        <div class="text-center p-8 text-destructive">{{ viewModel().error }}</div>
      } @else {
        <!-- --- Product List Component --- -->
        <admin-product-list
          [products]="viewModel().products"
          (editClicked)="editProduct($event)"
          (deleteClicked)="deleteProduct($event)"
          (statusChanged)="updateStatus($event)"
          (stockChanged)="updateStock($event)" />
        
        <!-- --- Pagination Component --- -->
        <royal-code-ui-pagination
          [totalItems]="viewModel().totalCount"
          [currentPage]="viewModel().filters.page ?? 1"
          [pageSize]="viewModel().filters.pageSize ?? 20"
          (goToPage)="onPageChange($event)"
        />
      }
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class ProductManagementPageComponent implements OnInit {
  private readonly facade = inject(AdminProductsFacade);
  private readonly destroyRef = inject(DestroyRef);
  private readonly router = inject(Router);

  protected readonly TitleTypeEnum = TitleTypeEnum;
  protected readonly AppIcon = AppIcon;
  protected readonly productStatuses = Object.values(ProductStatus);

  protected readonly searchTerm = signal('');
  protected readonly statusFilter = signal('all');

  readonly viewModel = this.facade.viewModel;

  private readonly filters = computed<Partial<ProductFilters>>(() => ({
    searchTerm: this.searchTerm() || undefined,
    statuses: this.statusFilter() === 'all' ? undefined : [this.statusFilter() as ProductStatus],
  }));

  ngOnInit(): void {
    this.facade.initPage();
  }

  constructor() {
    const filters$ = toObservable(this.filters);
    filters$.pipe(
      debounceTime(300),
      distinctUntilChanged((prev, curr) => JSON.stringify(prev) === JSON.stringify(curr)),
      takeUntilDestroyed(this.destroyRef)
    ).subscribe((currentFilters: Partial<ProductFilters>) => {
      this.facade.changeFilters(currentFilters);
    });
  }
  
  onPageChange(page: number): void { this.facade.changeFilters({ page }); }
  onSearchTermChange(term: string): void { this.searchTerm.set(term); }
  createProduct(): void { this.router.navigate(['/products/new']); }
  editProduct(id: string): void { this.router.navigate(['/products', id]); }
  deleteProduct(id: string): void {
    if (confirm(`Weet u zeker dat u dit product wilt verwijderen? Dit kan niet ongedaan worden gemaakt.`)) {
      this.facade.deleteProduct(id);
    }
  }
  updateStatus(event: { productId: string; newStatus: ProductStatus }): void { this.facade.updateProduct(event.productId, { status: event.newStatus }); }
  updateStock(event: { productId: string; newStock: number }): void {
    this.facade.updateProduct(event.productId, {
      physicalProductConfig: { stockQuantity: event.newStock }
    });
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/pages/role-management-page/role-management-page.component.ts ---
/**
 * @file role-management-page.component.ts
 * @version 3.0.0 (Integrated AdminRoleListComponent Accordion)
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-07-29
 * @description Smart component for the role management page, now using the accordion list for roles and permission editing.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { AdminUsersFacade } from '@royal-code/features/admin-users/core';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiIconComponent } from '@royal-code/ui/icon';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { AppIcon } from '@royal-code/shared/domain';
import { CreateRolePayload, Role, UpdateRolePayload, UpdateRolePermissionsPayload } from '@royal-code/features/admin-users/domain';
import { AdminRoleListComponent, RoleManagementDialogComponent } from '@royal-code/features/admin-users/ui';
import { TranslateModule, TranslateService } from '@ngx-translate/core';
import { DynamicOverlayService } from '@royal-code/ui/overlay';
import { NotificationService } from '@royal-code/ui/notifications';

@Component({
  selector: 'admin-role-management-page',
  standalone: true,
  imports: [CommonModule, TranslateModule, UiTitleComponent, UiButtonComponent, UiIconComponent, UiSpinnerComponent, AdminRoleListComponent],
  template: `
    <div class="space-y-6">
      <div class="flex justify-between items-center">
        <royal-code-ui-title [level]="TitleTypeEnum.H1" [text]="'admin.roles.manageRoles' | translate" />
        <royal-code-ui-button type="primary" (clicked)="openCreateRoleDialog()">
          <royal-code-ui-icon [icon]="AppIcon.Plus" extraClass="mr-2"/>
          {{ 'admin.roles.prompts.newRoleName' | translate }}
        </royal-code-ui-button>
      </div>

      @if (vm(); as viewModel) {
        @if(viewModel.isLoading && viewModel.availableRoles.length === 0) {
          <div class="flex justify-center items-center h-64">
            <royal-code-ui-spinner size="lg" />
          </div>
        } @else {
          <admin-role-list
            [roles]="viewModel.availableRoles"
            [allPermissions]="viewModel.allPermissions"
            [permissionsByRoleId]="viewModel.permissionsByRoleId"
            [loadingPermissionsForRoleId]="viewModel.loadingPermissionsForRoleId"
            (editClicked)="onEditRole($event)"
            (deleteClicked)="onDeleteRole($event)"
            (loadPermissionsForRole)="onLoadPermissionsForRole($event)"
            (permissionsUpdated)="onUpdatePermissions($event)"
          />
        }
      }
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class RoleManagementPageComponent implements OnInit {
  protected readonly facade = inject(AdminUsersFacade);
  private readonly overlayService = inject(DynamicOverlayService);
  private readonly translate = inject(TranslateService);
  private readonly notificationService = inject(NotificationService);

  protected readonly TitleTypeEnum = TitleTypeEnum;
  protected readonly AppIcon = AppIcon;

  protected readonly vm = this.facade.viewModel;

  ngOnInit(): void {
    this.facade.initPage();
  }

  openCreateRoleDialog(): void {
    const dialogRef = this.overlayService.open({
      component: RoleManagementDialogComponent,
      data: { roles: this.vm()?.availableRoles ?? [] },
      backdropType: 'dark',
      panelClass: ['w-full', 'max-w-md']
    });

    dialogRef.componentInstance!.create.subscribe((payload: CreateRolePayload) => {
      this.facade.createRole(payload);
    });
  }

  onEditRole(role: Role): void {
    const newName = prompt(this.translate.instant('admin.roles.prompts.newNameForRole', { roleName: role.name }));
    if (newName && newName.trim().length > 0) {
      this.facade.updateRole({ id: role.id, name: newName.trim() });
    } else {
      this.notificationService.showWarning(this.translate.instant('admin.roles.messages.invalidRoleName'));
    }
  }

  onDeleteRole(role: Role): void {
    if (confirm(this.translate.instant('admin.roles.prompts.confirmDeleteRole', { roleName: role.name }))) {
      this.facade.deleteRole(role.id);
    }
  }

  onLoadPermissionsForRole(roleId: string): void {
    // Laad permissies alleen als ze nog niet in de state zitten
    if (!this.vm()?.permissionsByRoleId[roleId]) {
      this.facade.loadRolePermissions(roleId);
    }
  }
  
  onUpdatePermissions(payload: UpdateRolePermissionsPayload): void {
    this.facade.updateRolePermissions(payload);
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/pages/settings-page/settings-page.component.ts ---
/**
 * @file settings-page.component.ts
 * @Version 3.0.0 (Simplified Layout Container - Navigation Moved to AdminShell)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Simplified settings page component, now acting purely as a layout container
 *              for its sub-routes, with navigation responsibilities moved to AdminShell.
 */
import { Component, ChangeDetectionStrategy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterOutlet } from '@angular/router'; // Alleen RouterOutlet nodig

@Component({
  selector: 'admin-settings-page',
  standalone: true,
  imports: [CommonModule, RouterOutlet], // Verwijder RouterModule en UiTitleComponent
  template: `
    <div class="space-y-6">
      <!-- Hoofdtitel kan hier komen, of in elke individuele settings-subcomponent -->
      <!-- <royal-code-ui-title [level]="TitleTypeEnum.H1" text="Instellingen" /> -->
      <router-outlet />
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SettingsPageComponent {
  // << DE FIX: navItems en TitleTypeEnum verwijderd >>
  // protected readonly TitleTypeEnum = TitleTypeEnum; // Niet langer nodig
  // protected readonly navItems = signal<SettingsNavigationItem[]>([]); // Niet langer nodig
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/pages/swagger-test-page/swagger-test-page.component.ts ---
/**
 * @file swagger-test-page.component.ts
 * @Version 1.0.1 (Fixed NG5002 ICU message errors)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description A simple page to simulate Swagger for testing API endpoints by sending raw JSON payloads,
 *              now with escaped curly braces to fix Angular template parsing errors.
 */
import { Component, ChangeDetectionStrategy, inject, signal, effect } from '@angular/core';
import { CommonModule, JsonPipe } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { UiTextareaComponent } from '@royal-code/ui/textarea';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiButtonComponent } from '@royal-code/ui/button';
import { AdminProductsFacade } from '@royal-code/features/admin-products/core';
import { UpdateProductPayload } from '@royal-code/features/products/domain';
import { NotificationService } from '@royal-code/ui/notifications';
import { LoggerService } from '@royal-code/core/logging';

@Component({
  selector: 'admin-swagger-test-page',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    JsonPipe,
    UiTitleComponent,
    UiTextareaComponent,
    UiInputComponent,
    UiButtonComponent
  ],
  template: `
    <div class="space-y-6">
      <royal-code-ui-title [level]="TitleTypeEnum.H1" text="Swagger API Test Pagina" />

      <div class="p-6 bg-card border border-border rounded-xs">
        <h3 class="text-lg font-medium mb-4">Update Product (PUT /api/Products/{{ '{' }}id{{ '}' }})</h3>
        
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <!-- Input Sectie -->
          <div class="space-y-4">
            <royal-code-ui-input 
              label="Product ID" 
              [(ngModel)]="productId" 
              placeholder="Voer het product ID (GUID) in om te updaten" 
            />
            
            <label for="json-payload" class="block text-sm font-medium text-foreground">JSON Payload</label>
            <royal-code-ui-textarea 
              id="json-payload"
              [(value)]="jsonPayload"
              [rows]="25"
              [extraTextareaClasses]="'font-mono !text-xs ' + (isJsonValid() ? '' : '!border-error !ring-error')"
            />
            @if (!isJsonValid()) {
              <p class="text-sm text-error">De ingevoerde tekst is geen geldige JSON.</p>
            }
          </div>

          <!-- Output & Actie Sectie -->
          <div class="space-y-4">
            <royal-code-ui-button 
              type="primary" 
              (clicked)="submitUpdate()" 
              [disabled]="!productId() || !isJsonValid() || facade.viewModel().isSubmitting">
              Verstuur Update
            </royal-code-ui-button>
            
            <h4 class="text-md font-semibold mt-4">NgRx State & Response</h4>
            <div class="p-3 bg-surface-alt rounded-md border border-border">
              <p><strong>Is Submitting:</strong> {{ facade.viewModel().isSubmitting }}</p>
              <h5 class="font-medium mt-2">Error:</h5>
              <pre class="text-xs bg-card p-2 rounded max-h-48 overflow-auto">{{ facade.viewModel().error | json }}</pre>
            </div>
          </div>
        </div>
      </div>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SwaggerTestPageComponent {
  protected readonly TitleTypeEnum = TitleTypeEnum;
  protected readonly facade = inject(AdminProductsFacade);
  private readonly notificationService = inject(NotificationService);
  private readonly logger = inject(LoggerService);

  protected readonly productId = signal<string>('');
  protected readonly jsonPayload = signal<string>('');
  protected readonly isJsonValid = signal<boolean>(true);

  constructor() {
    // Luister naar veranderingen in jsonPayload om validatie te triggeren
    effect(() => {
      try {
        JSON.parse(this.jsonPayload());
        this.isJsonValid.set(true);
      } catch (e) {
        this.isJsonValid.set(false);
      }
    });

    // Standaard payload bij laden van de pagina
    this.jsonPayload.set(JSON.stringify(this.getExamplePayload(), null, 2));
  }

  submitUpdate(): void {
    if (!this.productId() || !this.isJsonValid()) {
      this.notificationService.showError("Product ID en een geldige JSON payload zijn vereist.");
      return;
    }

    try {
      const payload: UpdateProductPayload = JSON.parse(this.jsonPayload());
      this.logger.info(`[SwaggerTestPage] Versturen van update voor product ID ${this.productId()} met payload:`, payload);
      this.facade.updateProduct(this.productId(), payload);
    } catch (e) {
      this.logger.error("[SwaggerTestPage] Fout bij parsen van JSON payload:", e);
      this.notificationService.showError("Kon de JSON payload niet parsen.");
    }
  }

  private getExamplePayload(): any {
    return {
      name: "Bijgewerkte Productnaam via Swagger Test",
      shortDescription: "Deze beschrijving is bijgewerkt via de testpagina.",
      isActive: true,
      variantOverrides: [
        {
          tempAttributeValueIds: ["c0100001-0000-4000-8000-000000000004", "a0000001-0000-4000-8000-000000000002"],
          sku: "SWAGGER-TEST-SKU-1",
          price: 999.99
        }
      ]
    };
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/pages/user-create-page/user-create-page.component.ts ---
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { AdminUsersFacade } from '@royal-code/features/admin-users/core';
import { CreateUserPayload } from '@royal-code/features/admin-users/domain';
import { UserFormComponent } from '../../components/user-form/user-form.component';

@Component({
  selector: 'admin-user-create-page',
  standalone: true,
  imports: [CommonModule, UserFormComponent],
  template: `
    @if(vm(); as viewModel) {
      <admin-user-form [viewModel]="viewModel" (save)="onCreate($event)" />
    }
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class UserCreatePageComponent implements OnInit { // << DE FIX: Implement OnInit
  protected readonly facade = inject(AdminUsersFacade);
  protected readonly vm = this.facade.viewModel;

  ngOnInit(): void { // << DE FIX: Voeg ngOnInit toe
    this.facade.initPage(); // << DE FIX: Initialiseer de pagina om rollen te laden
  }

  onCreate(payload: any): void {
    this.facade.createUser(payload as CreateUserPayload);
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/pages/user-edit-page/user-edit-page.component.ts ---
/**
 * @file user-edit-page.component.ts
 * @version 4.0.0 (Full Implementation with Actions)
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-07-30
 * @description Smart component for editing a user, connecting form outputs to facade actions.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute } from '@angular/router';
import { AdminUsersFacade } from '@royal-code/features/admin-users/core';
import { UpdateUserPayload } from '@royal-code/features/admin-users/domain';
import { UserFormComponent } from '../../components/user-form/user-form.component';
import { filter, map } from 'rxjs';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';

@Component({
  selector: 'admin-user-edit-page',
  standalone: true,
  imports: [CommonModule, UserFormComponent, UiSpinnerComponent],
  template: `
    @if(vm(); as viewModel) {
      @if (viewModel.isLoading && !viewModel.selectedUser) {
        <div class="flex justify-center items-center h-64">
          <royal-code-ui-spinner size="lg" />
        </div>
      } @else if (viewModel.selectedUser) {
        <admin-user-form
          [viewModel]="viewModel"
          [user]="viewModel.selectedUser"
          (save)="onUpdate($event)"
          (lockUser)="onLockUser()"
          (unlockUser)="onUnlockUser()"
          (setPassword)="onSetPassword($event)"
        />
      } @else {
        <p class="p-4 text-destructive">User not found or failed to load.</p>
      }
    }
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class UserEditPageComponent implements OnInit {
  protected readonly facade = inject(AdminUsersFacade);
  private readonly route = inject(ActivatedRoute);
  protected readonly vm = this.facade.viewModel;
  private userId: string | null = null;

  ngOnInit(): void {
    this.facade.initPage();
    this.route.paramMap.pipe(
      map(params => params.get('id')),
      filter((id): id is string => !!id)
    ).subscribe(id => {
      this.userId = id;
      this.facade.selectUser(id);
    });
  }

  onUpdate(payload: UpdateUserPayload): void {
    if (this.userId) {
      this.facade.updateUser(this.userId, payload);
    }
  }
  
  onLockUser(): void {
    if (this.userId) {
      // Optioneel: vraag om een 'lockoutEnd' datum. Voor nu, permanent.
      this.facade.lockUser(this.userId, null);
    }
  }

  onUnlockUser(): void {
    if (this.userId) {
      this.facade.unlockUser(this.userId);
    }
  }

  onSetPassword(newPassword: string): void {
    if (this.userId) {
      this.facade.setPassword(this.userId, newPassword);
    }
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/pages/user-management-page/user-management-page.component.ts ---
/**
 * @file user-management-page.component.ts
 * @version 8.0.0 (Refactored - User List Only)
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-07-29
 * @description Smart component focused solely on displaying and managing the user list.
 */
import { Component, ChangeDetectionStrategy, inject, OnInit, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router } from '@angular/router';
import { AdminUsersFacade } from '@royal-code/features/admin-users/core';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiIconComponent } from '@royal-code/ui/icon';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { AppIcon } from '@royal-code/shared/domain';
import { AdminUserListComponent, AdminUserFilterComponent, UserFilters } from '@royal-code/features/admin-users/ui';
import { UiPaginationComponent } from '@royal-code/ui/pagination';
import { TranslateModule, TranslateService } from '@ngx-translate/core';

@Component({
  selector: 'admin-user-management-page',
  standalone: true,
  imports: [
    CommonModule,
    UiTitleComponent,
    UiButtonComponent,
    UiIconComponent,
    UiSpinnerComponent,
    AdminUserListComponent,
    AdminUserFilterComponent,
    UiPaginationComponent,
    TranslateModule
  ],
  template: `
    <div class="space-y-6">
      <div class="flex justify-between items-center">
        <royal-code-ui-title [level]="TitleTypeEnum.H1" [text]="'admin.users.management.title' | translate" />
        <royal-code-ui-button type="primary" (clicked)="createUser()">
          <royal-code-ui-icon [icon]="AppIcon.Plus" extraClass="mr-2"/>
          {{ 'admin.users.management.newUser' | translate }}
        </royal-code-ui-button>
      </div>

      @if (vm(); as viewModel) {
        <admin-user-filter
          [availableRoles]="availableRoleNames()"
          (filtersChanged)="onFiltersChanged($event)"
        ></admin-user-filter>

        @if(viewModel.isLoading && viewModel.users.length === 0) {
          <div class="flex justify-center items-center h-64">
            <royal-code-ui-spinner size="lg" />
          </div>
        } @else {
          <admin-user-list
            [users]="viewModel.users"
            (editClicked)="editUser($event)"
            (deleteClicked)="deleteUser($event)"
          />
          <royal-code-ui-pagination
            [totalItems]="viewModel.totalCount"
            [currentPage]="viewModel.page"
            [pageSize]="viewModel.pageSize"
            (goToPage)="onPageChange($event)"
          />
        }
      }
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class UserManagementPageComponent implements OnInit {
  protected readonly facade = inject(AdminUsersFacade);
  private readonly router = inject(Router);
  private readonly translate = inject(TranslateService);

  protected readonly TitleTypeEnum = TitleTypeEnum;
  protected readonly AppIcon = AppIcon;

  protected readonly vm = this.facade.viewModel;
  protected readonly availableRoleNames = computed(() => {
    return this.vm()?.availableRoles.map(r => r.name) ?? [];
  });

  ngOnInit(): void {
    this.facade.initPage();
  }

  onFiltersChanged(filters: UserFilters): void {
    this.facade.changeFilters({ ...filters, page: 1 });
  }

  createUser(): void {
    this.router.navigate(['/users/new']);
  }

  editUser(userId: string): void {
    this.router.navigate(['/users', userId]);
  }

  deleteUser(userId: string): void {
    if (confirm(this.translate.instant('admin.users.management.confirmDeleteUser'))) {
      this.facade.deleteUser(userId);
    }
  }

  onPageChange(page: number): void {
    this.facade.changeFilters({ page });
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/pages/variant-management-page/variant-management-page.component.ts ---
/**
 * @file variant-management-page.component.ts
 * @Version 3.1.0 (Internationalized & Final UI)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-28
 * @Description Smart component for managing global product attributes.
 */
import { Component, ChangeDetectionStrategy, computed, inject, OnInit, signal } from '@angular/core';
import { CommonModule, KeyValuePipe } from '@angular/common';
import { AdminVariantsFacade, CreateVariantValuePayload, UpdateVariantValuePayload } from '@royal-code/features/admin-variants/core';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { UiButtonComponent } from '@royal-code/ui/button';
import { AppIcon } from '@royal-code/shared/domain';
import { VariantGroupComponent, VariantCreateFormComponent, VariantInfoPanelComponent } from '@royal-code/features/admin-variants/ui';
import { DynamicOverlayService, DynamicOverlayRef } from '@royal-code/ui/overlay';
import { UiIconComponent } from '@royal-code/ui/icon';
import { TranslateModule } from '@ngx-translate/core';

@Component({
  selector: 'admin-variant-management-page',
  standalone: true,
  imports: [CommonModule, KeyValuePipe, UiTitleComponent, UiSpinnerComponent, VariantGroupComponent, VariantCreateFormComponent, UiButtonComponent, UiIconComponent, TranslateModule],
  template: `
    <div class="space-y-6">
      <div class="flex justify-between items-center">
        <div class="flex items-center gap-2">
          <royal-code-ui-title [level]="TitleTypeEnum.H1" [text]="'variants.title' | translate" />
          <royal-code-ui-button type="outline" sizeVariant="icon" (clicked)="showInfoPanel()" [title]="'variants.tooltips.pricingInfo' | translate">
             <royal-code-ui-icon [icon]="AppIcon.HelpCircle" />
          </royal-code-ui-button>
        </div>
        @if(!isCreateFormVisible()) {
          <royal-code-ui-button type="primary" (clicked)="isCreateFormVisible.set(true)">
            <royal-code-ui-icon [icon]="AppIcon.Plus" extraClass="mr-2"/>
            {{ 'variants.create.newButton' | translate }}
          </royal-code-ui-button>
        }
      </div>

      @if (isCreateFormVisible()) {
        <admin-variant-create-form 
          [attributeTypes]="attributeTypeKeys()"
          (save)="onCreateVariant($event)"
          (cancel)="isCreateFormVisible.set(false)"
        />
      }

      @if (facade.isLoading() && !hasData()) {
        <div class="flex justify-center items-center h-64"><royal-code-ui-spinner size="lg" /></div>
      } @else if (facade.error()) {
        <p class="text-destructive">{{ facade.error() }}</p>
      } @else {
        <div class="space-y-8">
          @for (group of facade.groupedAttributes() | keyvalue; track group.key) {
            <admin-variant-group 
              [groupName]="group.key" 
              [items]="group.value"
              (update)="onUpdateVariant($event)"
              (delete)="onDeleteVariant($event)"
            />
          }
        </div>
      }
    </div>
  `
,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class VariantManagementPageComponent implements OnInit {
  protected readonly facade = inject(AdminVariantsFacade);
  private readonly overlayService = inject(DynamicOverlayService);
  protected readonly TitleTypeEnum = TitleTypeEnum;
  protected readonly AppIcon = AppIcon;

  protected isCreateFormVisible = signal(false);
  protected readonly hasData = computed(() => Object.keys(this.facade.groupedAttributes()).length > 0);
  protected readonly attributeTypeKeys = computed(() => Object.keys(this.facade.groupedAttributes()));
  private infoPanelRef?: DynamicOverlayRef;

  ngOnInit(): void {
    this.facade.loadVariants();
  }

  showInfoPanel(): void {
    this.infoPanelRef = this.overlayService.open({
        component: VariantInfoPanelComponent,
        backdropType: 'dark',
        closeOnClickOutside: true,
    });
    this.infoPanelRef.componentInstance!.close.subscribe(() => {
        this.infoPanelRef?.close();
    });
  }

  onUpdateVariant(event: { id: string, payload: UpdateVariantValuePayload }): void {
    this.facade.updateVariant(event.id, event.payload);
  }

  onDeleteVariant(event: { id: string, attributeType: string }): void {
    if (confirm('Are you sure you want to delete this value? This cannot be undone.')) { // Simple confirm for now
      this.facade.deleteVariant(event.id, event.attributeType);
    }
  }
  
  onCreateVariant(payload: CreateVariantValuePayload): void {
    this.facade.createVariant(payload);
    this.isCreateFormVisible.set(false);
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/app/services/settings-data.service.ts ---
/**
 * @file settings-data.service.ts
 * @Version 7.0.1 (Fixed Duplicate 'doaPolicyUrl' in OrderSettings)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Provides complete dummy data for all admin settings categories, now with 'doaPolicyUrl' fix.
 */
import { Injectable } from '@angular/core';
import { of } from 'rxjs';

export interface GeneralSettings {
  shopName: string;
  contactEmail: string;
  customerServicePhone: string;
  companyAddress: string;
  logoUrl?: string;
  faviconUrl?: string;
  defaultLanguage: string;
  defaultCurrency: string;
  maintenanceMode: {
    enabled: boolean;
    message: string;
    allowedIpAddresses: string;
  };
  legalUrls: {
    termsOfService: string;
    privacyPolicy: string;
    returnPolicy: string;
  };
}

export interface ProductSettings {
  defaultStatus: 'draft' | 'published';
  manageStockGlobally: boolean;
  lowStockThreshold: number;
  allowBackorders: boolean;
  reviewsEnabled: boolean;
  autoApproveReviews: boolean;
  flaggedReviewsThreshold: number;
  droneDefaultEasaClassification: string;
  droneFirmwareTrackingEnabled: boolean;
  droneCompatibilityMatrixEnabled: boolean;
}

export interface OrderSettings {
  orderNumberPrefix: string;
  startOrderNumber: number;
  allowGuestCheckout: boolean;
  unpaidOrderTimeoutMinutes: number;
  rmaWorkflowEnabled: boolean;
  warrantyTermsUrl: string;
  doaPolicyUrl: string; // << DE FIX: Duplicaat verwijderd, nu slechts één keer gedeclareerd
  batteryShippingRestrictionsEnabled: boolean;
  bulkyItemHandlingEnabled: boolean;
  highValueInsuranceRequired: boolean;
  dropShippingEnabled: boolean;
  shippingProviders: { id: string; name: string; apiKey: string; }[];
  paymentProviders: { id: string; name: string; apiKey: string; }[];
}

export interface SecuritySettings {
  allowPublicRegistration: boolean;
  requireEmailVerification: boolean;
  defaultUserRole: string;
  passwordPolicy: {
    minLength: number;
    requireUppercase: boolean;
    requireLowercase: boolean;
    requireNumbers: boolean;
    requireSymbols: boolean;
  };
  adminIpAllowlist: string;
  adminSessionTimeoutMinutes: number;
}

export interface ComplianceSettings {
  easaClassificationManagementEnabled: boolean;
  requireOperatorIdVisibility: boolean;
  geoAwarenessInfoEnabled: boolean;
  droneRegistrationRequired: boolean;
  ageVerificationEnabled: boolean;
  ageVerificationThreshold: number;
  exportRestrictionsEnabled: boolean;
  itarDualUseFlagsEnabled: boolean;
  ceMarkingVerificationEnabled: boolean;
}

export interface MarketingSettings {
  googleAnalyticsId: string;
  googleTagManagerId: string;
  defaultMetaTitle: string;
  defaultMetaDescription: string;
  globalMetaKeywords: string;
  sitemapAutoGenerate: boolean;
  socialMediaLinks: { platform: string; url: string; }[];
}

export interface SystemSettings {
  globalLogLevel: 'Debug' | 'Info' | 'Warning' | 'Error' | 'Critical';
  sentryDsn: string;
  frontendCacheClearButtonEnabled: boolean;
  backendCacheClearButtonEnabled: boolean;
  defaultCacheDurationMinutes: number;
  apiHealthCheckEnabled: boolean;
  cronJobMonitoringEnabled: boolean;
}

export interface AdminPanelSettings {
  defaultTheme: 'light' | 'dark';
  customBrandingEnabled: boolean;
  newOrderNotifications: { email: boolean; inApp: boolean; };
  lowStockNotifications: { email: boolean; inApp: boolean; };
  newReviewNotifications: { email: boolean; inApp: boolean; };
}

export interface GovernanceSettings {
  rbacEnabled: boolean;
  auditLoggingEnabled: boolean;
  highRiskApprovalWorkflowEnabled: boolean;
  adminIpRateLimitingEnabled: boolean;
}

export interface DeploymentSettings {
  featureFlagsEnabled: boolean;
  configVersioningEnabled: boolean;
  stagingToProdMigrationWizardEnabled: boolean;
}


@Injectable({
  providedIn: 'root'
})
export class SettingsDataService {

  getGeneralSettings() {
    return of<GeneralSettings>({
      shopName: 'Royal-Code Drone Shop',
      contactEmail: 'support@royal-code.drones',
      customerServicePhone: '+31 6 12345678',
      companyAddress: 'Dronehaven 1, 1234 AB, Amsterdam, Nederland',
      logoUrl: 'assets/images/logo-placeholder.png',
      faviconUrl: 'assets/images/favicon-placeholder.png',
      defaultLanguage: 'nl',
      defaultCurrency: 'EUR',
      maintenanceMode: {
        enabled: false,
        message: 'We voeren momenteel onderhoud uit. Probeer het later opnieuw.',
        allowedIpAddresses: '127.0.0.1, 192.168.1.1'
      },
      legalUrls: {
        termsOfService: '/legal/terms-of-service',
        privacyPolicy: '/legal/privacy-policy',
        returnPolicy: '/legal/return-policy'
      }
    });
  }

  getProductSettings() {
    return of<ProductSettings>({
      defaultStatus: 'draft',
      manageStockGlobally: true,
      lowStockThreshold: 10,
      allowBackorders: false,
      reviewsEnabled: true,
      autoApproveReviews: false,
      flaggedReviewsThreshold: 5,
      droneDefaultEasaClassification: 'C0',
      droneFirmwareTrackingEnabled: true,
      droneCompatibilityMatrixEnabled: true,
    });
  }
  
  getOrderSettings() {
    return of<OrderSettings>({
      orderNumberPrefix: 'RC-DRONE-',
      startOrderNumber: 2025001,
      allowGuestCheckout: true,
      unpaidOrderTimeoutMinutes: 60,
      rmaWorkflowEnabled: true,
      warrantyTermsUrl: '/legal/warranty-terms',
      doaPolicyUrl: '/legal/doa-policy',
      shippingProviders: [
        { id: 'postnl', name: 'PostNL', apiKey: 'postnl-api-key-123' },
        { id: 'dhl', name: 'DHL Express', apiKey: 'dhl-api-key-456' },
      ],
      paymentProviders: [
        { id: 'mollie', name: 'Mollie', apiKey: 'mollie-api-key-abc' },
        { id: 'stripe', name: 'Stripe', apiKey: 'stripe-api-key-xyz' },
      ],
      batteryShippingRestrictionsEnabled: true,
      bulkyItemHandlingEnabled: true,
      highValueInsuranceRequired: true,
      dropShippingEnabled: false,
    });
  }

  getSecuritySettings() {
    return of<SecuritySettings>({
      allowPublicRegistration: true,
      requireEmailVerification: false,
      defaultUserRole: 'Customer',
      passwordPolicy: {
        minLength: 12,
        requireUppercase: true,
        requireLowercase: true,
        requireNumbers: true,
        requireSymbols: true,
      },
      adminIpAllowlist: '127.0.0.1, 192.168.1.1',
      adminSessionTimeoutMinutes: 30,
    });
  }

  getComplianceSettings() {
    return of<ComplianceSettings>({
      easaClassificationManagementEnabled: true,
      requireOperatorIdVisibility: true,
      geoAwarenessInfoEnabled: true,
      droneRegistrationRequired: true,
      ageVerificationEnabled: true,
      ageVerificationThreshold: 16,
      exportRestrictionsEnabled: false,
      itarDualUseFlagsEnabled: false,
      ceMarkingVerificationEnabled: true,
    });
  }

  getMarketingSettings() {
    return of<MarketingSettings>({
      googleAnalyticsId: 'UA-XXXXX-Y',
      googleTagManagerId: 'GTM-XXXXXX',
      defaultMetaTitle: 'Royal-Code Drone Shop: Jouw bestemming voor drones',
      defaultMetaDescription: 'Ontdek de nieuwste drones, accessoires en services bij Royal-Code Drone Shop.',
      globalMetaKeywords: 'drones, quadcopters, RC, FPV, accessoires, drone shop',
      sitemapAutoGenerate: true,
      socialMediaLinks: [
        { platform: 'Facebook', url: 'https://facebook.com/royal-code-drones' },
        { platform: 'Instagram', url: 'https://instagram.com/royal-code-drones' },
        { platform: 'YouTube', url: 'https://youtube.com/royal-code-drones' },
      ],
    });
  }

  getSystemSettings() {
    return of<SystemSettings>({
      globalLogLevel: 'Info',
      sentryDsn: 'https://examplepublickey@o0.ingest.sentry.io/0',
      frontendCacheClearButtonEnabled: true,
      backendCacheClearButtonEnabled: true,
      defaultCacheDurationMinutes: 60,
      apiHealthCheckEnabled: true,
      cronJobMonitoringEnabled: true,
    });
  }

  getAdminPanelSettings() {
    return of<AdminPanelSettings>({
      defaultTheme: 'dark',
      customBrandingEnabled: true,
      newOrderNotifications: { email: true, inApp: true },
      lowStockNotifications: { email: false, inApp: true },
      newReviewNotifications: { email: true, inApp: false },
    });
  }

  getGovernanceSettings() {
    return of<GovernanceSettings>({
      rbacEnabled: true,
      auditLoggingEnabled: true,
      highRiskApprovalWorkflowEnabled: true,
      adminIpRateLimitingEnabled: true,
    });
  }

  getDeploymentSettings() {
    return of<DeploymentSettings>({
      featureFlagsEnabled: true,
      configVersioningEnabled: true,
      stagingToProdMigrationWizardEnabled: false,
    });
  }
}
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/index.html ---
<!DOCTYPE html>
<html class="dark" lang="en" data-theme="dark" > <!-- Default theme -->
  <head>
    <meta charset="utf-8" />
    <title>drone-guru</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="/styles.css" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
  </head>
  <body class="bg-background text-primary">
    <admin-root></admin-root>
  </body>
</html>
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/main.ts ---
import { bootstrapApplication } from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent, appConfig).catch(err => console.error(err));
--- END OF FILE ---

--- START OF FILE apps/admin-panel/src/styles.scss ---
// apps/admin-panel/src/styles.scss
@import '../../../libs/shared/styles/src/lib/theme'; // Centrale theming voor admin panel

// Hier komen eventuele ADMIN-SPECIFIEKE stijlen.
// Bijvoorbeeld, om dark mode als default in te stellen voor de admin.
html.dark {
  --color-background: hsl(210deg 15% 7%); // Donkergrijs achtergrond voor admin
  --color-surface: hsl(210deg 15% 10%);
  --color-card: hsl(210deg 15% 11%);
  --color-border: hsl(210deg 15% 18%);
  --color-foreground: hsl(210deg 20% 93%);
  --color-primary: hsl(38deg 92% 48%); // Pas primary aan voor admin thema
  --color-primary-hover: hsl(38deg 92% 42%);
  --color-primary-on: hsl(38deg 92% 12%);
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-dashboard/core/src/index.ts ---
// Data Transfer Objects (DTOs)
export * from './lib/dto/backend.dto';

// Abstract Data Access Service
export * from './lib/data-access/abstract-admin-dashboard-api.service';

// State Management
export * from './lib/state/admin-dashboard.actions';
export * from './lib/state/admin-dashboard.facade';
export * from './lib/state/admin-dashboard.feature';
export * from './lib/state/admin-dashboard.providers';
export * from './lib/state/admin-dashboard.types';

export * from './lib/mappers/admin-dashboard-mapping.service';
--- END OF FILE ---

--- START OF FILE libs/features/admin-dashboard/core/src/lib/data-access/abstract-admin-dashboard-api.service.ts ---
/**
 * @file abstract-admin-dashboard-api.service.ts
 * @Version 1.3.0 (getRecentOrders Return Type Fix)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Defines the abstract contract for the Admin Dashboard API services.
 *              This serves as the Dependency Injection token and contract for
 *              specific application implementations. Uses correct DTO imports.
 *              `getRecentOrders` now returns `PaginatedList<AdminDashboardOrderListItem>`.
 */
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { PaginatedList } from '@royal-code/shared/utils';
// FIX: Importeer AdminDashboardOrderListItem uit onze domain library
import { AdminDashboardOrderListItem } from '@royal-code/features/admin-dashboard/domain';
// Importeer de Backend DTO's direct.
import {
  BackendAdminDashboardStatsDto,
  BackendAdminRevenueChartDto,
  BackendAdminBestsellerDto,
  ReviewListItemDto // <-- Gebruik de alias uit onze eigen dto folder
} from '../dto/backend.dto'; // <-- Correcte import van DTO's/aliassen uit dezelfde core/dto
import { ReviewFilters } from '@royal-code/features/reviews/domain'; // <-- ReviewFilters komt uit reviews/domain

/**
 * @abstract
 * @class AbstractAdminDashboardApiService
 * @description
 *   Defines the mandatory methods for fetching admin dashboard-specific data
 *   from the backend. This class acts as a dependency injection token, allowing
 *   different backend implementations to be swapped without changing the core
 *   logic that consumes this service.
 */
@Injectable({ providedIn: 'root' })
export abstract class AbstractAdminDashboardApiService {
  /**
   * @method getDashboardStats
   * @description Fetches key performance indicators (KPIs) and their comparison percentages.
   * @returns {Observable<BackendAdminDashboardStatsDto>} An observable that emits the dashboard statistics.
   */
  abstract getDashboardStats(): Observable<BackendAdminDashboardStatsDto>;

  /**
   * @method getRevenueChartData
   * @description Fetches time-series data for the revenue chart.
   * @param {number} [days=30] - The number of days back to retrieve data for.
   * @returns {Observable<BackendAdminRevenueChartDto>} An observable that emits the revenue chart data.
   */
  abstract getRevenueChartData(days?: number): Observable<BackendAdminRevenueChartDto>;

  /**
   * @method getBestsellers
   * @description Fetches a list of best-selling products.
   * @param {number} [limit=5] - The maximum number of bestsellers to return.
   * @returns {Observable<readonly BackendAdminBestsellerDto[]>} An observable that emits an array of best-selling product DTOs.
   */
  abstract getBestsellers(limit?: number): Observable<readonly BackendAdminBestsellerDto[]>;

  /**
   * @method getRecentOrders
   * @description Fetches a paginated list of recent orders for display on the dashboard.
   *              Delegates to AdminOrdersApiService.
   * @param {number} pageNumber - The page number (e.g., 1).
   * @param {number} pageSize - The number of items per page.
   * @param {string} sortBy - Field to sort by (e.g., 'orderDate').
   * @param {string} sortDirection - Sort direction ('asc' or 'desc').
   * @returns {Observable<PaginatedList<AdminDashboardOrderListItem>>} Observable emitting a paginated list of recent orders.
   */
  abstract getRecentOrders(pageNumber: number, pageSize: number, sortBy: string, sortDirection: string): Observable<PaginatedList<AdminDashboardOrderListItem>>;

  /**
   * @method getPendingReviews
   * @description Fetches a paginated list of reviews with 'Pending' status for moderation.
   *              Delegates to ReviewsApiService.
   * @param {number} pageNumber - The page number (e.g., 1).
   * @param {number} pageSize - The number of items per page.
   * @param {string} sortBy - Field to sort by (e.g., 'createdAt').
   * @param {string} status - Status to filter by (e.g., 'pending').
   * @returns {Observable<PaginatedList<ReviewListItemDto>>} Observable emitting a paginated list of pending reviews.
   */
  abstract getPendingReviews(pageNumber: number, pageSize: number, sortBy: string, status: string): Observable<PaginatedList<ReviewListItemDto>>;
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-dashboard/core/src/lib/dto/backend.dto.ts ---
/**
 * @file backend.dto.ts
 * @Version 1.1.0 (Crucial Type & Casing Fixes)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Defines the Data Transfer Object (DTO) contracts for the Admin Dashboard API backend.
 *              These interfaces directly mirror the expected JSON responses.
 *              Includes crucial type aliases for AdminOrderListItemDto and ReviewListItemDto
 *              to correctly represent the *mapped* domain types in the dashboard context.
 */

import { PaginatedList } from '@royal-code/shared/utils';
// FIX: Importeer de BackendAdminOrderListItemDto voor de *ruwe* API response
import { BackendAdminOrderListItemDto as RawBackendAdminOrderListItemDto } from '@royal-code/features/admin-orders/core';
// FIX: Importeer de ReviewListItemDto die al gemapt is in reviews/domain
import { ReviewListItemDto as MappedReviewListItemDto } from '@royal-code/features/reviews/domain';

// === Backend DTO's (ruw van de API) ===
export interface BackendKpiValueDto {
  readonly value: number;
  readonly changePercentage: number;
}

export interface BackendAdminDashboardStatsDto {
  readonly totalRevenue: BackendKpiValueDto;
  readonly totalSales: BackendKpiValueDto;
  readonly newCustomers: BackendKpiValueDto;
  readonly pendingReviewsCount: number;
}

export interface BackendRevenueDataPointDto {
  readonly date: string; // YYYY-MM-DD (ruwe string van backend)
  readonly revenue: number;
}

export interface BackendAdminRevenueChartDto {
  readonly period: string;
  readonly dataPoints: readonly BackendRevenueDataPointDto[];
}

export interface BackendAdminBestsellerDto {
  readonly productId: string;
  readonly productName: string;
  readonly sku: string;
  readonly unitsSold: number;
  readonly totalRevenue: number;
  readonly thumbnailUrl: string;
}

// === Type Aliases voor Frontend Gebruik in de Dashboard Context ===
// Deze aliassen vertegenwoordigen de types *na* initiële mapping door de respectievelijke services,
// en worden gebruikt in de NgRx State van de Admin Dashboard.

/**
 * @alias AdminOrderListItemDto
 * @description Vertegenwoordigt een Order List Item in de context van het dashboard,
 *              nadat het gemapt is door `AdminOrderMappingService`.
 *              Specifiek: `orderDate` is een `DateTimeInfo` object.
 */
export type AdminOrderListItemDto = RawBackendAdminOrderListItemDto & {
  orderDate: import('@royal-code/shared/base-models').DateTimeInfo; // Expliciet DateTimeInfo for orderDate
};

/**
 * @alias ReviewListItemDto
 * @description Vertegenwoordigt een Review List Item in de context van het dashboard,
 *              nadat het gemapt is door `ReviewsMappingService`.
 *              Deze komt direct overeen met `MappedReviewListItemDto` uit `reviews/domain`.
 */
export type ReviewListItemDto = MappedReviewListItemDto;
--- END OF FILE ---

--- START OF FILE libs/features/admin-dashboard/core/src/lib/mappers/admin-dashboard-mapping.service.ts ---
/**
 * @file admin-dashboard-mapping.service.ts
 * @Version 1.3.0 (Introduced Order to AdminDashboardListItem Mapper)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Service to map backend DTOs to frontend domain models for the Admin Dashboard.
 *              Includes a new mapper for Order to AdminDashboardOrderListItem.
 */
import { Injectable } from '@angular/core';
import {
  BackendAdminDashboardStatsDto,
  BackendAdminRevenueChartDto,
  BackendAdminBestsellerDto
} from '../dto/backend.dto';
import {
  DashboardStats,
  Kpi,
  RevenueChartData,
  Bestseller,
  RevenueDataPoint,
  AdminDashboardOrderListItem // <-- Nieuwe import
} from '@royal-code/features/admin-dashboard/domain';
import { DateTimeUtil } from '@royal-code/shared/utils';
import { Order } from '@royal-code/features/orders/domain'; // Importeer volledig Order object

@Injectable({ providedIn: 'root' })
export class AdminDashboardMappingService {

  public mapStats(dto: BackendAdminDashboardStatsDto): DashboardStats {
    const mapKpi = (kpiDto: { value: number, changePercentage: number }): Kpi => ({
      value: kpiDto.value,
      changePercentage: Math.abs(kpiDto.changePercentage),
      trendDirection: kpiDto.changePercentage > 0 ? 'up' : kpiDto.changePercentage < 0 ? 'down' : 'neutral'
    });

    return {
      totalRevenue: mapKpi(dto.totalRevenue),
      totalSales: mapKpi(dto.totalSales),
      newCustomers: mapKpi(dto.newCustomers),
      pendingReviewsCount: dto.pendingReviewsCount,
    };
  }

  public mapRevenueChart(dto: BackendAdminRevenueChartDto): RevenueChartData {
    return {
      period: dto.period,
      dataPoints: dto.dataPoints.map((dp): RevenueDataPoint => ({
        date: new Date(dp.date),
        revenue: dp.revenue,
      })),
    };
  }

  public mapBestsellers(dto: readonly BackendAdminBestsellerDto[]): readonly Bestseller[] {
    return dto as readonly Bestseller[];
  }

  /**
   * @method mapOrderToAdminDashboardListItem
   * @description Converteert een volledig `Order` domain model naar een lichtgewicht `AdminDashboardOrderListItem`.
   * @param {Order} order - Het volledige Order domain model.
   * @returns {AdminDashboardOrderListItem} Het lichtgewicht dashboard orderlijst item.
   */
  public mapOrderToAdminDashboardListItem(order: Order): AdminDashboardOrderListItem {
    return {
      id: order.id,
      orderNumber: order.orderNumber,
      customerName: order.customerName,
      grandTotal: order.grandTotal,
      currency: order.currency,
      status: order.status,
      orderDate: order.orderDate, // Dit is al DateTimeInfo
      productThumbnails: order.productThumbnails,
      paymentStatus: order.paymentDetails?.paymentStatus || 'unknown',
      hasCustomerNotes: !!order.customerNotes,
      shippingMethodName: order.shippingDetails?.methodName || 'N/A',
    };
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-dashboard/core/src/lib/state/admin-dashboard.actions.ts ---
/**
 * @file admin-dashboard.actions.ts
 * @Version 1.2.0 (Corrected Imports for Types)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description NgRx actions for the Admin Dashboard feature.
 *              Corrected imports for DTOs and Domain Models.
 */
import { createActionGroup, emptyProps, props } from '@ngrx/store';
import { StructuredError } from '@royal-code/shared/domain';
import { PaginatedList } from '@royal-code/shared/utils';

// FIX: Importeer AdminOrderListItemDto en ReviewListItemDto uit onze eigen dto-map
import { AdminOrderListItemDto, ReviewListItemDto } from '../dto/backend.dto'; // <-- Correcte import

// Importeer de Domain Models uit de domain library
import { DashboardStats, RevenueChartData, Bestseller, AdminDashboardOrderListItem } from '@royal-code/features/admin-dashboard/domain';

export const AdminDashboardActions = createActionGroup({
  source: 'Admin Dashboard',
  events: {
    // --- Lifecycle ---
    'Page Initialized': emptyProps(),

    // --- Stats Loading ---
    'Load Stats Requested': emptyProps(),
    'Load Stats Success': props<{ stats: DashboardStats }>(), // Gebruikt Domain Model
    'Load Stats Failure': props<{ error: StructuredError }>(),

    // --- Revenue Chart Loading ---
    'Load Revenue Chart Requested': props<{ days: number }>(),
    'Load Revenue Chart Success': props<{ chartData: RevenueChartData }>(), // Gebruikt Domain Model
    'Load Revenue Chart Failure': props<{ error: StructuredError }>(),

    // --- Bestsellers Loading ---
    'Load Bestsellers Requested': props<{ limit: number }>(),
    'Load Bestsellers Success': props<{ bestsellers: readonly Bestseller[] }>(), // Gebruikt Domain Model
    'Load Bestsellers Failure': props<{ error: StructuredError }>(),

    // --- Recent Orders Loading ---
    'Load Recent Orders Requested': emptyProps(),
    'Load Recent Orders Success': props<{ orders: PaginatedList<AdminDashboardOrderListItem> }>(), 
    'Load Recent Orders Failure': props<{ error: StructuredError }>(),

    // --- Pending Reviews Loading ---
    'Load Pending Reviews Requested': emptyProps(),
    'Load Pending Reviews Success': props<{ reviews: PaginatedList<ReviewListItemDto> }>(),
    'Load Pending Reviews Failure': props<{ error: StructuredError }>(),

    // --- UI Actions ---
    'Clear Error': emptyProps(),
  },
});
--- END OF FILE ---

--- START OF FILE libs/features/admin-dashboard/core/src/lib/state/admin-dashboard.effects.ts ---
/**
 * @file admin-dashboard.effects.ts
 * @Version 1.2.0 (Mapped & Enterprise Ready with Error Handling)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description NgRx effects for the Admin Dashboard, now using the mapping service
 *              to convert DTOs to domain models before dispatching success actions.
 *              Also uses structured error handling.
 */
import { Injectable, inject } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { of } from 'rxjs';
import { catchError, map, switchMap } from 'rxjs/operators';
import { AdminDashboardActions } from './admin-dashboard.actions';
import { AbstractAdminDashboardApiService } from '../data-access/abstract-admin-dashboard-api.service';
import { AdminDashboardMappingService } from '../mappers/admin-dashboard-mapping.service'; // <-- MAPPER
import { StructuredError } from '@royal-code/shared/domain';
import { HttpErrorResponse } from '@angular/common/http';
import { ErrorActions } from '@royal-code/store/error'; // Global Error Actions
import { Store } from '@ngrx/store'; // Voor dispatching globale error

@Injectable()
export class AdminDashboardEffects {
  private readonly actions$ = inject(Actions);
  private readonly apiService = inject(AbstractAdminDashboardApiService);
  private readonly mapper = inject(AdminDashboardMappingService); // <-- MAPPER INJECTIE
  private readonly store = inject(Store); // Voor globale error dispatch

  // === Orchestrator Effect ===
  init$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminDashboardActions.pageInitialized),
      switchMap(() => [
        AdminDashboardActions.loadStatsRequested(),
        AdminDashboardActions.loadRevenueChartRequested({ days: 30 }),
        AdminDashboardActions.loadBestsellersRequested({ limit: 5 }),
        AdminDashboardActions.loadRecentOrdersRequested(),
        AdminDashboardActions.loadPendingReviewsRequested(),
      ])
    )
  );

  // === Individual Data Loading Effects ===

  loadStats$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminDashboardActions.loadStatsRequested),
      switchMap(() =>
        this.apiService.getDashboardStats().pipe(
          map(dto => AdminDashboardActions.loadStatsSuccess({ stats: this.mapper.mapStats(dto) })),
          catchError(error => {
            const structuredError = this.formatError(error, 'LoadStats');
            this.store.dispatch(ErrorActions.reportError({ error: structuredError })); // Rapportage
            return of(AdminDashboardActions.loadStatsFailure({ error: structuredError }));
          })
        )
      )
    )
  );

  loadRevenueChart$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminDashboardActions.loadRevenueChartRequested),
      switchMap(({ days }) =>
        this.apiService.getRevenueChartData(days).pipe(
          map(dto => AdminDashboardActions.loadRevenueChartSuccess({ chartData: this.mapper.mapRevenueChart(dto) })),
          catchError(error => {
            const structuredError = this.formatError(error, 'LoadRevenueChart');
            this.store.dispatch(ErrorActions.reportError({ error: structuredError })); // Rapportage
            return of(AdminDashboardActions.loadRevenueChartFailure({ error: structuredError }));
          })
        )
      )
    )
  );

  loadBestsellers$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminDashboardActions.loadBestsellersRequested),
      switchMap(({ limit }) =>
        this.apiService.getBestsellers(limit).pipe(
          map(dto => AdminDashboardActions.loadBestsellersSuccess({ bestsellers: this.mapper.mapBestsellers(dto) })),
          catchError(error => {
            const structuredError = this.formatError(error, 'LoadBestsellers');
            this.store.dispatch(ErrorActions.reportError({ error: structuredError })); // Rapportage
            return of(AdminDashboardActions.loadBestsellersFailure({ error: structuredError }));
          })
        )
      )
    )
  );

  loadRecentOrders$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminDashboardActions.loadRecentOrdersRequested),
      switchMap(() =>
        // De apiService retourneert nu PaginatedList<AdminDashboardOrderListItem>
        this.apiService.getRecentOrders(1, 5, 'orderDate', 'desc').pipe(
          map(orders => AdminDashboardActions.loadRecentOrdersSuccess({ orders })),
          catchError(error => {
            const structuredError = this.formatError(error, 'LoadRecentOrders');
            this.store.dispatch(ErrorActions.reportError({ error: structuredError }));
            return of(AdminDashboardActions.loadRecentOrdersFailure({ error: structuredError }));
          })
        )
      )
    )
  );



  loadPendingReviews$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminDashboardActions.loadPendingReviewsRequested),
      switchMap(() =>
        this.apiService.getPendingReviews(1, 3, 'createdAt', 'pending').pipe( // Sorteer op 'createdAt', status 'pending'
          map(reviews => AdminDashboardActions.loadPendingReviewsSuccess({ reviews })), // DTO is al gemapt/bruikbaar
          catchError(error => {
            const structuredError = this.formatError(error, 'LoadPendingReviews');
            this.store.dispatch(ErrorActions.reportError({ error: structuredError })); // Rapportage
            return of(AdminDashboardActions.loadPendingReviewsFailure({ error: structuredError }));
          })
        )
      )
    )
  );

  // === Utility Functions ===
  private formatError(error: unknown, operation: string): StructuredError {
    const httpError = error as HttpErrorResponse;
    const baseMessage = `Failed to ${operation}.`;
    const details = httpError?.error?.message || httpError?.message || 'An unknown error occurred.';

    return {
      message: `${baseMessage} ${details}`,
      code: `DASHBOARD_${operation.toUpperCase()}_FAILURE`,
      context: {
        status: httpError?.status,
        url: httpError?.url,
        fullError: httpError // Voeg de volledige HttpErrorResponse toe voor gedetailleerde logging
      },
      timestamp: Date.now(),
      severity: 'error'
    };
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-dashboard/core/src/lib/state/admin-dashboard.facade.ts ---
/**
 * @file admin-dashboard.facade.ts
 * @Version 1.1.0 (Domain Model Aligned)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Public API for the Admin Dashboard feature state, now using clean domain models.
 */
import { Injectable, Signal, inject } from '@angular/core';
import { Store } from '@ngrx/store';
import { AdminDashboardActions } from './admin-dashboard.actions';
import { selectViewModel } from './admin-dashboard.feature';
import { AdminDashboardViewModel } from './admin-dashboard.types';

// Import de Domain Models, niet de DTOs voor de initialViewModel
import { DashboardStats, RevenueChartData, Bestseller } from '@royal-code/features/admin-dashboard/domain';
import { AdminOrderListItemDto } from '../dto/backend.dto'; // Type alias
import { ReviewListItemDto } from '@royal-code/features/reviews/domain';
import { StructuredError } from '@royal-code/shared/domain';
import { toSignal } from '@angular/core/rxjs-interop';

@Injectable({ providedIn: 'root' })
export class AdminDashboardFacade {
  private readonly store = inject(Store);

  // === Primary ViewModel (for UI consumption) ===
  private readonly initialViewModel: AdminDashboardViewModel = {
    stats: null,
    revenueChartData: null,
    bestsellers: [],
    recentOrders: [],
    pendingReviews: [],
    isLoading: true, // Initieel laden
    error: null,
  };

  /**
   * The main ViewModel signal containing all data and states for the dashboard UI.
   */
  public readonly viewModel: Signal<AdminDashboardViewModel> = toSignal(
    this.store.select(selectViewModel),
    { initialValue: this.initialViewModel }
  );

  // === Action Dispatchers ===

  /**
   * Initializes the dashboard by dispatching the action to load all necessary data.
   * This should be called when the dashboard page component is initialized.
   */
  public init(): void {
    this.store.dispatch(AdminDashboardActions.pageInitialized());
  }

  /**
   * Clears any existing error messages from the state.
   */
  public clearError(): void {
    this.store.dispatch(AdminDashboardActions.clearError());
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-dashboard/core/src/lib/state/admin-dashboard.feature.ts ---
/**
 * @file admin-dashboard.feature.ts
 * @Version 2.0.0 (Definitive createFeature Refactor)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description The main NgRx feature definition for the Admin Dashboard.
 *              Refactored to define the ViewModel selector outside of createFeature
 *              to prevent all 'implicitly has an any type' errors.
 */
import { createFeature, createReducer, on, createSelector } from '@ngrx/store';
import { initialAdminDashboardState } from './admin-dashboard.state'; // FIX: Correcte import
import { AdminDashboardActions } from './admin-dashboard.actions';
import { AdminDashboardViewModel } from './admin-dashboard.types';

export const ADMIN_DASHBOARD_FEATURE_KEY = 'adminDashboard';

export const adminDashboardFeature = createFeature({
  name: ADMIN_DASHBOARD_FEATURE_KEY,
  reducer: createReducer(
    initialAdminDashboardState,
    on(AdminDashboardActions.pageInitialized, (state) => ({
      ...state,
      isLoadingStats: true,
      isLoadingChart: true,
      isLoadingBestsellers: true,
      isLoadingRecentOrders: true,
      isLoadingPendingReviews: true,
      error: null,
    })),
    on(AdminDashboardActions.loadStatsSuccess, (state, { stats }) => ({ ...state, stats, isLoadingStats: false })),
    on(AdminDashboardActions.loadStatsFailure, (state, { error }) => ({ ...state, isLoadingStats: false, error })),
    on(AdminDashboardActions.loadRevenueChartSuccess, (state, { chartData }) => ({ ...state, revenueChartData: chartData, isLoadingChart: false })),
    on(AdminDashboardActions.loadRevenueChartFailure, (state, { error }) => ({ ...state, isLoadingChart: false, error })),
    on(AdminDashboardActions.loadBestsellersSuccess, (state, { bestsellers }) => ({ ...state, bestsellers, isLoadingBestsellers: false })),
    on(AdminDashboardActions.loadBestsellersFailure, (state, { error }) => ({ ...state, isLoadingBestsellers: false, error })),
    on(AdminDashboardActions.loadRecentOrdersSuccess, (state, { orders }) => ({ ...state, recentOrders: orders.items, isLoadingRecentOrders: false })),
    on(AdminDashboardActions.loadRecentOrdersFailure, (state, { error }) => ({ ...state, isLoadingRecentOrders: false, error })),
    on(AdminDashboardActions.loadPendingReviewsSuccess, (state, { reviews }) => ({ ...state, pendingReviews: reviews.items, isLoadingPendingReviews: false })),
    on(AdminDashboardActions.loadPendingReviewsFailure, (state, { error }) => ({ ...state, isLoadingPendingReviews: false, error })),
    on(AdminDashboardActions.clearError, (state) => ({ ...state, error: null }))
  )
});

// === EXPORTED SELECTORS (DEFINITIEVE FIX) ===

// 1. Exporteer de basis selectors die `createFeature` genereert.
export const {
  name,
  reducer,
  selectAdminDashboardState,
  selectStats,
  selectRevenueChartData,
  selectBestsellers,
  selectRecentOrders,
  selectPendingReviews,
  selectIsLoadingStats,
  selectIsLoadingChart,
  selectIsLoadingBestsellers,
  selectIsLoadingRecentOrders,
  selectIsLoadingPendingReviews,
  selectError,
} = adminDashboardFeature;

// 2. Creëer de gecombineerde selectors buiten de `createFeature` call.
export const selectIsLoading = createSelector(
  selectIsLoadingStats,
  selectIsLoadingChart,
  selectIsLoadingBestsellers,
  selectIsLoadingRecentOrders,
  selectIsLoadingPendingReviews,
  (stats, chart, bestsellers, orders, reviews) => stats || chart || bestsellers || orders || reviews
);

export const selectViewModel = createSelector(
  selectStats,
  selectRevenueChartData,
  selectBestsellers,
  selectRecentOrders,
  selectPendingReviews,
  selectIsLoading,
  selectError,
  (stats, revenueChartData, bestsellers, recentOrders, pendingReviews, isLoading, error): AdminDashboardViewModel => ({
    stats,
    revenueChartData,
    bestsellers,
    recentOrders,
    pendingReviews,
    isLoading,
    error,
  })
);
--- END OF FILE ---

--- START OF FILE libs/features/admin-dashboard/core/src/lib/state/admin-dashboard.providers.ts ---
/**
 * @file admin-dashboard.providers.ts
 * @Version 2.0.0 (Type Safe, Consolidated State & Reducer)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description
 *   Provides de NgRx state en effects voor de Admin Dashboard feature
 *   met de moderne, vereenvoudigde `createFeature` aanpak.
 */
import { EnvironmentProviders, makeEnvironmentProviders } from '@angular/core';
import { provideState } from '@ngrx/store';
import { provideEffects } from '@ngrx/effects';
import { adminDashboardFeature } from './admin-dashboard.feature';
import { AdminDashboardEffects } from './admin-dashboard.effects';

/**
 * @description Provides the admin dashboard feature state and effects to the application.
 * @returns {EnvironmentProviders}
 */
export function provideAdminDashboardFeature(): EnvironmentProviders {
  return makeEnvironmentProviders([
    // DE FIX: adminDashboardFeature is nu een geldig FeatureSlice object.
    provideState(adminDashboardFeature),
    provideEffects([AdminDashboardEffects]),
  ]);
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-dashboard/core/src/lib/state/admin-dashboard.state.ts ---
/**
 * @file admin-dashboard.state.ts
 * @Version 1.3.0 (Definitive Export)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Defines the state interface and initial state for the Admin Dashboard feature.
 *              Ensures `initialAdminDashboardState` is correctly exported.
 */
import { StructuredError } from '@royal-code/shared/domain';
import { AdminDashboardOrderListItem } from '@royal-code/features/admin-dashboard/domain';
import { ReviewListItemDto } from '@royal-code/features/reviews/domain';
import { DashboardStats, RevenueChartData, Bestseller } from '@royal-code/features/admin-dashboard/domain';

export interface AdminDashboardState {
  stats: DashboardStats | null;
  revenueChartData: RevenueChartData | null;
  bestsellers: readonly Bestseller[];
  recentOrders: readonly AdminDashboardOrderListItem[];
  pendingReviews: readonly ReviewListItemDto[];
  isLoadingStats: boolean;
  isLoadingChart: boolean;
  isLoadingBestsellers: boolean;
  isLoadingRecentOrders: boolean;
  isLoadingPendingReviews: boolean;
  error: StructuredError | null;
}

// FIX: Zorg ervoor dat deze variabele geëxporteerd wordt.
export const initialAdminDashboardState: AdminDashboardState = {
  stats: null,
  revenueChartData: null,
  bestsellers: [],
  recentOrders: [],
  pendingReviews: [],
  isLoadingStats: false,
  isLoadingChart: false,
  isLoadingBestsellers: false,
  isLoadingRecentOrders: false,
  isLoadingPendingReviews: false,
  error: null,
};
--- END OF FILE ---

--- START OF FILE libs/features/admin-dashboard/core/src/lib/state/admin-dashboard.types.ts ---
/**
 * @file admin-dashboard.types.ts
 * @Version 1.1.0 (Domain Model Aligned)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Defines the ViewModel type for the Admin Dashboard feature, now using
 *              clean domain models.
 */
import { AdminDashboardState } from './admin-dashboard.state';
// Importeer de Domain Models, niet de DTOs.
import { DashboardStats, RevenueChartData, Bestseller, AdminDashboardOrderListItem } from '@royal-code/features/admin-dashboard/domain';
import { AdminOrderListItemDto } from '../dto/backend.dto'; // AdminOrderListItemDto is hier een type alias voor BackendAdminOrderListItemDto
import { ReviewListItemDto } from '@royal-code/features/reviews/domain';
import { StructuredError } from '@royal-code/shared/domain';

export interface AdminDashboardViewModel {
  stats: DashboardStats | null;
  revenueChartData: RevenueChartData | null;
  bestsellers: readonly Bestseller[];
  recentOrders: readonly AdminDashboardOrderListItem[];
  pendingReviews: readonly ReviewListItemDto[];
  isLoading: boolean;
  error: StructuredError | null;
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-dashboard/data-access/src/index.ts ---
export * from './lib/services/plushie-admin-dashboard-api.service';
--- END OF FILE ---

--- START OF FILE libs/features/admin-dashboard/data-access/src/lib/services/plushie-admin-dashboard-api.service.ts ---
/**
 * @file plushie-admin-dashboard-api.service.ts
 * @Version 1.9.0 (Definitive - All Type, Import & Mapping Issues Resolved)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Definitive concrete implementation for the Admin Dashboard API.
 */
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable, map } from 'rxjs';
import { APP_CONFIG } from '@royal-code/core/config';
import {
  AbstractAdminDashboardApiService,
  BackendAdminDashboardStatsDto,
  BackendAdminRevenueChartDto,
  BackendAdminBestsellerDto,
  AdminDashboardMappingService
} from '@royal-code/features/admin-dashboard/core';
import { PaginatedList } from '@royal-code/shared/utils';

// FIX: Importeer OrderFilters en Order direct vanuit de bron in 'orders/domain'
import { OrderFilters, Order } from '@royal-code/features/orders/domain';
import { AbstractAdminOrderApiService } from '@royal-code/features/admin-orders/core';
import { ReviewListItemDto, ReviewFilters, ReviewStatus, ReviewTargetEntityType } from '@royal-code/features/reviews/domain';
import { ReviewsMappingService, AbstractReviewsApiService } from '@royal-code/features/reviews/core';
import { AdminDashboardOrderListItem } from '@royal-code/features/admin-dashboard/domain';

@Injectable({ providedIn: 'root' })
export class PlushieAdminDashboardApiService implements AbstractAdminDashboardApiService {
  private readonly http = inject(HttpClient);
  private readonly config = inject(APP_CONFIG);
  private readonly adminDashboardApiUrl = `${this.config.backendUrl}/AdminDashboard`;
  private readonly adminOrdersApiService = inject(AbstractAdminOrderApiService);
  private readonly reviewsApiService = inject(AbstractReviewsApiService);
  private readonly dashboardMapper = inject(AdminDashboardMappingService);

  getDashboardStats(): Observable<BackendAdminDashboardStatsDto> {
    return this.http.get<BackendAdminDashboardStatsDto>(`${this.adminDashboardApiUrl}/stats`);
  }

  getRevenueChartData(days?: number): Observable<BackendAdminRevenueChartDto> {
    let params = new HttpParams();
    if (days !== undefined) {
      params = params.set('days', days.toString());
    }
    return this.http.get<BackendAdminRevenueChartDto>(`${this.adminDashboardApiUrl}/revenue-chart`, { params });
  }

  getBestsellers(limit?: number): Observable<readonly BackendAdminBestsellerDto[]> {
    let params = new HttpParams();
    if (limit !== undefined) {
      params = params.set('limit', limit.toString());
    }
    return this.http.get<readonly BackendAdminBestsellerDto[]>(`${this.adminDashboardApiUrl}/bestsellers`, { params });
  }

  getRecentOrders(pageNumber: number, pageSize: number, sortBy: string, sortDirection: string): Observable<PaginatedList<AdminDashboardOrderListItem>> {
    const filters: Partial<OrderFilters> = {
      page: pageNumber,
      pageSize: pageSize,
      sortBy: sortBy, // FIX: Dit zou nu moeten werken met de correcte import
      sortDirection: sortDirection,
    };

    return this.adminOrdersApiService.getOrders(filters).pipe(
      map(paginatedOrderList => ({
        ...paginatedOrderList,
        items: paginatedOrderList.items.map(order => this.dashboardMapper.mapOrderToAdminDashboardListItem(order as Order)) // FIX: Cast 'order' naar 'Order'
      }))
    );
  }

  getPendingReviews(pageNumber: number, pageSize: number, sortBy: string, status: string): Observable<PaginatedList<ReviewListItemDto>> {
    const filters: ReviewFilters = {
      pageNumber: pageNumber,
      pageSize: pageSize,
      sortBy: sortBy as any,
      status: status as ReviewStatus,
    };
    return this.reviewsApiService.getMyReviews(filters);
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-dashboard/domain/src/index.ts ---
export * from './lib/models/admin-dashboard.models';
--- END OF FILE ---

--- START OF FILE libs/features/admin-dashboard/domain/src/lib/models/admin-dashboard.models.ts ---
/**
 * @file admin-dashboard.models.ts
 * @Version 1.2.0 (Introduced AdminDashboardOrderListItem)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Defines the frontend domain models for the Admin Dashboard feature.
 *              These models are clean, UI-focused representations of the backend data.
 *              Introduces a specific model for order list items on the dashboard.
 */
import type { ReviewListItemDto } from '@royal-code/features/reviews/domain'; // Importeer als type
import { DateTimeInfo } from '@royal-code/shared/base-models'; // Importeer DateTimeInfo

// Specifieke Domain Model voor een Order ListItem op het Dashboard
export interface AdminDashboardOrderListItem {
  readonly id: string;
  readonly orderNumber: string;
  readonly customerName: string;
  readonly grandTotal: number;
  readonly currency: string;
  readonly status: string; // Hier is het nog een string, de pipe converteert het later
  readonly orderDate: DateTimeInfo; // Gemapt Date
  readonly productThumbnails: readonly string[];
  readonly paymentStatus: string;
  readonly hasCustomerNotes: boolean;
  readonly shippingMethodName: string; // Specifiek veld voor de UI
}


export interface Kpi {
  value: number; // <<< AANGEPAST
  changePercentage: number; // <<< AANGEPAST
  trendDirection: 'up' | 'down' | 'neutral';
}

export interface DashboardStats {
  totalRevenue: Kpi;
  totalSales: Kpi;
  newCustomers: Kpi;
  pendingReviewsCount: number;
}

export interface RevenueDataPoint {
  date: Date; // Gebruik een echt Date object in het domain model
  revenue: number;
}

export interface RevenueChartData {
  period: string;
  dataPoints: readonly RevenueDataPoint[];
}

export interface Bestseller {
  productId: string;
  productName: string;
  sku: string;
  unitsSold: number;
  totalRevenue: number;
  thumbnailUrl: string;
}

// FIX: Exporteer als type om TS1205 te vermijden.
export type { ReviewListItemDto };
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/core/src/index.ts ---
// DTOs
export * from './lib/DTOs/backend.dto';

// Data Access
export * from './lib/data-access/abstract-admin-order-api.service';

// Mappers
export * from './lib/mappers/admin-order-mapping.service';

// State Management
export * from './lib/state/admin-orders.actions';
export * from './lib/state/admin-orders.effects';
export * from './lib/state/admin-orders.facade';
export * from './lib/state/admin-orders.feature';

// Providers
export * from './lib/admin-orders.providers';
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/core/src/lib/admin-orders.providers.ts ---
/**
 * @file admin-orders.providers.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-22
 * @Description Provides NgRx feature state and effects for Admin Orders.
 * @GeneratedBy Royal-Code MonorepoAppDevAI
 * @GeneratedDate 2025-07-22
 * @PromptSummary "Yes lets go! (start state management)"
 */
import { EnvironmentProviders, makeEnvironmentProviders } from '@angular/core';
import { provideState } from '@ngrx/store';
import { provideEffects } from '@ngrx/effects';
import { adminOrdersFeature } from './state/admin-orders.feature';
import { AdminOrdersEffects } from './state/admin-orders.effects';
import { AdminOrderApiService } from '@royal-code/features/admin-orders/data-access';
import { AbstractAdminOrderApiService } from './data-access/abstract-admin-order-api.service';

export function provideAdminOrdersFeature(): EnvironmentProviders {
  return makeEnvironmentProviders([
    provideState(adminOrdersFeature),
    provideEffects(AdminOrdersEffects),
    { provide: AbstractAdminOrderApiService, useClass: AdminOrderApiService }
  ]);
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/core/src/lib/data-access/abstract-admin-order-api.service.ts ---
/**
 * @file abstract-admin-order-api.service.ts
 * @version 4.0.0 (Removed PickPack Overload & Correct Return Type)
 * @description Abstract contract voor de AdminOrders API‑calls. Nu zonder de 'pickpack' overload.
 *              De `getOrderById` methode retourneert nu altijd een `BackendAdminOrderDetailDto`.
 */
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { Order, OrderFilters } from '@royal-code/features/orders/domain';
import {
  BackendAdminOrderDetailDto,
  BackendAdminOrderPickPackDto, // Behoud import for DTO, maar niet voor overload/return type van getOrderById
  BackendAdminOrderStatsDto,
  BackendAdminLookupsDto,
  UpdateOrderStatusPayloadDto,
  UpdateOrderNotesPayloadDto,
  RefundOrderPayloadDto,
  CreateFulfillmentPayloadDto,
  UpdateCustomerNotesPayloadDto,
  AddOrderItemPayloadDto,
  UpdateOrderItemQuantityPayloadDto
} from '../DTOs/backend.dto';
import { Address } from '@royal-code/shared/domain';
import { PaginatedList } from '@royal-code/shared/utils';

@Injectable({ providedIn: 'root' })
export abstract class AbstractAdminOrderApiService {

  // --- LEZEN ---
  abstract getOrders(filters: Partial<OrderFilters>): Observable<PaginatedList<Order>>;
  // << DE FIX: Retourneert nu altijd BackendAdminOrderDetailDto >>
  abstract getOrderById(orderId: string): Observable<BackendAdminOrderDetailDto>;
  abstract getOrderById(orderId: string, view: 'pickpack'): Observable<BackendAdminOrderPickPackDto>; // << Overload voor de specifieke view blijft voor API contract, maar wordt niet gebruikt door de effecten
  abstract getOrderById(orderId: string, view?: 'pickpack'): Observable<BackendAdminOrderDetailDto | BackendAdminOrderPickPackDto>;


  abstract getStats(dateFrom?: string, dateTo?: string): Observable<BackendAdminOrderStatsDto>;
  abstract getLookups(): Observable<BackendAdminLookupsDto>;

  // --- MUTATIES ---
  abstract updateStatus(orderId: string, payload: UpdateOrderStatusPayloadDto):
    Observable<BackendAdminOrderDetailDto>;
  abstract updateInternalNotes(orderId: string, payload: UpdateOrderNotesPayloadDto):
    Observable<BackendAdminOrderDetailDto>;
  abstract updateCustomerNotes(orderId: string, payload: UpdateCustomerNotesPayloadDto):
    Observable<BackendAdminOrderDetailDto>;
  abstract updateShippingAddress(orderId: string, payload: Address):
    Observable<BackendAdminOrderDetailDto>;
  abstract updateBillingAddress(orderId: string, payload: Address):
    Observable<BackendAdminOrderDetailDto>;
  abstract updateOrderItemQuantity(orderItemId: string, payload: UpdateOrderItemQuantityPayloadDto):
    Observable<BackendAdminOrderDetailDto>;

  // --- AANMAKEN / VERWIJDEREN ---
  abstract createFulfillment(orderId: string, payload: CreateFulfillmentPayloadDto):
    Observable<BackendAdminOrderDetailDto>;
  abstract addItemToOrder(orderId: string, payload: AddOrderItemPayloadDto):
    Observable<BackendAdminOrderDetailDto>;
  abstract removeOrderItem(orderItemId: string):
    Observable<BackendAdminOrderDetailDto>;

  // --- OVERIG ---
  abstract cancelOrder(orderId: string): Observable<BackendAdminOrderDetailDto>;
  abstract refundOrder(orderId: string, payload: RefundOrderPayloadDto):
    Observable<BackendAdminOrderDetailDto>;

  // --- DOCUMENTEN ---
  abstract exportOrders(filters: Partial<OrderFilters>): Observable<Blob>;
  abstract downloadInvoice(orderId: string): Observable<Blob>;
  abstract downloadPackingSlip(orderId: string): Observable<Blob>;
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/core/src/lib/DTOs/backend.dto.ts ---
// --- BACKEND DTO CONTRACTS ---
import { OrderStatus } from '@royal-code/features/orders/domain';
import { ProductType } from '@royal-code/features/products/domain';
import { PaginatedList } from '@royal-code/shared/utils';
import { Address } from '@royal-code/shared/domain';

/* LIST & LOOKUPS */
export type BackendPaginatedOrderListDto = PaginatedList<BackendAdminOrderListItemDto>;

export interface BackendAdminOrderListItemDto {
  readonly id: string;
  readonly orderNumber: string;
  readonly orderDate: string; // ISO string
  readonly status: string; // camelCase string, bijv. 'shipped'
  readonly paymentStatus: string;
  readonly grandTotal: number;
  readonly currency: string;
  readonly totalItems: number;
  readonly customerName: string;
  readonly customerEmail: string;
  readonly hasCustomerNotes: boolean;
  readonly shippingSummary: { countryCode: string; methodName: string; trackingNumber: string | null; };
  readonly productThumbnails: readonly string[]; // Array van URL's
}

export interface BackendAdminOrderStatsDto {
  readonly totalRevenue: number;
  readonly totalOrders: number;
  readonly averageOrderValue: number;
  readonly ordersAwaitingFulfillment: number;
  readonly newOrdersToday: number;
  readonly revenueToday: number;
}
export interface BackendAdminLookupsDto {
  readonly orderStatuses: readonly string[];
  readonly paymentMethods: readonly string[];
  readonly shippingMethods: readonly string[];
}

/* DETAIL */
export interface BackendAdminOrderDetailDto {
  readonly id: string; 
  readonly orderNumber: string;
  readonly orderDate: string;
  readonly status: string;
  readonly customer: { userId: string; name: string; email: string };
  readonly financialSummary: {
    subTotal: number; shippingCost: number; taxAmount: number; discountAmount: number;
    grandTotal: number; currency: string;
  };
  readonly shippingAddress: Address;
  readonly billingAddress: Address;
  readonly paymentDetails?: { methodFriendlyName: string; gatewayTransactionId?: string; paymentStatus: string; };
  readonly items: readonly BackendOrderItemDto[];
  readonly customerNotes?: string;
  readonly internalNotes: readonly BackendInternalNoteDto[];
  readonly fulfillments: readonly BackendFulfillmentDto[];
  readonly history: readonly BackendHistoryEventDto[];
  readonly refunds: readonly BackendRefundDto[];
}

/* PICK‑PACK */
export interface BackendAdminOrderPickPackDto {
  readonly orderId: string;
  readonly shippingAddress: Address;
  readonly customerNotes?: string;
  readonly items: readonly {
    orderItemId: string; sku?: string; productName: string; variantInfo?: Record<string,string>; quantity: number; productImageUrl?: string;
  }[];
  readonly fulfillment?: { carrierName?: string; trackingNumber?: string; trackingUrl?: string; };
}

/* sub‑DTOs */
export interface BackendVariantDisplayInfoDto {
  readonly attributeType: string;
  readonly displayName: string;
  readonly value: string;
  readonly colorHex: string | null;
}

export interface BackendOrderItemDto {
  readonly id: string; readonly productId: string; readonly productVariantId?: string;
  readonly productName: string; readonly sku?: string; readonly productType: ProductType;
  readonly quantity: number; readonly pricePerItem: number; readonly lineTotal: number;
  readonly taxAmount: number; readonly discountAmount: number;
  readonly variantInfo?: readonly BackendVariantDisplayInfoDto[]; // Aangepast naar array van objecten
  readonly productImageUrl?: string;
}


export interface BackendInternalNoteDto { id: string; createdAt: string; authorName: string; text: string; }
export interface BackendFulfillmentDto {
  fulfillmentId: string; createdAt: string; status: string;
  carrierName?: string; trackingNumber?: string; trackingUrl?: string;
  shippedDate?: string; estimatedDeliveryDate?: string;
  items: readonly { orderItemId: string; quantity: number }[];
}
export interface BackendHistoryEventDto { timestamp: string; eventType: string; author: string; description: string; }
export interface BackendRefundDto { refundId: string; amount: number; reason: string; refundedAt: string; processedBy: string; gatewayRefundId?: string; }

/* PAYLOADS */
export interface UpdateOrderStatusPayloadDto { newStatus: OrderStatus; trackingNumber?: string; trackingUrl?: string; shippedDate?: string; estimatedDeliveryDate?: string; }
export interface UpdateOrderNotesPayloadDto { notes: string; }
export interface UpdateCustomerNotesPayloadDto { notes: string; }
export interface RefundOrderPayloadDto { amount: number; reason: string; }
export interface CreateFulfillmentItemDto { orderItemId: string; quantity: number; }
export interface CreateFulfillmentPayloadDto { carrierName?: string; trackingNumber?: string; trackingUrl?: string; items: CreateFulfillmentItemDto[]; }
export interface AddOrderItemPayloadDto { productId: string; variantId?: string; quantity: number; }
export interface UpdateOrderItemQuantityPayloadDto { quantity: number; }
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/core/src/lib/mappers/admin-order-mapping.service.ts ---
/**
 * @file admin-order-mapping.service.ts
 * @version 4.0.0 (Removed PickPack Mapper)
 * @description Mapper die nu alle inkomende orderstatussen naar camelCase converteert
 *              om inconsistenties met de backend op te lossen en consistentie in de frontend te garanderen.
 *              De 'pickpack' mapper is verwijderd, aangezien deze niet meer wordt gebruikt.
 */
import { Injectable } from '@angular/core';
import { DateTimeUtil } from '@royal-code/shared/utils';
import {
  BackendAdminOrderDetailDto,
  // BackendAdminOrderPickPackDto, // Removed
  BackendAdminOrderListItemDto,
  BackendOrderItemDto,
  BackendInternalNoteDto,
  BackendFulfillmentDto,
  BackendHistoryEventDto,
  BackendRefundDto
} from '../DTOs/backend.dto';
import {
  Order,
  OrderItem,
  OrderStatus,
  InternalNote,
  Fulfillment,
  HistoryEvent,
  Refund
} from '@royal-code/features/orders/domain';
import { Address } from '@royal-code/shared/domain';
import { ProductType } from '@royal-code/features/products/domain';

@Injectable({ providedIn: 'root' })
export class AdminOrderMappingService {

  /**
   * Converteert een string naar camelCase.
   * Wordt gebruikt om inconsistente casing van de backend (PascalCase/camelCase) te normaliseren.
   */
  private toCamelCase(str: string): string {
    if (!str) return '';
    return str.charAt(0).toLowerCase() + str.slice(1);
  }

    /* -- LIST -- */
    // FIX: Retourneer MappedAdminOrderListItemDto
  mapListItemToOrder(dto: BackendAdminOrderListItemDto): Order {
    return {
      id: dto.id,
      orderNumber: dto.orderNumber,
      orderDate: DateTimeUtil.createDateTimeInfo(dto.orderDate),
      status: this.toCamelCase(dto.status) as OrderStatus,
      userId: '', // Niet in DTO, default naar leeg
      customerName: dto.customerName,
      customerEmail: dto.customerEmail,
      totalItems: dto.totalItems,
      grandTotal: dto.grandTotal,
      currency: dto.currency,
      items: [], // Lijstitems hebben geen gedetailleerde items, dus een lege array
      productThumbnails: dto.productThumbnails,
      // Vul de rest van de vereiste Order-properties met defaults/placeholders
      subTotal: dto.grandTotal, // Beste gok
      shippingCost: 0,
      discountAmount: 0,
      taxAmount: 0,
      shippingAddress: { countryCode: dto.shippingSummary.countryCode } as Address,
      billingAddress: {} as Address,
      fulfillments: [],
      history: [],
      internalNotes: [],
      refunds: [],
      createdAt: DateTimeUtil.createDateTimeInfo(dto.orderDate),
      lastModified: DateTimeUtil.createDateTimeInfo(dto.orderDate),
    };
  }


  /* -- DETAIL -- */
  mapDetailDtoToOrder(dto: BackendAdminOrderDetailDto): Order {
    return {
      id: dto.id,
      orderNumber: dto.orderNumber,
      orderDate:   DateTimeUtil.createDateTimeInfo(dto.orderDate),
      status:      this.toCamelCase(dto.status) as OrderStatus,
      userId:      dto.customer.userId,
      customerName:dto.customer.name,
      customerEmail:dto.customer.email,
      subTotal: dto.financialSummary.subTotal,
      shippingCost:dto.financialSummary.shippingCost,
      taxAmount: dto.financialSummary.taxAmount,
      discountAmount:dto.financialSummary.discountAmount,
      grandTotal: dto.financialSummary.grandTotal,
      currency: dto.financialSummary.currency,
      shippingAddress: dto.shippingAddress,
      billingAddress:  dto.billingAddress,
      paymentDetails:  dto.paymentDetails,
      items: dto.items.map(this.mapItem),
      totalItems: dto.items.reduce((s,i)=>s+i.quantity,0),
      productThumbnails: dto.items.map(i=>i.productImageUrl).filter(Boolean) as string[],
      customerNotes: dto.customerNotes ?? undefined,
      internalNotes: dto.internalNotes.map(this.mapNote),
      fulfillments:  dto.fulfillments.map(this.mapFulfillment),
      history:       dto.history.map(this.mapHistory),
      refunds:       dto.refunds.map(this.mapRefund),
      createdAt:    DateTimeUtil.createDateTimeInfo(dto.orderDate),
      lastModified: DateTimeUtil.createDateTimeInfo(dto.orderDate)
    };
  }

  // Removed mapPickPackDtoToOrder

  /* -- helpers -- */
private mapItem = (d: BackendOrderItemDto): OrderItem => ({
      id: d.id,
      productId: d.productId,
      productVariantId: d.productVariantId,
      productName: d.productName,
      sku: d.sku,
      productType: d.productType ?? 'physical',
      quantity: d.quantity,
      pricePerItem: d.pricePerItem,
      lineTotal: d.lineTotal,
      taxAmount: d.taxAmount,
      discountAmount: d.discountAmount,
      variantInfo: d.variantInfo,
      productImageUrl: d.productImageUrl,
  });


  private mapNote = (d: BackendInternalNoteDto): InternalNote => ({ ...d, createdAt: DateTimeUtil.createDateTimeInfo(d.createdAt) });
  private mapFulfillment = (d: BackendFulfillmentDto): Fulfillment => ({
    ...d,
    createdAt: DateTimeUtil.createDateTimeInfo(d.createdAt),
    shippedDate: d.shippedDate ? DateTimeUtil.createDateTimeInfo(d.shippedDate) : null,
    estimatedDeliveryDate: d.estimatedDeliveryDate ? DateTimeUtil.createDateTimeInfo(d.estimatedDeliveryDate) : null
  });
  private mapHistory = (d: BackendHistoryEventDto): HistoryEvent =>
    ({ ...d, timestamp: DateTimeUtil.createDateTimeInfo(d.timestamp) });
  private mapRefund = (d: BackendRefundDto): Refund =>
    ({ ...d, refundedAt: DateTimeUtil.createDateTimeInfo(d.refundedAt) });
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/core/src/lib/state/admin-orders.actions.ts ---
/**
 * @file admin-orders.actions.ts
 * @version 5.0.0 (Removed 'view' parameter from Load Order Detail)
 * @description NgRx‑actions voor Admin Orders, nu zonder de 'view' parameter in Load Order Detail actie.
 */
import { createActionGroup, emptyProps, props } from '@ngrx/store';
import { Update } from '@ngrx/entity';
import { Order, OrderFilters, OrderStatus } from '@royal-code/features/orders/domain';
import { AdminOrderLookups, AdminOrderStats } from '@royal-code/features/admin-orders/domain';
import { Address } from '@royal-code/shared/domain';
import {
  AddOrderItemPayloadDto,
  UpdateOrderItemQuantityPayloadDto,
  CreateFulfillmentPayloadDto,
  RefundOrderPayloadDto,
  UpdateOrderStatusPayloadDto
} from '../DTOs/backend.dto';

export const AdminOrdersActions = createActionGroup({
  source: 'Admin/Orders',
  events: {
    // --- LEEGSLAG & FILTERS ---
    'Page Initialized': emptyProps(),
    'Filters Changed': props<{ filters: Partial<OrderFilters> }>(),
    'Load Orders': props<{ filters: Partial<OrderFilters> }>(),
    'Load Orders Success': props<{ orders: readonly Order[]; totalCount: number }>(),
    'Load Orders Failure': props<{ error: string }>(),

    // --- STATS & LOOKUPS ---
    'Load Stats': props<{ dateFrom?: string; dateTo?: string }>(),
    'Load Stats Success': props<{ stats: AdminOrderStats }>(),
    'Load Stats Failure': props<{ error: string }>(),
    'Load Lookups': emptyProps(),
    'Load Lookups Success': props<{ lookups: AdminOrderLookups }>(),
    'Load Lookups Failure': props<{ error: string }>(),

    // --- DETAIL VIEW ---
    'Order Detail Page Opened': props<{ orderId: string }>(),
    // << DE FIX: 'view' parameter verwijderd uit Load Order Detail >>
    'Load Order Detail': props<{ orderId: string }>(),
    'Load Order Detail Success': props<{ order: Order }>(),
    'Load Order Detail Failure': props<{ error: string }>(),
    'Select Order': props<{ orderId: string | null }>(),

    // --- MUTATIONS ---
    'Update Status Submitted': props<{ orderId: string; payload: UpdateOrderStatusPayloadDto }>(),
    'Update Shipping Address Submitted': props<{ orderId: string; payload: Address }>(),
    'Update Billing Address Submitted': props<{ orderId: string; payload: Address }>(),
    'Update Internal Notes Submitted': props<{ orderId: string; notes: string }>(),
    'Update Customer Notes Submitted': props<{ orderId: string; notes: string }>(),
    'Cancel Order Confirmed': props<{ orderId: string }>(),
    'Refund Order Submitted': props<{ orderId: string; payload: RefundOrderPayloadDto }>(),
    'Create Fulfillment Submitted': props<{ orderId: string; payload: CreateFulfillmentPayloadDto }>(),
    'Add Item To Order Submitted': props<{ orderId: string; payload: AddOrderItemPayloadDto }>(),
    'Update Order Item Submitted': props<{ orderId: string; orderItemId: string; payload: UpdateOrderItemQuantityPayloadDto }>(),
    'Remove Order Item Submitted': props<{ orderId: string; orderItemId: string }>(),
    'Mutation Success': props<{ orderUpdate: Update<Order> }>(),
    'Mutation Failure': props<{ error: string }>(),

    // --- DOCUMENTEN ---
    'Download Invoice Submitted': props<{ orderId: string; orderNumber: string }>(),
    'Download Packing Slip Submitted': props<{ orderId: string; orderNumber: string }>(),
    'Export Orders Submitted': props<{ filters: Partial<OrderFilters> }>()
  }
});
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/core/src/lib/state/admin-orders.effects.ts ---
/**
 * @file admin-orders.effects.ts
 * @version 5.0.0 (Fixed Detail Load - Always Full DTO)
 * @description NgRx-effects voor Admin Orders, nu met een robuuste detail load die altijd de volledige order DTO ophaalt en mapt.
 */
import { Injectable, inject } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { of, Observable } from 'rxjs';
import { switchMap, map, catchError, exhaustMap, tap, withLatestFrom } from 'rxjs/operators';

import { AdminOrdersActions } from './admin-orders.actions';
import {
  AbstractAdminOrderApiService,
  AdminOrderMappingService
} from '@royal-code/features/admin-orders/core';
import { NotificationService } from '@royal-code/ui/notifications';
import type {
  BackendAdminOrderDetailDto
} from '../DTOs/backend.dto';
import { Order } from '@royal-code/features/orders/domain';
import { StructuredError } from '@royal-code/shared/domain';
import { Store } from '@ngrx/store';

// Removed isDetailDto as we now always expect BackendAdminOrderDetailDto

@Injectable()
export class AdminOrdersEffects {
  private readonly actions$ = inject(Actions);
  private readonly api      = inject(AbstractAdminOrderApiService);
  private readonly mapper   = inject(AdminOrderMappingService);
  private readonly toast    = inject(NotificationService);
  private readonly store = inject(Store);

  // --- INIT ---
  init$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminOrdersActions.pageInitialized),
      switchMap(() => [
        AdminOrdersActions.loadOrders({ filters: {} }),
        AdminOrdersActions.loadStats({}),
        AdminOrdersActions.loadLookups()
      ])
    )
  );

  // --- LOAD ORDERS ---
  loadOrders$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminOrdersActions.loadOrders),
      switchMap(({ filters }) =>
        this.api.getOrders(filters).pipe(
          map(response =>
            AdminOrdersActions.loadOrdersSuccess({
              orders: response.items, // `response.items` is al `readonly Order[]`
              totalCount: response.totalCount
            })
          ),
          catchError(err =>
            of(AdminOrdersActions.loadOrdersFailure({ error: err.message }))
          )
        )
      )
    )
  );

  // --- LOAD STATS ---
  loadStats$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminOrdersActions.loadStats),
      switchMap(({ dateFrom, dateTo }) =>
        this.api.getStats(dateFrom, dateTo).pipe(
          map(stats => AdminOrdersActions.loadStatsSuccess({ stats })),
          catchError(err =>
            of(AdminOrdersActions.loadStatsFailure({ error: err.message }))
          )
        )
      )
    )
  );

  // --- LOAD LOOKUPS ---
  loadLookups$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminOrdersActions.loadLookups),
      switchMap(() =>
        this.api.getLookups().pipe(
          map(lookups => AdminOrdersActions.loadLookupsSuccess({ lookups })),
          catchError(err =>
            of(AdminOrdersActions.loadLookupsFailure({ error: err.message }))
          )
        )
      )
    )
  );

  // --- TRIGGER DETAIL LOAD ---
  triggerLoadDetail$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminOrdersActions.orderDetailPageOpened),
      // << DE FIX: Dispatch loadOrderDetail zonder de 'view' parameter >>
      map(({ orderId }) =>
        AdminOrdersActions.loadOrderDetail({ orderId })
      )
    )
  );

  // --- LOAD DETAIL ---
  loadDetail$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminOrdersActions.loadOrderDetail),
      switchMap(({ orderId }) => // << DE FIX: 'view' parameter verwijderd >>
        this.api.getOrderById(orderId).pipe( // << DE FIX: Call zonder 'view' parameter >>
          map(dto => {
            // Nu mappen we altijd naar een volledige Order, de API retourneert altijd DetailDto.
            const order = this.mapper.mapDetailDtoToOrder(dto as BackendAdminOrderDetailDto);
            return AdminOrdersActions.loadOrderDetailSuccess({ order });
          }),
          catchError(err =>
            of(AdminOrdersActions.loadOrderDetailFailure({ error: err.message }))
          )
        )
      )
    )
  );

  // Removed loadOrderQuickShipDetails$ effect

  // --- MUTATIONS ---
  mutation$ = createEffect(() =>
    this.actions$.pipe(
      ofType(
        AdminOrdersActions.updateStatusSubmitted,
        AdminOrdersActions.updateShippingAddressSubmitted,
        AdminOrdersActions.updateBillingAddressSubmitted,
        AdminOrdersActions.updateInternalNotesSubmitted,
        AdminOrdersActions.updateCustomerNotesSubmitted,
        AdminOrdersActions.cancelOrderConfirmed,
        AdminOrdersActions.refundOrderSubmitted,
        AdminOrdersActions.createFulfillmentSubmitted,
        AdminOrdersActions.addItemToOrderSubmitted,
        AdminOrdersActions.updateOrderItemSubmitted,
        AdminOrdersActions.removeOrderItemSubmitted
      ),
      exhaustMap(action => {
        let call$: Observable<BackendAdminOrderDetailDto>;

        switch (action.type) {
          case AdminOrdersActions.updateStatusSubmitted.type:
            call$ = this.api.updateStatus(action.orderId, action.payload);
            break;
          case AdminOrdersActions.updateShippingAddressSubmitted.type:
            call$ = this.api.updateShippingAddress(action.orderId, action.payload);
            break;
          case AdminOrdersActions.updateBillingAddressSubmitted.type:
            call$ = this.api.updateBillingAddress(action.orderId, action.payload);
            break;
          case AdminOrdersActions.updateInternalNotesSubmitted.type:
            call$ = this.api.updateInternalNotes(action.orderId, { notes: action.notes });
            break;
          case AdminOrdersActions.updateCustomerNotesSubmitted.type:
            call$ = this.api.updateCustomerNotes(action.orderId, { notes: action.notes });
            break;
          case AdminOrdersActions.cancelOrderConfirmed.type:
            call$ = this.api.cancelOrder(action.orderId);
            break;
          case AdminOrdersActions.refundOrderSubmitted.type:
            call$ = this.api.refundOrder(action.orderId, action.payload);
            break;
          case AdminOrdersActions.createFulfillmentSubmitted.type:
            call$ = this.api.createFulfillment(action.orderId, action.payload);
            break;
          case AdminOrdersActions.addItemToOrderSubmitted.type:
            call$ = this.api.addItemToOrder(action.orderId, action.payload);
            break;
          case AdminOrdersActions.updateOrderItemSubmitted.type:
            call$ = this.api.updateOrderItemQuantity(action.orderItemId, action.payload);
            break;
          case AdminOrdersActions.removeOrderItemSubmitted.type:
            call$ = this.api.removeOrderItem(action.orderItemId);
            break;
          default:
            return of(AdminOrdersActions.mutationFailure({ error: 'Unknown mutation action' }));
        }

        return call$.pipe(
          map(dto => {
            const order = this.mapper.mapDetailDtoToOrder(dto);
            // Pas de succesmelding aan voor duidelijkheid
            if (action.type === AdminOrdersActions.addItemToOrderSubmitted.type) {
              this.toast.showSuccess('Product succesvol toegevoegd aan order');
            } else {
              this.toast.showSuccess('Order succesvol bijgewerkt');
            }
            return AdminOrdersActions.mutationSuccess({
              orderUpdate: { id: order.id, changes: order }
            });
          }),
          catchError(err => {
            // Pas de foutmelding aan
            const message = action.type === AdminOrdersActions.addItemToOrderSubmitted.type
              ? 'Toevoegen van product mislukt'
              : 'Update mislukt';
            this.toast.showError(message);
            return of(AdminOrdersActions.mutationFailure({ error: err.message }));
          })
        );
      })
    )
  );

  // --- DOCUMENTEN DOWNLOAD ---
  download$ = createEffect(
    () =>
      this.actions$.pipe(
        ofType(
          AdminOrdersActions.downloadInvoiceSubmitted,
          AdminOrdersActions.downloadPackingSlipSubmitted,
          AdminOrdersActions.exportOrdersSubmitted
        ),
        exhaustMap(action => {
          let call$: Observable<Blob>;
          let filename: string;

          if (action.type === AdminOrdersActions.downloadInvoiceSubmitted.type) {
            call$ = this.api.downloadInvoice(action.orderId);
            filename = `invoice-${action.orderNumber}.pdf`;
          } else if (
            action.type === AdminOrdersActions.downloadPackingSlipSubmitted.type
          ) {
            call$ = this.api.downloadPackingSlip(action.orderId);
            filename = `packing-slip-${action.orderNumber}.pdf`;
          } else {
            call$ = this.api.exportOrders(action.filters);
            filename = `orders-export-${new Date()
              .toISOString()
              .slice(0, 10)}.csv`;
          }

          return call$.pipe(
            tap(blob => this.downloadFile(blob, filename)),
            catchError(() => {
              this.toast.showError('Download mislukt');
              return of();
            })
          );
        })
      ),
    { dispatch: false }
  );

  private downloadFile(blob: Blob, filename: string) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/core/src/lib/state/admin-orders.facade.ts ---
/**
 * @file admin-orders.facade.ts
 * @version 4.0.0 (Removed Quick Ship Details Method)
 * @description Facade voor Admin Orders, nu zonder de problematische 'Quick Ship Details' methode.
 */
import { Injectable, inject, computed, Signal } from '@angular/core';
import { Store } from '@ngrx/store';
import { OrderFilters, OrderStatus } from '@royal-code/features/orders/domain';
import { Address } from '@royal-code/shared/domain';
import {
  AddOrderItemPayloadDto,
  UpdateOrderItemQuantityPayloadDto,
  CreateFulfillmentPayloadDto,
  RefundOrderPayloadDto,
  UpdateOrderStatusPayloadDto
} from '../DTOs/backend.dto';
import { AdminOrdersActions } from './admin-orders.actions';
import { adminOrdersFeature } from './admin-orders.feature';

@Injectable({ providedIn: 'root' })
export class AdminOrdersFacade {
  private readonly store = inject(Store);

  // --- SELECTORS ---
  readonly isLoading = this.store.selectSignal(adminOrdersFeature.selectIsLoading);
  readonly isSubmitting: Signal<boolean> = this.store.selectSignal(adminOrdersFeature.selectIsSubmitting);
  readonly lookups = this.store.selectSignal(adminOrdersFeature.selectLookups);
  readonly selectedOrder = this.store.selectSignal(adminOrdersFeature.selectSelectedOrder);
  // Removed selectLoadingAccordionForId as it's no longer used.

  // --- VIEWMODEL ---
  readonly viewModel = this.store.selectSignal(adminOrdersFeature.selectViewModel);

  // --- LIFECYCLE ---
  init() {
    this.store.dispatch(AdminOrdersActions.pageInitialized());
  }
  changeFilters(filters: Partial<OrderFilters>) {
    this.store.dispatch(AdminOrdersActions.filtersChanged({ filters }));
  }
  selectOrder(orderId: string | null) {
    this.store.dispatch(AdminOrdersActions.selectOrder({ orderId }));
  }
  openOrderDetailPage(orderId: string) {
    this.store.dispatch(AdminOrdersActions.orderDetailPageOpened({ orderId }));
  }

  // Removed loadOrderQuickShipDetails as it's no longer used.


  // --- MUTATIONS ---
  updateStatus(orderId: string, newStatus: OrderStatus, trackingNumber?: string, trackingUrl?: string) {
    const payload: UpdateOrderStatusPayloadDto = { newStatus, trackingNumber, trackingUrl };
    this.store.dispatch(AdminOrdersActions.updateStatusSubmitted({ orderId, payload }));
  }
  updateShippingAddress(orderId: string, payload: Address) {
    this.store.dispatch(AdminOrdersActions.updateShippingAddressSubmitted({ orderId, payload }));
  }
  updateBillingAddress(orderId: string, payload: Address) {
    this.store.dispatch(AdminOrdersActions.updateBillingAddressSubmitted({ orderId, payload }));
  }
  updateInternalNotes(orderId: string, notes: string) {
    this.store.dispatch(AdminOrdersActions.updateInternalNotesSubmitted({ orderId, notes }));
  }
  updateCustomerNotes(orderId: string, notes: string) {
    this.store.dispatch(AdminOrdersActions.updateCustomerNotesSubmitted({ orderId, notes }));
  }
  cancelOrder(orderId: string) {
    this.store.dispatch(AdminOrdersActions.cancelOrderConfirmed({ orderId }));
  }
  refundOrder(orderId: string, amount: number, reason: string) {
    const payload: RefundOrderPayloadDto = { amount, reason };
    this.store.dispatch(AdminOrdersActions.refundOrderSubmitted({ orderId, payload }));
  }
  createFulfillment(orderId: string, payload: CreateFulfillmentPayloadDto) {
    this.store.dispatch(AdminOrdersActions.createFulfillmentSubmitted({ orderId, payload }));
  }
  addItemToOrder(orderId: string, payload: AddOrderItemPayloadDto) {
    this.store.dispatch(AdminOrdersActions.addItemToOrderSubmitted({ orderId, payload }));
  }
  updateOrderItem(orderId: string, orderItemId: string, quantity: number) {
    const payload: UpdateOrderItemQuantityPayloadDto = { quantity };
    this.store.dispatch(AdminOrdersActions.updateOrderItemSubmitted({ orderId, orderItemId, payload }));
  }
  removeOrderItem(orderId: string, orderItemId: string) {
    this.store.dispatch(AdminOrdersActions.removeOrderItemSubmitted({ orderId, orderItemId }));
  }

  // --- DOCUMENTEN ---
  downloadInvoice(orderId: string, orderNumber: string) {
    this.store.dispatch(AdminOrdersActions.downloadInvoiceSubmitted({ orderId, orderNumber }));
  }
  downloadPackingSlip(orderId: string, orderNumber: string) {
    this.store.dispatch(AdminOrdersActions.downloadPackingSlipSubmitted({ orderId, orderNumber }));
  }
  exportOrders(filters: Partial<OrderFilters>) {
    this.store.dispatch(AdminOrdersActions.exportOrdersSubmitted({ filters }));
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/core/src/lib/state/admin-orders.feature.ts ---
/**
 * @file admin-orders.feature.ts
 * @Version 3.0.0 (Definitive State - Removed Quick Ship Details)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description
 *   Definitive NgRx feature for Admin Orders, now cleaned of the problematic
 *   'Quick Ship Details' related state and actions, ensuring consistent data.
 */
import { createFeature, createReducer, on, createSelector } from '@ngrx/store';
import { createEntityAdapter, EntityAdapter, EntityState } from '@ngrx/entity';
import { Order, OrderFilters } from '@royal-code/features/orders/domain';
import { AdminOrderLookups, AdminOrderStats } from '@royal-code/features/admin-orders/domain';
import { AdminOrdersActions } from './admin-orders.actions';

export const ADMIN_ORDERS_FEATURE_KEY = 'adminOrders';

export interface AdminOrdersState extends EntityState<Order> {
  stats: AdminOrderStats | null;
  lookups: AdminOrderLookups | null;
  totalCount: number;
  isLoading: boolean;
  isSubmitting: boolean;
  error: string | null;
  filters: Partial<OrderFilters>;
  selectedOrderId: string | null;
  // Removed loadingAccordionForId
}

export const adapter: EntityAdapter<Order> = createEntityAdapter<Order>();

export const initialState: AdminOrdersState = adapter.getInitialState({
  stats: null,
  lookups: null,
  totalCount: 0,
  isLoading: true,
  isSubmitting: false,
  error: null,
  filters: { page: 1, pageSize: 20, status: 'all' },
  selectedOrderId: null,
  // Removed loadingAccordionForId
});

const reducer = createReducer(
  initialState,

  // --- LOAD LOOKUPS & STATS ---
  on(AdminOrdersActions.loadLookupsSuccess, (state, { lookups }) => ({ ...state, lookups })),
  on(AdminOrdersActions.loadStatsSuccess, (state, { stats }) => ({ ...state, stats })),

   // --- LIST PULL ---
 on(AdminOrdersActions.loadOrders, state => ({ ...state, isLoading: true, error: null })),
on(AdminOrdersActions.loadOrdersSuccess, (state, { orders, totalCount }) =>
    // FIX: Converteer `orders` expliciet naar een mutable array voor `setAll`.
    // Dit is veilig, want `setAll` creëert een nieuwe staat; de originele `orders` (readonly) blijft onaangetast.
    adapter.setAll([...orders], { ...state, totalCount, isLoading: false }) // <-- HIER IS DE FIX
  ),
  on(AdminOrdersActions.loadOrdersFailure, (state, { error }) => ({ ...state, isLoading: false, error })),

   // --- DETAIL PAGE ---
 on(AdminOrdersActions.orderDetailPageOpened, state => ({ ...state, isLoading: true, error: null })),
  on(AdminOrdersActions.loadOrderDetailSuccess, (state, { order }) =>
    adapter.upsertOne(order, { ...state, isLoading: false, selectedOrderId: order.id })
  ),
  on(AdminOrdersActions.loadOrderDetailFailure, (state, { error }) => ({ ...state, isLoading: false, error })),
  on(AdminOrdersActions.selectOrder, (state, { orderId }) => ({ ...state, selectedOrderId: orderId })),

    // --- MUTATION CYCLE ---
on(
    AdminOrdersActions.updateStatusSubmitted,
    AdminOrdersActions.updateShippingAddressSubmitted,
    AdminOrdersActions.updateBillingAddressSubmitted,
    AdminOrdersActions.updateInternalNotesSubmitted,
    AdminOrdersActions.updateCustomerNotesSubmitted,
    AdminOrdersActions.cancelOrderConfirmed,
    AdminOrdersActions.refundOrderSubmitted,
    AdminOrdersActions.createFulfillmentSubmitted,
    AdminOrdersActions.addItemToOrderSubmitted,
    AdminOrdersActions.updateOrderItemSubmitted,
    AdminOrdersActions.removeOrderItemSubmitted,
    state => ({ ...state, isSubmitting: true, error: null })
  ),
  on(AdminOrdersActions.mutationSuccess, (state, { orderUpdate }) =>
    adapter.updateOne(orderUpdate, { ...state, isSubmitting: false })
  ),
  on(AdminOrdersActions.mutationFailure, (state, { error }) => ({ ...state, isSubmitting: false, error }))
);

export const adminOrdersFeature = createFeature({
  name: ADMIN_ORDERS_FEATURE_KEY,
  reducer,
  extraSelectors: ({
    selectAdminOrdersState,
    selectSelectedOrderId,
    selectStats,
    selectLookups,
    selectIsLoading,
    selectIsSubmitting,
    selectError,
    selectFilters,
    selectTotalCount,
    // Removed selectLoadingAccordionForId
  }) => {
    const { selectAll, selectEntities } = adapter.getSelectors();

    const selectAllOrders = createSelector(selectAdminOrdersState, selectAll);
    const selectOrderEntities = createSelector(selectAdminOrdersState, selectEntities);

    const selectSelectedOrder = createSelector(
      selectOrderEntities,
      selectSelectedOrderId,
      (entities, selectedId) => (selectedId ? entities[selectedId] : undefined)
    );

    const selectViewModel = createSelector(
      selectAllOrders,
      selectStats,
      selectLookups,
      selectIsLoading,
      selectIsSubmitting,
      selectError,
      selectFilters,
      selectTotalCount,
      (orders, stats, lookups, isLoading, isSubmitting, error, filters, totalCount) => ({
        orders,
        stats,
        lookups,
        isLoading,
        isSubmitting,
        error,
        filters,
        totalCount
      })
    );

    return {
      selectAllOrders,
      selectEntities: selectOrderEntities,
      selectSelectedOrder,
      selectViewModel
    };
  }
});

// --- EXPORT PUBLIC SELECTORS ---
export const {
  selectStats,
  selectLookups,
  selectIsLoading,
  selectIsSubmitting,
  selectError,
  selectFilters,
  selectTotalCount,
  // Removed selectLoadingAccordionForId
  selectAllOrders,
  selectEntities,
  selectSelectedOrder,
  selectViewModel
} = adminOrdersFeature;
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/core/src/lib/state/admin-orders.state.ts ---

--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/data-access/src/index.ts ---
export * from './lib/services/admin-order-api.service';
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/data-access/src/lib/services/admin-order-api.service.ts ---
/**
 * @file admin-order-api.service.ts
 * @version 4.0.0 (Removed PickPack Overload & Correct Return Type)
 * @description Concrete implementatie van AbstractAdminOrderApiService.
 *              Nu zonder de 'pickpack' overload in de getOrderById implementatie, zodat altijd een volledige DTO wordt geretourneerd.
 */
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { APP_CONFIG } from '@royal-code/core/config';
import { Order, OrderFilters } from '@royal-code/features/orders/domain';
import {
  AbstractAdminOrderApiService,
  BackendAdminOrderDetailDto,
  BackendAdminOrderPickPackDto,
  BackendAdminLookupsDto,
  BackendAdminOrderStatsDto,
  BackendPaginatedOrderListDto,
  RefundOrderPayloadDto,
  UpdateOrderNotesPayloadDto,
  UpdateOrderStatusPayloadDto,
  CreateFulfillmentPayloadDto,
  UpdateCustomerNotesPayloadDto,
  AddOrderItemPayloadDto,
  UpdateOrderItemQuantityPayloadDto,
  BackendAdminOrderListItemDto
} from '@royal-code/features/admin-orders/core';
import { Address } from '@royal-code/shared/domain';
import { PaginatedList } from '@royal-code/shared/utils';
import { AdminOrderMappingService } from '@royal-code/features/admin-orders/core';

@Injectable({ providedIn: 'root' })
export class AdminOrderApiService extends AbstractAdminOrderApiService {
  private readonly http = inject(HttpClient);
  private readonly config = inject(APP_CONFIG);
  private readonly mapper = inject(AdminOrderMappingService);
  private readonly apiUrl = `${this.config.backendUrl}/AdminOrders`;

  // --- LEZEN ---
  override getOrders(filters: Partial<OrderFilters>): Observable<PaginatedList<Order>> {
    let params = new HttpParams();
    if (filters.page) params = params.set('PageNumber', filters.page.toString());
    if (filters.pageSize) params = params.set('PageSize', filters.pageSize.toString());
    if (filters.status && filters.status !== 'all') params = params.set('Status', filters.status);
    if (filters.userId) params = params.set('UserId', filters.userId);
    if (filters.searchTerm) params = params.set('SearchTerm', filters.searchTerm);
    if (filters.dateFrom) params = params.set('DateFrom', filters.dateFrom);
    if (filters.dateTo) params = params.set('DateTo', filters.dateTo);

    return this.http.get<PaginatedList<BackendAdminOrderListItemDto>>(this.apiUrl, { params }).pipe(
      map(response => ({
        ...response,
        items: response.items.map(item => this.mapper.mapListItemToOrder(item))
      }))
    );
  }

  // << DE FIX: Implementatie van getOrderById om altijd BackendAdminOrderDetailDto te retourneren >>
  override getOrderById(orderId: string): Observable<BackendAdminOrderDetailDto>;
  override getOrderById(orderId: string, view: 'pickpack'): Observable<BackendAdminOrderPickPackDto>; // Deze overload blijft voor API compatibiliteit
  override getOrderById(orderId: string, view?: 'pickpack'): Observable<BackendAdminOrderDetailDto | BackendAdminOrderPickPackDto> {
    const opts = view ? { params: new HttpParams().set('view', view) } : {};
    return this.http.get<BackendAdminOrderDetailDto>(`${this.apiUrl}/${orderId}`, opts); // Hier forceren we de DetailDto
  }

  override getStats(dateFrom?: string, dateTo?: string): Observable<BackendAdminOrderStatsDto> {
    let params = new HttpParams();
    if (dateFrom) params = params.set('DateFrom', dateFrom);
    if (dateTo) params = params.set('DateTo', dateTo);
    return this.http.get<BackendAdminOrderStatsDto>(`${this.apiUrl}/stats`, { params });
  }

  override getLookups(): Observable<BackendAdminLookupsDto> {
    return this.http.get<BackendAdminLookupsDto>(`${this.apiUrl}/lookups`);
  }

  // --- MUTATIES ---
  override updateStatus(orderId: string, pl: UpdateOrderStatusPayloadDto) {
    return this.http.patch<BackendAdminOrderDetailDto>(`${this.apiUrl}/${orderId}/status`, pl);
  }
  override updateInternalNotes(orderId: string, pl: UpdateOrderNotesPayloadDto) {
    return this.http.put<BackendAdminOrderDetailDto>(`${this.apiUrl}/${orderId}/notes`, pl);
  }
  override updateCustomerNotes(orderId: string, pl: UpdateCustomerNotesPayloadDto) {
    return this.http.put<BackendAdminOrderDetailDto>(`${this.apiUrl}/${orderId}/customer-notes`, pl);
  }
  override updateShippingAddress(orderId: string, pl: Address) {
    return this.http.put<BackendAdminOrderDetailDto>(`${this.apiUrl}/${orderId}/shipping-address`, pl);
  }
  override updateBillingAddress(orderId: string, pl: Address) {
    return this.http.put<BackendAdminOrderDetailDto>(`${this.apiUrl}/${orderId}/billing-address`, pl);
  }
  override updateOrderItemQuantity(orderItemId: string, pl: UpdateOrderItemQuantityPayloadDto) {
    return this.http.patch<BackendAdminOrderDetailDto>(`${this.apiUrl}/items/${orderItemId}`, pl);
  }

  // --- AANMAKEN / VERWIJDEREN ---
  override createFulfillment(orderId: string, pl: CreateFulfillmentPayloadDto) {
    return this.http.post<BackendAdminOrderDetailDto>(`${this.apiUrl}/${orderId}/fulfillments`, pl);
  }
  override addItemToOrder(orderId: string, pl: AddOrderItemPayloadDto) {
    return this.http.post<BackendAdminOrderDetailDto>(`${this.apiUrl}/${orderId}/items`, pl);
  }
  override removeOrderItem(itemId: string) {
    return this.http.delete<BackendAdminOrderDetailDto>(`${this.apiUrl}/items/${itemId}`);
  }

  // --- OVERIG ---
  override cancelOrder(orderId: string) {
    return this.http.post<BackendAdminOrderDetailDto>(`${this.apiUrl}/${orderId}/cancel`, {});
  }
  override refundOrder(orderId: string, pl: RefundOrderPayloadDto) {
    return this.http.post<BackendAdminOrderDetailDto>(`${this.apiUrl}/${orderId}/refund`, pl);
  }

  // --- DOCUMENTEN ---
  override exportOrders(filters: Partial<OrderFilters>): Observable<Blob> {
    let params = new HttpParams();
    if (filters.status && filters.status !== 'all') params = params.set('Status', filters.status);
    if (filters.userId) params = params.set('UserId', filters.userId);
    if (filters.searchTerm) params = params.set('SearchTerm', filters.searchTerm);
    if (filters.dateFrom) params = params.set('DateFrom', filters.dateFrom);
    if (filters.dateTo) params = params.set('DateTo', filters.dateTo);
    return this.http.get(`${this.apiUrl}/export`, { params, responseType: 'blob' });
  }
  override downloadInvoice(orderId: string) {
    return this.http.get(`${this.apiUrl}/${orderId}/invoice`, { responseType: 'blob' });
  }
  override downloadPackingSlip(orderId: string) {
    return this.http.get(`${this.apiUrl}/${orderId}/packing-slip`, { responseType: 'blob' });
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/domain/src/index.ts ---
export * from './lib/models/admin-orders.models';
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/domain/src/lib/models/admin-orders.models.ts ---
/**
 * @file admin-orders.models.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-23
 * @Description Defines the frontend domain models for admin-specific order data like stats and lookups.
 */
import { OrderStatus } from '@royal-code/features/orders/domain';

export interface AdminOrderStats {
  readonly totalRevenue: number;
  readonly totalOrders: number;
  readonly averageOrderValue: number;
  readonly ordersAwaitingFulfillment: number;
  readonly newOrdersToday: number;
  readonly revenueToday: number;
}

export interface AdminOrderLookups {
  readonly orderStatuses: ReadonlyArray<OrderStatus | string>;
  readonly paymentMethods: readonly string[];
  readonly shippingMethods: readonly string[];
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/ui/src/index.ts ---
export * from './lib/components/dashboard-stats/dashboard-stats.component';
export * from './lib/components/order-filter/order-filter.component';
export * from './lib/components/order-list/order-list.component';
export * from './lib/components/order-fulfillment-view/order-fulfillment-view.component';
export * from './lib/components/order-customer-info/order-customer-info.component';
export * from './lib/components/order-items-table/order-items-table.component';
export * from './lib/components/order-actions-card/order-actions-card.component';
export * from './lib/components/order-financials-card/order-financials-card.component';
export * from './lib/components/order-payment-details/order-payment-details.component';
export * from './lib/components/add-product-to-order-dialog/add-product-to-order-dialog.component';
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/ui/src/lib/components/add-product-to-order-dialog/add-product-to-order-dialog.component.ts ---
/**
 * @file add-product-to-order-dialog.component.ts
 * @Version 4.0.0 (Definitive - Signal State Fix)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-24
 * @Description
 *   The definitive, working version. The core issue was that the component's
 *   local selection state was a plain object, which did not reliably trigger the
 *   re-evaluation of the `computed` signal. By converting `selection` itself
 *   into a signal (`signal<Record<string, string>>({})`), the dependency becomes
 *   explicit and robust, solving the disabled button issue permanently.
 */
import { Component, ChangeDetectionStrategy, inject, signal, computed, WritableSignal } from '@angular/core';
import { CommonModule, CurrencyPipe, LowerCasePipe, TitleCasePipe } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { filter, switchMap, take } from 'rxjs';
import { toObservable, toSignal } from '@angular/core/rxjs-interop';
import { Store } from '@ngrx/store';
import { TranslateModule } from '@ngx-translate/core';

import { AdminProductsFacade } from '@royal-code/features/admin-products/core';
import { ProductFacade, selectProductById } from '@royal-code/features/products/core';
import { Product, ProductVariantCombination, VariantAttribute } from '@royal-code/features/products/domain';
import { DYNAMIC_OVERLAY_REF, DynamicOverlayRef } from '@royal-code/ui/overlay';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { UiImageComponent } from '@royal-code/ui/media';
import { AppIcon } from '@royal-code/shared/domain';
import { filterImageMedia } from '@royal-code/shared/utils';
import { Image } from '@royal-code/shared/domain';

export interface AddProductResult {
  productId: string;
  variantId: string;
  quantity: number;
}

type ViewState = 'search' | 'loadingDetails' | 'variantSelection';

@Component({
  selector: 'admin-add-product-to-order-dialog',
  standalone: true,
  imports: [
    CommonModule, FormsModule, CurrencyPipe, LowerCasePipe, TitleCasePipe, TranslateModule,
    UiInputComponent, UiButtonComponent, UiSpinnerComponent, UiImageComponent
  ],
  template: `
    <div class="p-6 rounded-xs bg-card shadow-xl border border-border w-[600px] max-w-[90vw] h-[70vh] max-h-[80vh] flex flex-col">
      <h2 class="text-xl font-semibold text-foreground mb-4">{{ 'admin.dialogs.addProduct.title' | translate }}</h2>

      @switch (viewState()) {
        @case ('search') {
          <div class="flex-shrink-0">
            <royal-code-ui-input
              [(ngModel)]="searchTerm"
              (ngModelChange)="onSearchTermChange($event)"
              [placeholder]="'admin.dialogs.addProduct.searchPlaceholder' | translate"
              [icon]="AppIcon.Search"
            />
          </div>
          <div class="flex-grow mt-4 overflow-y-auto">
            @if (adminProductsFacade.viewModel().isLoading) {
              <div class="flex justify-center items-center h-full"><royal-code-ui-spinner /></div>
            } @else {
              <ul class="space-y-2">
                @for (product of adminProductsFacade.viewModel().products; track product.id) {
                  <li (click)="selectProduct(product)" class="flex items-center gap-4 p-2 rounded-md hover:bg-hover cursor-pointer">
                    <div class="w-12 h-12 flex-shrink-0 bg-muted rounded-md overflow-hidden">
                      @if (getPrimaryImage(product); as image) {
                        <royal-code-ui-image [src]="image.variants[0].url" [alt]="product.name" objectFit="cover" />
                      }
                    </div>
                    <div class="flex-grow"><p class="font-medium text-foreground">{{ product.name }}</p><p class="text-sm text-secondary">{{ product.price | currency:'EUR' }}</p></div>
                  </li>
                } @empty { <p class="text-center text-secondary p-4">{{ 'admin.dialogs.addProduct.noProductsFound' | translate }}</p> }
              </ul>
            }
          </div>
        }
        @case ('loadingDetails') {
          <div class="flex-grow flex flex-col justify-center items-center text-center">
            <royal-code-ui-spinner size="lg" /><p class="mt-4 text-secondary">{{ 'admin.dialogs.addProduct.loadingDetails' | translate }}</p>
          </div>
        }
        @case ('variantSelection') {
          @if(selectedProduct(); as product) {
            <div class="flex-grow overflow-y-auto">
              <div class="flex items-start gap-4 mb-4">
                 <div class="w-20 h-20 flex-shrink-0 bg-muted rounded-md overflow-hidden">
                    @if (getPrimaryImage(product); as image) { <royal-code-ui-image [src]="image.variants[0].url" [alt]="product.name" objectFit="cover" /> }
                  </div>
                  <div>
                    <h3 class="font-semibold text-lg text-foreground">{{ product.name }}</h3>
                     <royal-code-ui-button type="primary" (clicked)="clearSelection()" sizeVariant="sm" extraClasses="!p-0 h-auto">← {{ 'admin.dialogs.addProduct.backToSearch' | translate }}</royal-code-ui-button>
                  </div>
              </div>
              <div class="space-y-4">
                @if ((product.variantAttributes ?? []).length > 0) {
                  @for (attribute of product.variantAttributes; track attribute.id) {
                    <div>
                      <label [for]="attribute.id" class="block text-sm font-medium text-foreground mb-1">{{ attribute.name | titlecase }}</label>
                      <select [id]="attribute.id" [ngModel]="selection()[attribute.id]" (ngModelChange)="onSelectionChange(attribute.id, $event)" class="w-full p-2 border border-input rounded-md bg-background text-sm">
                        <option [ngValue]="undefined" disabled>{{ 'admin.dialogs.addProduct.selectAttribute' | translate: { attribute: (attribute.name | lowercase) } }}</option>
                        @for (value of attribute.values; track value.id) {
                          <option [value]="value.id">{{ (value.displayName || value.value) | titlecase }}</option>
                        }
                      </select>
                    </div>
                  }
                }
                <div>
                  <label for="quantity" class="block text-sm font-medium text-foreground mb-1">{{ 'admin.dialogs.addProduct.quantity' | translate }}</label>
                  <royal-code-ui-input id="quantity" type="number" [(ngModel)]="quantity" />
                </div>
                @if (selectedVariant()) {
                  <div class="p-3 bg-surface-alt rounded-md text-sm">
                    <p><strong>{{ 'admin.dialogs.addProduct.sku' | translate }}:</strong> {{ selectedVariant()?.sku }}</p>
                    <p><strong>{{ 'admin.dialogs.addProduct.price' | translate }}:</strong> {{ selectedVariant()?.price | currency:'EUR' }}</p>
                    <p><strong>{{ 'admin.dialogs.addProduct.stockStatus' | translate }}:</strong> {{ selectedVariant()?.stockStatus | titlecase }}</p>
                  </div>
                }
              </div>
            </div>
          }
        }
      }

      <div class="flex-shrink-0 pt-4 border-t border-border flex justify-end gap-3">
        <royal-code-ui-button type="outline" (clicked)="cancel()">{{ 'admin.dialogs.addProduct.cancel' | translate }}</royal-code-ui-button>
        <royal-code-ui-button type="primary" (clicked)="confirm()" [disabled]="!isSelectionValid()">{{ 'admin.dialogs.addProduct.addToOrder' | translate }}</royal-code-ui-button>
      </div>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class AddProductToOrderDialogComponent {
  protected readonly adminProductsFacade = inject(AdminProductsFacade);
  protected readonly productFacade = inject(ProductFacade);
  private readonly store = inject(Store);
  private readonly overlayRef = inject<DynamicOverlayRef<AddProductResult>>(DYNAMIC_OVERLAY_REF);

  protected readonly AppIcon = AppIcon;
  protected searchTerm: string = '';
  // *** DE FIX: Converteer de lokale state naar een signal ***
  protected selection = signal<Record<string, string>>({});
  protected quantity = 1;

  protected viewState: WritableSignal<ViewState> = signal('search');
  protected selectedProductId = signal<string | null>(null);

  protected selectedProduct = toSignal(
    toObservable(this.selectedProductId).pipe(
      filter((id): id is string => !!id),
      switchMap(id => this.store.select(selectProductById(id)))
    )
  );
  
  protected selectedVariant = computed<ProductVariantCombination | undefined>(() => {
    const product = this.selectedProduct();
    const currentSelection = this.selection(); // Lees de signal waarde
    
    if (!product || !product.variantCombinations) {
      return undefined;
    }
    
    const requiredAttributeIds = (product.variantAttributes ?? []).map((a: VariantAttribute) => a.id);
    
    if (requiredAttributeIds.length === 0) {
      return product.variantCombinations[0];
    }
    
    const hasAllSelections = requiredAttributeIds.every((id: string) => !!currentSelection[id]);
    if (!hasAllSelections) return undefined;

    return product.variantCombinations.find((combo: ProductVariantCombination) => 
      combo.attributes.every(attr => currentSelection[attr.attributeId] === attr.attributeValueId)
    );
  });
  
  protected isSelectionValid = computed(() => {
    const product = this.selectedProduct();
    if (!product || this.viewState() !== 'variantSelection' || this.quantity <= 0) {
      return false;
    }
    
    const hasVariantAttributes = (product.variantAttributes ?? []).length > 0;
    if (!hasVariantAttributes) {
      return (product.variantCombinations ?? []).length > 0;
    }
    
    return !!this.selectedVariant();
  });

  constructor() {
    this.adminProductsFacade.initPage();
  }
  
  onSearchTermChange(term: string): void {
    setTimeout(() => {
      if (term === this.searchTerm) {
        this.adminProductsFacade.changeFilters({ searchTerm: term });
      }
    }, 300);
  }

  getPrimaryImage(product: Product | null): Image | undefined {
    if (!product) return undefined;
    return filterImageMedia(product.media)?.[0];
  }

  selectProduct(product: Product): void {
    this.viewState.set('loadingDetails');
    this.productFacade.selectProduct(product.id);

    this.productFacade.viewModel$.pipe(
      filter(vm => !vm.isLoading && !!vm.selectedProduct && vm.selectedProduct.id === product.id),
      take(1)
    ).subscribe(vm => {
      this.selectedProductId.set(vm.selectedProduct!.id);
      this.viewState.set('variantSelection');
    });
  }

  clearSelection(): void {
    this.viewState.set('search');
    this.selectedProductId.set(null);
    this.productFacade.selectProduct(null);
    this.selection.set({}); // Reset het signal
  }
  
  onSelectionChange(attributeId: string, valueId: string): void {
    // *** DE FIX: Gebruik de .update() methode van het signal ***
    this.selection.update(currentSelection => ({
      ...currentSelection,
      [attributeId]: valueId
    }));
  }

  confirm(): void {
    const product = this.selectedProduct();
    if (!product || !this.isSelectionValid()) return;
    
    let variantId = this.selectedVariant()?.id;
    if (!variantId && (product.variantAttributes ?? []).length === 0) {
      variantId = (product.variantCombinations ?? []).find(vc => vc.isDefault)?.id ?? product.variantCombinations?.[0]?.id;
    }

    if (!variantId) {
      console.error("Could not find a valid variant ID to add.");
      return;
    }

    this.overlayRef.close({
      productId: product.id,
      variantId: variantId,
      quantity: this.quantity,
    });
  }

  cancel(): void {
    this.overlayRef.close();
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/ui/src/lib/components/dashboard-stats/dashboard-stats.component.ts ---
/**
 * @file dashboard-stats.component.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-22
 * @Description Displays key order statistics in a card layout.
 */
import { Component, ChangeDetectionStrategy, input } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { AdminOrderStats } from '@royal-code/features/admin-orders/domain';
import { UiIconComponent } from '@royal-code/ui/icon';
import { AppIcon } from '@royal-code/shared/domain';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';

@Component({
  selector: 'admin-dashboard-stats',
  standalone: true,
  imports: [CommonModule, CurrencyPipe, UiIconComponent, UiSpinnerComponent],
  template: `
    <div class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-6 gap-4">
      @if (stats(); as statData) {
        <div class="bg-card border border-border rounded-xs p-4">
          <h3 class="text-sm font-medium text-muted">Totale Omzet</h3>
          <p class="text-2xl font-semibold mt-1">{{ statData.totalRevenue | currency:'EUR' }}</p>
        </div>
        <div class="bg-card border border-border rounded-xs p-4">
          <h3 class="text-sm font-medium text-muted">Totaal Aantal Orders</h3>
          <p class="text-2xl font-semibold mt-1">{{ statData.totalOrders }}</p>
        </div>
        <div class="bg-card border border-border rounded-xs p-4">
          <h3 class="text-sm font-medium text-muted">Gem. Orderwaarde</h3>
          <p class="text-2xl font-semibold mt-1">{{ statData.averageOrderValue | currency:'EUR' }}</p>
        </div>
        <div class="bg-card border border-border rounded-xs p-4">
          <h3 class="text-sm font-medium text-muted">Wacht op verzending</h3>
          <p class="text-2xl font-semibold mt-1">{{ statData.ordersAwaitingFulfillment }}</p>
        </div>
        <div class="bg-card border border-border rounded-xs p-4">
          <h3 class="text-sm font-medium text-muted">Nieuw Vandaag</h3>
          <p class="text-2xl font-semibold mt-1">{{ statData.newOrdersToday }}</p>
        </div>
        <div class="bg-card border border-border rounded-xs p-4">
          <h3 class="text-sm font-medium text-muted">Omzet Vandaag</h3>
          <p class="text-2xl font-semibold mt-1">{{ statData.revenueToday | currency:'EUR' }}</p>
        </div>
      } @else {
        @for (_ of [1,2,3,4,5,6]; track $index) {
          <div class="bg-card border border-border rounded-xs p-4 h-[92px] animate-pulse"></div>
        }
      }
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class DashboardStatsComponent {
  stats = input<AdminOrderStats | null>();
  protected readonly AppIcon = AppIcon;
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/ui/src/lib/components/order-actions-card/order-actions-card.component.ts ---
/**
 * @file order-actions-card.component.ts
 * @Version 1.8.0 (Translated Labels & Fire Button)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Dumb component for order actions, now with i18n labels and a 'fire' styled cancel button.
 */
import { Component, ChangeDetectionStrategy, input, output } from '@angular/core';
import { CommonModule, AsyncPipe } from '@angular/common';
import { FormGroup, ReactiveFormsModule } from '@angular/forms';
import { AdminOrderLookups } from '@royal-code/features/admin-orders/domain';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiButtonComponent } from '@royal-code/ui/button';
import { AppIcon } from '@royal-code/shared/domain';
import { UiIconComponent } from '@royal-code/ui/icon';
import { OrderStatusPipe } from '@royal-code/features/orders/ui-plushie';
import { TranslateModule } from '@ngx-translate/core';
import { OrderStatus } from '@royal-code/features/orders/domain';

@Component({
  selector: 'admin-order-actions-card',
  standalone: true,
  imports: [
    CommonModule, ReactiveFormsModule, AsyncPipe, TranslateModule,
    UiInputComponent, UiButtonComponent, UiIconComponent, OrderStatusPipe
  ],
  template: `
    <div [formGroup]="parentFormGroup()">
      <div class="space-y-4">
        <div>
          <label class="block text-sm font-medium text-foreground mb-1">{{ 'admin.orders.detail.status' | translate }}</label>
          <select formControlName="status" class="w-full p-2 border border-input rounded-md bg-background text-sm">
            @for (status of lookups()?.orderStatuses; track status) {
              <option [value]="status">{{ (status | orderStatusInfo).textKey | translate }}</option>
            }
          </select>
        </div>
        <div class="space-y-3" formGroupName="shippingDetails">
          <royal-code-ui-input [label]="'admin.orders.fulfillment.trackingNumber' | translate" formControlName="trackingNumber" />
          <royal-code-ui-input [label]="'admin.orders.fulfillment.trackingUrlOptional' | translate" formControlName="trackingUrl" />
        </div>
        <div class="flex flex-col gap-2 pt-4 border-t border-border">
          <royal-code-ui-button type="fire" (clicked)="cancelOrder.emit()">
            <royal-code-ui-icon [icon]="AppIcon.XCircle" extraClass="mr-2" /> {{ 'admin.orders.detail.orderCancel' | translate }}
          </royal-code-ui-button>
          <royal-code-ui-button type="outline" (clicked)="refundOrder.emit()">
            <royal-code-ui-icon [icon]="AppIcon.Banknote" extraClass="mr-2" /> {{ 'admin.orders.detail.refund' | translate }}
          </royal-code-ui-button>
        </div>
      </div>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class OrderActionsCardComponent {
  parentFormGroup = input.required<FormGroup>();
  lookups = input<AdminOrderLookups | null>();
  cancelOrder = output<void>();
  refundOrder = output<void>();
  protected readonly AppIcon = AppIcon;
  protected readonly OrderStatus = OrderStatus;
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/ui/src/lib/components/order-customer-info/order-customer-info.component.ts ---
/**
 * @file order-customer-info.component.ts
 * @Version 1.1.0 (Translated Labels)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-24
 * @Description Dumb component to display customer information and addresses for an order, now with i18n labels.
 */
import { Component, ChangeDetectionStrategy, input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormGroup, ReactiveFormsModule } from '@angular/forms';
import { TranslateModule } from '@ngx-translate/core'; // Import TranslateModule
import { Address } from '@royal-code/shared/domain';
import { UiInputComponent } from '@royal-code/ui/input';

@Component({
  selector: 'admin-order-customer-info',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, UiInputComponent, TranslateModule], // Add TranslateModule
  template: `
    <div [formGroup]="parentFormGroup()">
      <div formGroupName="customer">
        <royal-code-ui-input [label]="'admin.orders.detail.customerName' | translate" formControlName="customerName" [readonly]="true" />
        <royal-code-ui-input [label]="'admin.orders.detail.customerEmail' | translate" formControlName="customerEmail" [readonly]="true" />
      </div>

      <h4 class="text-md font-semibold mt-6 mb-3">{{ 'admin.orders.detail.shippingAddress' | translate }}</h4>
      <div formGroupName="shippingAddress" class="space-y-3">
        <royal-code-ui-input [label]="'admin.orders.detail.contactName' | translate" formControlName="contactName" />
        <royal-code-ui-input [label]="'admin.orders.detail.street' | translate" formControlName="street" />
        <royal-code-ui-input [label]="'admin.orders.detail.houseNumber' | translate" formControlName="houseNumber" />
        <royal-code-ui-input [label]="'admin.orders.detail.postalCode' | translate" formControlName="postalCode" />
        <royal-code-ui-input [label]="'admin.orders.detail.city' | translate" formControlName="city" />
        <royal-code-ui-input [label]="'admin.orders.detail.countryCode' | translate" formControlName="countryCode" />
      </div>

      <h4 class="text-md font-semibold mt-6 mb-3">{{ 'admin.orders.detail.billingAddress' | translate }}</h4>
      <div formGroupName="billingAddress" class="space-y-3">
        <royal-code-ui-input [label]="'admin.orders.detail.contactName' | translate" formControlName="contactName" />
        <royal-code-ui-input [label]="'admin.orders.detail.street' | translate" formControlName="street" />
        <royal-code-ui-input [label]="'admin.orders.detail.houseNumber' | translate" formControlName="houseNumber" />
        <royal-code-ui-input [label]="'admin.orders.detail.postalCode' | translate" formControlName="postalCode" />
        <royal-code-ui-input [label]="'admin.orders.detail.city' | translate" formControlName="city" />
        <royal-code-ui-input [label]="'admin.orders.detail.countryCode' | translate" formControlName="countryCode" />
      </div>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class OrderCustomerInfoComponent {
  parentFormGroup = input.required<FormGroup>();
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/ui/src/lib/components/order-filter/order-filter.component.ts ---
/**
 * @file order-filter.component.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-22
 * @Description UI component for filtering the admin order list.
 */
import { Component, ChangeDetectionStrategy, input, output } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { AdminOrderLookups } from '@royal-code/features/admin-orders/domain';
import { OrderFilters } from '@royal-code/features/orders/domain';
import { UiInputComponent } from '@royal-code/ui/input';
import { AppIcon } from '@royal-code/shared/domain';
import { Subject } from 'rxjs';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { toSignal, toObservable } from '@angular/core/rxjs-interop';

@Component({
  selector: 'admin-order-filter',
  standalone: true,
  imports: [CommonModule, FormsModule, UiInputComponent],
  template: `
    <div class="flex flex-col sm:flex-row gap-4 p-4 bg-surface-alt border border-border rounded-xs">
      <royal-code-ui-input
        [ngModel]="searchTerm()"
        (ngModelChange)="onSearchTermChange($event)"
        placeholder="Zoek op ordernr, klant..."
        [icon]="AppIcon.Search" iconPosition="left" extraClasses="flex-grow" />
      <select [ngModel]="statusFilter" (ngModelChange)="onStatusChange($event)"
        class="w-full sm:w-48 p-2 border border-input rounded-md bg-background text-sm focus:ring-primary focus:border-primary">
        <option value="all">Alle Statussen</option>
        @if (lookups(); as lookupData) {
          @for (status of lookupData.orderStatuses; track status) {
            <option [value]="status">{{ status | titlecase }}</option>
          }
        }
       </select>
       <!-- Date pickers can be added here later -->
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class OrderFilterComponent {
  lookups = input<AdminOrderLookups | null>();
  filtersChanged = output<Partial<OrderFilters>>();

  protected readonly AppIcon = AppIcon;
  protected statusFilter: string = 'all';

  private searchTermSubject = new Subject<string>();
  protected searchTerm = toSignal(this.searchTermSubject.pipe(
    debounceTime(300),
    distinctUntilChanged()
  ), { initialValue: '' });

  constructor() {
    toObservable(this.searchTerm).subscribe(term => {
      this.filtersChanged.emit({ searchTerm: term });
    });
  }

  onSearchTermChange(term: string): void {
    this.searchTermSubject.next(term);
  }

  onStatusChange(status: string): void {
    this.statusFilter = status;
    this.filtersChanged.emit({ status: status as any });
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/ui/src/lib/components/order-financials-card/order-financials-card.component.ts ---
// --- MAAK BESTAND AAN: libs/features/admin-orders/ui/src/lib/components/order-financials-card/order-financials-card.component.ts ---
/**
 * @file order-financials-card.component.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-23
 * @Description Dumb component to display the financial summary of an order.
 */
import { Component, ChangeDetectionStrategy, input } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { Order } from '@royal-code/features/orders/domain';

@Component({
  selector: 'admin-order-financials-card',
  standalone: true,
  imports: [CommonModule, CurrencyPipe],
  template: `
    @if (order(); as o) {
      <div class="space-y-2 text-sm">
        <div class="flex justify-between">
          <span class="text-muted">Subtotaal</span>
          <span class="font-medium">{{ o.subTotal | currency:'EUR' }}</span>
        </div>
        <div class="flex justify-between">
          <span class="text-muted">Verzendkosten</span>
          <span class="font-medium">{{ o.shippingCost | currency:'EUR' }}</span>
        </div>
        <div class="flex justify-between">
          <span class="text-muted">BTW</span>
          <span class="font-medium">{{ o.taxAmount | currency:'EUR' }}</span>
        </div>
        @if (o.discountAmount > 0) {
          <div class="flex justify-between text-success">
            <span class="text-muted">Korting</span>
            <span class="font-medium">- {{ o.discountAmount | currency:'EUR' }}</span>
          </div>
        }
        <div class="flex justify-between text-base font-semibold pt-2 border-t border-border mt-2">
          <span>Totaal</span>
          <span>{{ o.grandTotal | currency:'EUR' }}</span>
        </div>
      </div>
    }
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class AdminOrderFinancialsCardComponent {
  order = input.required<Order>();
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/ui/src/lib/components/order-fulfillment-view/order-fulfillment-view.component.ts ---
/**
 * @file order-fulfillment-view.component.ts
 * @Version 2.0.0 (Upgraded with Form)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-22
 * @Description Dumb component for the 'fast lane' accordion. Displays order items,
 *              shipping address, and a form to update status to 'Shipped'.
 */
import { Component, ChangeDetectionStrategy, input, output, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Order, OrderStatus } from '@royal-code/features/orders/domain';
import { UiIconComponent } from '@royal-code/ui/icon';
import { AppIcon } from '@royal-code/shared/domain';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { UiImageComponent } from '@royal-code/ui/media';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';

export interface UpdateStatusPayload {
  trackingNumber: string;
  trackingUrl: string;
}

@Component({
  selector: 'admin-order-fulfillment-view',
  standalone: true,
  imports: [CommonModule, FormsModule, UiIconComponent, UiInputComponent, UiButtonComponent, UiSpinnerComponent, UiImageComponent, UiTitleComponent],
  template: `
    <div class="p-4 bg-surface-alt">
      @if (isLoading()) {
        <div class="flex items-center justify-center p-8">
          <royal-code-ui-spinner />
        </div>
      } @else if (order()) {
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
          <!-- Items -->
          <div class="md:col-span-2">
            <div class="flex items-center gap-2 mb-2">
              <royal-code-ui-icon [icon]="AppIcon.Package" sizeVariant="sm" />
              <royal-code-ui-title 
                [level]="TitleTypeEnum.H4" 
                [heading]="false" 
                text="Producten" 
                extraClasses="text-sm font-semibold !mb-0" />
            </div>
            <ul class="divide-y divide-border">
              @for (item of order().items; track item.id) {
                <li class="py-2 flex items-start justify-between gap-4">
                  <div class="flex items-center gap-3 min-w-0">
                    <div class="w-10 h-10 flex-shrink-0">
                      <royal-code-ui-image 
                        [src]="item.productImageUrl ?? 'default-image.jpg'" 
                        [alt]="item.productName" 
                        objectFit="cover" 
                        [rounded]="true" />
                    </div>
                    <div class="text-sm min-w-0">
                      <p class="font-medium text-foreground truncate" [title]="item.productName">{{ item.productName }}</p>
                      <!-- DE FIX: Toon SKU als hij bestaat, anders niets -->
                      @if(item.sku) {
                        <p class="text-xs text-muted">SKU: {{ item.sku }}</p>
                      }
                    </div>
                  </div>
                  <div class="font-mono text-sm text-foreground whitespace-nowrap pt-1 flex-shrink-0">
                    {{ item.quantity }}x
                  </div>
                </li>
              }
            </ul>
          </div>
          <!-- Verzend & Actie -->
          <div class="md:col-span-1 space-y-4">
              <div>
                <div class="flex items-center gap-2 mb-2">
                  <royal-code-ui-icon [icon]="AppIcon.Truck" sizeVariant="sm" />
                  <royal-code-ui-title 
                    [level]="TitleTypeEnum.H4" 
                    [heading]="false" 
                    text="Verzenden Naar" 
                    extraClasses="text-sm font-semibold !mb-0" />
                </div>
                @if (order().shippingAddress; as address) {
                  <div class="text-sm text-secondary leading-relaxed bg-background p-3 rounded-md border border-border">
                    <p class="font-medium text-foreground">{{ address.contactName }}</p>
                    <p>{{ address.street }} {{ address.houseNumber }}</p>
                    <p>{{ address.postalCode }} {{ address.city }}</p>
                  </div>
                } @else {
                  <p class="text-sm text-secondary italic">Geen verzendadres beschikbaar.</p>
                }
              </div>
              <div class="pt-2 border-t border-border">
                <royal-code-ui-title 
                  [level]="TitleTypeEnum.H4" 
                  [heading]="false" 
                  text="Order verzenden" 
                  extraClasses="text-sm font-semibold mb-2" />
                <div class="space-y-3">
                    <royal-code-ui-input label="Trackingnummer" [(ngModel)]="trackingNumber" />
                    <royal-code-ui-input label="Tracking URL (optioneel)" [(ngModel)]="trackingUrl" />
                    <royal-code-ui-button type="primary" (clicked)="onUpdateStatus()" [disabled]="!trackingNumber" class="m-2">
                        <royal-code-ui-icon [icon]="AppIcon.Send" /> Markeer als Verzonden
                    </royal-code-ui-button>
                </div>
              </div>
          </div>
        </div>
      }
    </div>
  `,
  // ...
})
export class OrderFulfillmentViewComponent {
  order = input.required<Order>();
  isLoading = input.required<boolean>();
  updateStatusClicked = output<UpdateStatusPayload>();

  protected readonly AppIcon = AppIcon;
  protected readonly TitleTypeEnum = TitleTypeEnum; // Voeg deze toe
  protected trackingNumber = '';
  protected trackingUrl = '';

  onUpdateStatus(): void {
    if (this.trackingNumber) {
      this.updateStatusClicked.emit({
        trackingNumber: this.trackingNumber,
        trackingUrl: this.trackingUrl,
      });
    }
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/ui/src/lib/components/order-items-table/order-items-table.component.ts ---
/**
 * @file order-items-table.component.ts
 * @Version 3.3.0 (Definitive - i18n Headers & RxJS Interop)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description
 *   Dumb component that now correctly displays variant information,
 *   with i18n headers and the RxJS interop import fixed and improved type safety in the
 *   valueChanges subscription.
 */
import { Component, ChangeDetectionStrategy, input, output, effect, DestroyRef, inject } from '@angular/core';
import { CommonModule, CurrencyPipe, KeyValuePipe } from '@angular/common';
import { FormArray, ReactiveFormsModule, FormGroup, AbstractControl } from '@angular/forms';
import { TranslateModule } from '@ngx-translate/core';
import { UiImageComponent } from '@royal-code/ui/image';
import { UiIconComponent } from '@royal-code/ui/icon';
import { AppIcon } from '@royal-code/shared/domain';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiButtonComponent } from '@royal-code/ui/button';
import { debounceTime } from 'rxjs/operators';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { UiBadgeComponent } from '@royal-code/ui/badge';
import { OrderItem } from '@royal-code/features/orders/domain';

export interface OrderItemUpdate {
  itemId: string;
  quantity: number;
  pricePerItem: number;
}

@Component({
  selector: 'admin-order-items-table',
  standalone: true,
  imports: [CommonModule, CurrencyPipe, ReactiveFormsModule, UiImageComponent, UiIconComponent, UiInputComponent, UiButtonComponent, TranslateModule, KeyValuePipe, UiBadgeComponent],
  template: `
    <div [formGroup]="parentFormGroup()">
      <div class="overflow-x-auto" formArrayName="items">
        <table class="w-full text-sm text-left text-secondary">
          <thead class="text-xs text-muted uppercase bg-surface-alt">
             <tr>
              <th scope="col" class="p-4">{{ 'admin.orders.detail.products' | translate }}</th>
              <th scope="col" class="p-4 w-32">{{ 'admin.orders.detail.pricePerItem' | translate }}</th>
              <th scope="col" class="p-4 w-24">{{ 'admin.orders.detail.quantity' | translate }}</th>
              <th scope="col" class="p-4 text-right">{{ 'admin.orders.detail.total' | translate }}</th>
              <th scope="col" class="p-4"></th>
            </tr>
          </thead>
          <tbody>
            @for (control of itemsFormArray.controls; track control.value.id; let i = $index) {
              <tr class="border-b border-border last:border-b-0 hover:bg-hover" [formGroupName]="i">
                <td class="p-4 font-medium text-foreground align-top">
                  <div class="flex items-start gap-3">
                    <div class="w-12 h-12 flex-shrink-0 rounded-md overflow-hidden bg-muted">
                      @if (control.value.productImageUrl) {
                        <royal-code-ui-image [src]="control.value.productImageUrl" [alt]="control.value.productName" objectFit="cover" />
                      } @else {
                        <div class="w-full h-full flex items-center justify-center text-secondary">
                          <royal-code-ui-icon [icon]="AppIcon.ImageOff" sizeVariant="sm" />
                        </div>
                      }
                    </div>
                    <div>
                      <span class="font-semibold text-foreground">{{ control.value.productName }}</span>
                       @if(control.value.sku) {
                        <p class="text-xs font-mono text-muted">SKU: {{ control.value.sku }}</p>
                      }
                      @if(control.value.variantInfo && control.value.variantInfo.length > 0) {
                        <div class="flex flex-wrap items-center gap-2">
                          @for(variant of control.value.variantInfo; track variant.attributeType) {
                            <royal-code-ui-badge color="muted" [bordered]="true">
                              @if (variant.attributeType.toLowerCase() === 'color' && variant.colorHex) {
                                <span class="w-3 h-3 rounded-full border border-border inline-block flex-shrink-0" [style.background-color]="variant.colorHex"></span>
                              }
                              <span>{{ variant.displayName }}</span>
                            </royal-code-ui-badge>
                          }
                        </div>
                      }
                    </div>
                  </div>
                </td>
                <td class="p-4 align-middle">
                  <royal-code-ui-input formControlName="pricePerItem" type="number" extraClasses="!py-1" />
                </td>
                <td class="p-4 align-middle">
                  <royal-code-ui-input formControlName="quantity" type="number" extraClasses="!py-1" />
                </td>
                <td class="p-4 text-right font-medium align-middle">{{ control.value.pricePerItem * control.value.quantity | currency:'EUR' }}</td>
                <td class="p-4 text-right align-middle">
                  <royal-code-ui-button type="fire" sizeVariant="icon" (clicked)="removeItem.emit(control.value.id)">
                    <royal-code-ui-icon [icon]="AppIcon.Trash2" />
                  </royal-code-ui-button>
                </td>
              </tr>
            }
          </tbody>
        </table>
      </div>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class OrderItemsTableComponent {
  parentFormGroup = input.required<FormGroup>();

  addItem = output<void>();
  removeItem = output<string>();
  itemUpdated = output<OrderItemUpdate>();

  protected readonly AppIcon = AppIcon;
  private readonly destroyRef = inject(DestroyRef);

  get itemsFormArray(): FormArray {
    return this.parentFormGroup().get('items') as FormArray;
  }
  
  constructor() {
    effect(() => {
      const form = this.parentFormGroup();
      if (form) {
        this.itemsFormArray.controls.forEach((control: AbstractControl) => {
          control.valueChanges.pipe(
            debounceTime(500),
            takeUntilDestroyed(this.destroyRef)
          ).subscribe(value => {
            const itemValue = value as OrderItem;
            if (control.dirty && itemValue?.id) {
              this.itemUpdated.emit({
                itemId: itemValue.id,
                quantity: itemValue.quantity,
                pricePerItem: itemValue.pricePerItem
              });
            }
          });
        });
      }
    }, { allowSignalWrites: true });
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/ui/src/lib/components/order-list/order-list.component.ts ---
/**
 * @file order-list.component.ts
 * @Version 5.0.0 (Definitive - Robust Accordion & Data Loading - Public Facade)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Definitive smart-dumb component that displays a list of orders. It manages the
 *              accordion state and triggers full order detail loading via the facade when a row is expanded.
 *              'facade' is nu protected voor template toegang.
 */
import { Component, ChangeDetectionStrategy, input, output, signal, inject, computed } from '@angular/core';
import { CommonModule, CurrencyPipe, DatePipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { Order, OrderStatus } from '@royal-code/features/orders/domain';
import { UiIconComponent } from '@royal-code/ui/icon';
import { UiButtonComponent } from '@royal-code/ui/button';
import { AppIcon } from '@royal-code/shared/domain';
import { AdminOrdersFacade, adminOrdersFeature } from '@royal-code/features/admin-orders/core';
import { toSignal } from '@angular/core/rxjs-interop';
import { OrderFulfillmentViewComponent, UpdateStatusPayload } from '../order-fulfillment-view/order-fulfillment-view.component';
import { Store } from '@ngrx/store';
import { UiSpinnerComponent } from '@royal-code/ui/spinner'; // << DE FIX: Importeer UiSpinnerComponent >>


@Component({
  selector: 'admin-order-list',
  standalone: true,
  imports: [
    CommonModule, CurrencyPipe, DatePipe, RouterModule,
    UiIconComponent, UiButtonComponent, OrderFulfillmentViewComponent,
    UiSpinnerComponent // << DE FIX: Voeg UiSpinnerComponent toe aan imports >>
  ],
  template: `
    <div class="bg-card border border-border rounded-xs overflow-x-auto">
      <table class="w-full text-sm text-left text-secondary whitespace-nowrap">
        <thead class="text-xs text-muted uppercase bg-surface-alt">
          <tr>
            <th scope="col" class="p-4 w-12"></th>
            <th scope="col" class="p-4">Order #</th>
            <th scope="col" class="p-4">Datum</th>
            <th scope="col" class="p-4">Klant</th>
            <th scope="col" class="p-4">Totaal</th>
            <th scope="col" class="p-4">Status</th>
            <th scope="col" class="p-4 text-right">Acties</th>
          </tr>
        </thead>
        @if (!isLoading()) {
          @for (order of orders(); track order.id) {
            <tbody class="border-b border-border last:border-b-0">
              <tr class="hover:bg-hover">
                <td class="p-2 text-center">
                  <royal-code-ui-button type="transparent" sizeVariant="icon" (clicked)="toggleExpand(order)" [title]="expandedOrderId() === order.id ? 'Inklappen' : 'Snelle weergave'">
                    <royal-code-ui-icon [icon]="AppIcon.ChevronRight" sizeVariant="sm" [extraClass]="'transition-transform ' + (expandedOrderId() === order.id ? 'rotate-90' : '')"/>
                  </royal-code-ui-button>
                </td>
                <td class="p-4 font-mono text-foreground">{{ order.orderNumber }}</td>
                <td class="p-4">{{ order.orderDate.iso | date:'dd-MM-yyyy HH:mm' }}</td>
                <td class="p-4">{{ order.customerName }}</td>
                <td class="p-4">{{ order.grandTotal | currency:'EUR' }}</td>
                <td class="p-4"><span class="font-semibold">{{ order.status | titlecase }}</span></td>
                <td class="p-4 text-right">
                  <royal-code-ui-button type="outline" sizeVariant="sm" [routerLink]="['/orders', order.id]">
                    Beheren
                  </royal-code-ui-button>
                </td>
              </tr>
              @if (expandedOrderId() === order.id) {
                <tr>
                  <td colspan="7" class="p-0">
                    <!-- Bind aan de volledig geladen order van de facade -->
                    @if (facade.selectedOrder(); as detailedOrder) {
                      <admin-order-fulfillment-view 
                          [order]="detailedOrder" 
                          [isLoading]="facade.isLoading()"
                          (updateStatusClicked)="handleUpdateStatus(detailedOrder.id, $event)" />
                    } @else {
                      <div class="flex items-center justify-center p-8">
                        <royal-code-ui-spinner />
                      </div>
                    }
                  </td>
                </tr>
              }
            </tbody>
          } @empty {
            <tbody>
              <tr>
                <td colspan="7" class="p-8 text-center">Geen orders gevonden voor de huidige filters.</td>
              </tr>
            </tbody>
          }
        } @else {
          <!-- Skeleton Loader -->
          <tbody>
            @for (_ of [1,2,3,4,5]; track $index) {
              <tr class="border-b border-border">
                <td class="p-4"><div class="h-6 w-6 bg-muted rounded-full animate-pulse"></div></td>
                <td class="p-4"><div class="h-4 bg-muted rounded animate-pulse w-24"></div></td>
                <td class="p-4"><div class="h-4 bg-muted rounded animate-pulse w-32"></div></td>
                <td class="p-4"><div class="h-4 bg-muted rounded animate-pulse w-40"></div></td>
                <td class="p-4"><div class="h-4 bg-muted rounded animate-pulse w-16"></div></td>
                <td class="p-4"><div class="h-4 bg-muted rounded animate-pulse w-20"></div></td>
                <td class="p-4 text-right"><div class="h-8 bg-muted rounded animate-pulse w-20 ml-auto"></div></td>
              </tr>
            }
          </tbody>
        }
      </table>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class OrderListComponent {
  orders = input.required<readonly Order[]>();
  isLoading = input<boolean>(false);

  // << DE FIX: 'facade' is nu protected >>
  protected readonly facade = inject(AdminOrdersFacade);
  protected readonly AppIcon = AppIcon;
  protected readonly expandedOrderId = signal<string | null>(null);

toggleExpand(order: Order): void {
    const newId = this.expandedOrderId() === order.id ? null : order.id;
    this.expandedOrderId.set(newId);

    if (newId) {
      // Laad altijd de volledige order details wanneer de accordion wordt geopend
      this.facade.openOrderDetailPage(newId);
    } else {
      // Wis de geselecteerde order uit de facade wanneer de accordion wordt gesloten
      this.facade.selectOrder(null);
    }
  }

  handleUpdateStatus(orderId: string, payload: UpdateStatusPayload): void {
    this.facade.updateStatus(orderId, OrderStatus.shipped, payload.trackingNumber, payload.trackingUrl);
    this.expandedOrderId.set(null); // Sluit de accordion na update
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-orders/ui/src/lib/components/order-payment-details/order-payment-details.component.ts ---
// --- MAAK BESTAND AAN: libs/features/admin-orders/ui/src/lib/components/order-payment-details/order-payment-details.component.ts ---
/**
 * @file order-payment-details.component.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-23
 * @Description Dumb component to display order payment details.
 */
import { Component, ChangeDetectionStrategy, input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Order } from '@royal-code/features/orders/domain';

type PaymentDetails = Order['paymentDetails'];

@Component({
  selector: 'admin-order-payment-details',
  standalone: true,
  imports: [CommonModule],
  template: `
    @if (paymentDetails(); as details) {
      <div class="space-y-2 text-sm">
        <div class="flex justify-between">
          <span class="text-muted">Betaalmethode</span>
          <span class="font-medium">{{ details.methodFriendlyName }}</span>
        </div>
        <div class="flex justify-between">
          <span class="text-muted">Status</span>
          <span class="font-medium">{{ details.paymentStatus }}</span>
        </div>
        @if (details.gatewayTransactionId) {
          <div class="flex justify-between">
            <span class="text-muted">Transactie ID</span>
            <span class="font-mono text-xs">{{ details.gatewayTransactionId }}</span>
          </div>
        }
      </div>
    } @else {
      <p class="text-sm text-muted italic">Geen betaalgegevens beschikbaar.</p>
    }
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class AdminOrderPaymentDetailsComponent {
  paymentDetails = input<PaymentDetails>();
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/core/src/index.ts ---
// State Management
export * from './lib/state/admin-products.actions';
export * from './lib/state/admin-products.effects';
export * from './lib/state/admin-products.facade';
export * from './lib/state/admin-products.feature';
export * from './lib/state/admin-products.types';

// DTOs
export * from './lib/DTOs/predefined-attribute.dto';
export * from './lib/DTOs/custom-attribute-definition.dto';
export * from './lib/DTOs/display-specification-definition.dto';

export * from './lib/admin-products.providers';
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/core/src/lib/admin-products.providers.ts ---
import { EnvironmentProviders, makeEnvironmentProviders } from '@angular/core';
import { provideState } from '@ngrx/store';
import { provideEffects } from '@ngrx/effects';
import { adminProductsFeature } from './state/admin-products.feature';
import { AdminProductsEffects } from './state/admin-products.effects';
import { AdminProductApiService } from '@royal-code/features/admin-products/data-access';

export function provideAdminProductsFeature(): EnvironmentProviders {
  return makeEnvironmentProviders([
    provideState(adminProductsFeature),
    provideEffects(AdminProductsEffects),
    AdminProductApiService,
  ]);
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/core/src/lib/DTOs/custom-attribute-definition.dto.ts ---
import { AppIcon } from "@royal-code/shared/domain";

export interface CustomAttributeDefinitionDto {
  readonly id: string;
  readonly key: string;
  readonly nameKeyOrText: string;
  readonly descriptionKeyOrText: string;
  readonly valueType: 'integer' | 'boolean' | 'string' | 'decimal';
  readonly uiControlType: 'slider' | 'toggle' | 'input' | 'textarea' | 'dropdown' | 'text';
  readonly validationRulesJson: string | null; // JSON string met bv. { "min": 1, "max": 10 }
  readonly defaultValue: string;
  readonly group: string;
  readonly icon: AppIcon | string; 
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/core/src/lib/DTOs/display-specification-definition.dto.ts ---
import { AppIcon } from "@royal-code/shared/domain";

export interface DisplaySpecificationDefinitionDto {
  readonly id: string;
  readonly specKey: string;
  readonly labelKeyOrText: string;
  readonly icon: AppIcon | string;
  readonly groupKeyOrText: string;
  readonly displayOrder: number;
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/core/src/lib/DTOs/predefined-attribute.dto.ts ---
/**
 * @file predefined-attribute.dto.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-20
 * @Description Defines the DTO for predefined, selectable attribute values fetched from the backend.
 */
export interface PredefinedAttributeValueDto {
  readonly id: string;
  readonly value: string;
  readonly name: string;
  readonly displayName: string;
  readonly colorHex: string | null;
  readonly priceModifier: number | null;
}

export type PredefinedAttributesMap = Record<string, PredefinedAttributeValueDto[]>;
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/core/src/lib/state/admin-products.actions.ts ---
/**
 * @file admin-products.actions.ts
 * @Version 2.1.0 (Corrected Action Payloads)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-08
 * @Description Corrected actions for the Admin Products feature state. The `loadCategoriesSuccess`
 *              action now only carries the essential category data, leaving display logic to selectors.
 */
import { createActionGroup, emptyProps, props } from '@ngrx/store';
import { Update } from '@ngrx/entity';
import { CreateProductPayload, Product, ProductCategory, ProductFilters, UpdateProductPayload } from '@royal-code/features/products/domain';
import { PredefinedAttributesMap } from '../DTOs/predefined-attribute.dto';
import { CustomAttributeDefinitionDto } from '../DTOs/custom-attribute-definition.dto';
import { DisplaySpecificationDefinitionDto } from '../DTOs/display-specification-definition.dto';
import { ProductLookups } from '@royal-code/features/admin-products/domain';

export const AdminProductActions = createActionGroup({
  source: 'Admin Products',
    events: {
    // === PAGE LIFECYCLE & FILTERS ===
    'Admin Page Initialized': emptyProps(),
    'Ensure Form Lookups Loaded': emptyProps(),
    'Filters Changed': props<{ filters: Partial<ProductFilters> }>(),
    'Create Product API Success': props<{ productId: string }>(),
    // === READ (AGGREGATED LOOKUPS) ---
    'Load Lookups': emptyProps(),
    'Load Lookups Success': props<{ lookups: ProductLookups }>(),
    'Load Lookups Failure': props<{ error: string }>(),

    // === READ (INDIVIDUAL ACTIONS, CALLED BY EFFECTS) ===
    'Load Products': props<{ filters: Partial<ProductFilters> }>(),
    'Load Products Success': props<{ products: Product[], totalCount: number }>(),
    'Load Products Failure': props<{ error: string }>(),
    'Load Custom Attribute Definitions Success': props<{ definitions: CustomAttributeDefinitionDto[] }>(),
    'Load Predefined Attributes Success': props<{ attributes: PredefinedAttributesMap }>(),
    'Load Display Specification Definitions Success': props<{ definitions: DisplaySpecificationDefinitionDto[] }>(),

    // === DETAIL VIEW ===
    'Product Detail Page Opened': props<{ productId: string }>(),
    'Load Product Detail': props<{ productId: string }>(),
    'Load Product Detail Success': props<{ product: Product }>(),
    'Load Product Detail Failure': props<{ error: string; productId: string }>(),    'Select Product': props<{ productId: string | null }>(),

    // --- Categories ---
    'Load Categories': emptyProps(),
    // << DE FIX: Payload versimpeld. De display map wordt in een selector afgeleid. >>
    'Load Categories Success': props<{ categories: ProductCategory[] }>(),
    'Load Categories Failure': props<{ error: string }>(),


    // === CREATE ===
    'Create Product Submitted': props<{ payload: CreateProductPayload; tempId: string }>(),
    'Create Product Success': props<{ product: Product }>(),
    'Create Product Failure': props<{ error: string }>(),

    // === UPDATE ===
    'Update Product Submitted': props<{ productId: string, payload: UpdateProductPayload }>(),
    'Update Product Success': props<{ productUpdate: Update<Product> }>(),
    'Update Product Failure': props<{ error: string }>(),

    // === UPDATE STOCK ===
    'Update Stock Submitted': props<{ productId: string, newStock: number }>(),
    'Update Stock Success': props<{ productUpdate: Update<Product> }>(),
    'Update Stock Failure': props<{ error: string }>(),

    // === DELETE ===
    'Delete Product Confirmed': props<{ productId: string }>(),
    'Delete Product Success': props<{ productId: string }>(),
    'Delete Product Failure': props<{ error: string }>(),
  },
});
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/core/src/lib/state/admin-products.effects.ts ---
/**
 * @file admin-products.effects.ts
 * @Version 4.0.0 (Architecturally Correct)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-08
 * @Description Architecturally correct effects. All presentation logic has been removed.
 *              Effects are now solely responsible for API interactions and dispatching
 *              subsequent actions with raw data for the reducer to handle.
 */
import { Injectable, inject } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { of } from 'rxjs';
import {
  catchError,
  map,
  switchMap,
  tap,
  exhaustMap,
  withLatestFrom,
  filter,
  debounceTime,
  distinctUntilChanged,
  startWith
} from 'rxjs/operators';
import { AdminProductActions } from './admin-products.actions';
import { AdminProductApiService } from '@royal-code/features/admin-products/data-access';
import { ProductMappingService } from '@royal-code/features/products/core';
import { Router } from '@angular/router';
import { NotificationService } from '@royal-code/ui/notifications';
import { Update } from '@ngrx/entity';
import { isPhysicalProduct, Product } from '@royal-code/features/products/domain';
import { HttpErrorResponse } from '@angular/common/http';
import { LoggerService } from 'libs/core/core-logging/src/lib/logger.service';
import { Media } from '@royal-code/shared/domain';
import { Store } from '@ngrx/store';
import { MediaActions } from '@royal-code/features/media/core';
import { adminProductsFeature } from './admin-products.feature';

@Injectable()
export class AdminProductsEffects {
  private readonly actions$ = inject(Actions);
  private readonly apiService = inject(AdminProductApiService);
  private readonly mappingService = inject(ProductMappingService);
  private readonly router = inject(Router);
  private readonly notificationService = inject(NotificationService);
  private readonly logger = inject(LoggerService);
  private readonly store = inject(Store);
  private readonly logPrefix = '[AdminProductsEffects]';

  initPageOrEnsureLookups$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminProductActions.adminPageInitialized, AdminProductActions.ensureFormLookupsLoaded),
      withLatestFrom(
        this.store.select(adminProductsFeature.selectPredefinedAttributes),
        this.store.select(adminProductsFeature.selectAllCategories),
        this.store.select(adminProductsFeature.selectIsDataStale)
      ),
      filter(([, attributes, categories, isStale]) => {
        const needsAttributes = attributes === null;
        const needsCategories = categories === undefined || categories === null || categories.length === 0;
        const shouldRefresh = isStale && (needsAttributes || needsCategories);
        return needsAttributes || needsCategories || shouldRefresh;
      }),
      tap(() => this.logger.debug(`${this.logPrefix} Loading missing or stale lookup data`)),
      switchMap(() => [
        AdminProductActions.loadLookups(),
        AdminProductActions.loadCategories()
      ])
    )
  );

  loadLookups$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminProductActions.loadLookups),
      tap(() => this.logger.debug(`${this.logPrefix} Loading all lookups in batch`)),
      switchMap(() =>
        this.apiService.getLookups().pipe(
          tap(lookups => this.logger.debug(`${this.logPrefix} Received lookups:`, {
            attributeCount: Object.keys(lookups.variantAttributes || {}).length,
            customAttrCount: lookups.customAttributes?.length || 0,
            displaySpecCount: lookups.displaySpecifications?.length || 0
          })),
          map(lookups => AdminProductActions.loadLookupsSuccess({ lookups })),
          catchError(error => {
            this.logger.error(`${this.logPrefix} Failed to load lookups:`, error);
            return of(AdminProductActions.loadLookupsFailure({ error: error.message }));
          })
        )
      )
    )
  );

  unpackLookups$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminProductActions.loadLookupsSuccess),
      tap(() => this.logger.debug(`${this.logPrefix} Unpacking lookups`)),
      switchMap(({ lookups }) => [
        AdminProductActions.loadPredefinedAttributesSuccess({ attributes: lookups.variantAttributes }),
        AdminProductActions.loadCustomAttributeDefinitionsSuccess({ definitions: lookups.customAttributes }),
        AdminProductActions.loadDisplaySpecificationDefinitionsSuccess({ definitions: lookups.displaySpecifications })
      ])
    )
  );

  // << DE FIX: Verwijdering van alle presentatie-logica. De effect haalt alleen de data op. >>
  loadCategories$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminProductActions.loadCategories),
      tap(() => this.logger.debug(`${this.logPrefix} Loading categories`)),
      switchMap(() =>
        this.apiService.getCategories().pipe(
          tap(categories => this.logger.debug(`${this.logPrefix} Received ${categories.length} categories`)),
          map(categories => AdminProductActions.loadCategoriesSuccess({ categories })),
          catchError(error => {
            this.logger.error(`${this.logPrefix} Failed to load categories:`, error);
            return of(AdminProductActions.loadCategoriesFailure({ error: error.message }));
          })
        )
      )
    )
  );

  triggerLoadProducts$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminProductActions.adminPageInitialized, AdminProductActions.filtersChanged),
      startWith(null),
      debounceTime(300),
      distinctUntilChanged((prev, curr) => {
        if (!prev || !curr) return false;
        if (prev.type !== curr.type) return false;
        const prevFilters = prev.type === AdminProductActions.filtersChanged.type ? prev.filters : {};
        const currFilters = curr.type === AdminProductActions.filtersChanged.type ? curr.filters : {};
        return JSON.stringify(prevFilters) === JSON.stringify(currFilters);
      }),
      map(action => {
        const filters = action?.type === AdminProductActions.filtersChanged.type ? action.filters : {};
        this.logger.debug(`${this.logPrefix} Triggering product load with filters:`, filters);
        return AdminProductActions.loadProducts({ filters });
      })
    )
  );

  loadProducts$ = createEffect(() =>
  this.actions$.pipe(
    ofType(AdminProductActions.loadProducts),
    switchMap(({ filters }) => {
      const finalFilters = { page: 1, pageSize: 20, ...filters };
      return this.apiService.getProducts(finalFilters).pipe(
        map(response => {
          const mappedProducts = response.items.map(dto => this.mappingService.mapListItemToProduct(dto));
          return AdminProductActions.loadProductsSuccess({ products: mappedProducts, totalCount: response.totalCount });
        }),
        catchError(error => of(AdminProductActions.loadProductsFailure({ error: error.message })))
      );
    })
  )
);

  triggerLoadDetail$ = createEffect(() =>
  this.actions$.pipe(
    ofType(AdminProductActions.productDetailPageOpened),
    map(({ productId }) => AdminProductActions.loadProductDetail({ productId }))
  )
);

loadDetail$ = createEffect(() =>
  this.actions$.pipe(
    ofType(AdminProductActions.loadProductDetail),
    switchMap(({ productId }) =>
      this.apiService.getProductById(productId).pipe(
        map(dto => {
          const productDetail = this.mappingService.mapProductDetail(dto);
          return AdminProductActions.loadProductDetailSuccess({ product: productDetail });
        }),
        catchError(err => of(AdminProductActions.loadProductDetailFailure({ error: err.message, productId: productId })))
      )
    )
  )
);

  createProduct$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminProductActions.createProductSubmitted),
      tap(({ payload }) => this.logger.info(`${this.logPrefix} Creating product:`, payload.name)),
      exhaustMap(({ payload }) =>
        this.apiService.createProduct(payload).pipe(
          map(responseDto => {
            const newProduct = this.mappingService.mapProductDetail(responseDto);
            this.logger.info(`${this.logPrefix} Product created successfully:`, newProduct.id);
            return AdminProductActions.createProductSuccess({ product: newProduct });
          }),
          catchError(error => {
            this.logger.error(`${this.logPrefix} Failed to create product:`, error);
            return of(AdminProductActions.createProductFailure({ error: error.message }));
          })
        )
      )
    )
  );

  createProductSuccess$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminProductActions.createProductSuccess),
      tap(({ product }) => {
        if (product && product.id) {
          this.notificationService.showSuccess('Product succesvol aangemaakt!');
          this.router.navigate(['/products', product.id]);
        } else {
          this.logger.error(`${this.logPrefix} Product creation succeeded but no ID returned`);
          this.notificationService.showError('Product aangemaakt, maar kon niet navigeren');
          this.router.navigate(['/products']);
        }
      })
    ), { dispatch: false }
  );

  updateProduct$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminProductActions.updateProductSubmitted),
      tap(({ productId, payload }) => this.logger.info(`${this.logPrefix} Updating product: ${productId}`)),
      exhaustMap(({ productId, payload }) =>
        this.apiService.updateProduct(productId, payload).pipe(
          map(responseDto => {
            const updatedProduct = this.mappingService.mapProductDetail(responseDto);
            const allProductMedia: Media[] = [];
            if (updatedProduct.media) { allProductMedia.push(...updatedProduct.media); }
            updatedProduct.variantAttributes?.forEach(attr => { attr.values.forEach(val => { if (val.media) { allProductMedia.push(...val.media); } }); });
            if (allProductMedia.length > 0) { this.store.dispatch(MediaActions.mediaLoadedFromSource({ media: allProductMedia })); }
            const productUpdate: Update<Product> = { id: productId, changes: updatedProduct };
            this.logger.info(`${this.logPrefix} Product updated successfully: ${productId}`);
            return AdminProductActions.updateProductSuccess({ productUpdate });
          }),
          catchError(error => {
            this.logger.error(`${this.logPrefix} Failed to update product ${productId}:`, error);
            if (error instanceof HttpErrorResponse && error.status === 409) {
              const errorMessage = 'SKU bestaat al – pas aan of verwijder duplicaat.';
              this.notificationService.showError(errorMessage);
              return of(AdminProductActions.updateProductFailure({ error: errorMessage }));
            }
            return of(AdminProductActions.updateProductFailure({ error: error.message || 'Onbekende updatefout' }));
          })
        )
      )
    )
  );

  updateProductSuccess$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminProductActions.updateProductSuccess),
      tap(() => this.notificationService.showSuccess('Product succesvol bijgewerkt!'))
    ), { dispatch: false }
  );

  deleteProduct$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminProductActions.deleteProductConfirmed),
      tap(({ productId }) => this.logger.info(`${this.logPrefix} Deleting product: ${productId}`)),
      exhaustMap(({ productId }) =>
        this.apiService.deleteProduct(productId).pipe(
          map(() => {
            this.logger.info(`${this.logPrefix} Product deleted successfully: ${productId}`);
            return AdminProductActions.deleteProductSuccess({ productId });
          }),
          catchError(error => {
            this.logger.error(`${this.logPrefix} Failed to delete product ${productId}:`, error);
            return of(AdminProductActions.deleteProductFailure({ error: error.message }));
          })
        )
      )
    )
  );

  deleteProductSuccess$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminProductActions.deleteProductSuccess),
      tap(() => this.notificationService.showSuccess('Product succesvol verwijderd!'))
    ), { dispatch: false }
  );

  updateStock$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminProductActions.updateStockSubmitted),
      tap(({ productId, newStock }) => this.logger.info(`${this.logPrefix} Updating stock for ${productId}: ${newStock}`)),
      exhaustMap(({ productId, newStock }) =>
        this.apiService.updatePhysicalStock(
          productId, undefined, newStock, 'Admin Panel Update', 'placeholder-user-id'
        ).pipe(
          map(responseDto => {
            const updatedProduct = this.mappingService.mapProductDetail(responseDto);
            const changes: Partial<Product> = {};
            if (isPhysicalProduct(updatedProduct)) {
              changes.stockQuantity = updatedProduct.stockQuantity;
              changes.stockStatus = updatedProduct.stockStatus;
            }
            const productUpdate: Update<Product> = { id: productId, changes };
            this.logger.info(`${this.logPrefix} Stock updated successfully for: ${productId}`);
            return AdminProductActions.updateStockSuccess({ productUpdate });
          }),
          catchError(error => {
            this.logger.error(`${this.logPrefix} Failed to update stock for ${productId}:`, error);
            return of(AdminProductActions.updateStockFailure({ error: error.message }));
          })
        )
      )
    )
  );

  updateStockSuccess$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminProductActions.updateStockSuccess),
      tap(() => this.notificationService.showSuccess('Voorraad succesvol bijgewerkt!'))
    ), { dispatch: false }
  );

  operationFailure$ = createEffect(() =>
    this.actions$.pipe(
      ofType(
        AdminProductActions.createProductFailure, AdminProductActions.updateProductFailure,
        AdminProductActions.deleteProductFailure, AdminProductActions.updateStockFailure,
        AdminProductActions.loadLookupsFailure, AdminProductActions.loadProductsFailure,
        AdminProductActions.loadProductDetailFailure, AdminProductActions.loadCategoriesFailure
      ),
      tap(({ error }) => {
        this.logger.error(`${this.logPrefix} Operation failed:`, error);
        this.notificationService.showError(`Operatie mislukt: ${error}`);
      })
    ), { dispatch: false }
  );
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/core/src/lib/state/admin-products.facade.ts ---
/**
 * @file admin-products.facade.ts
 * @Version 7.1.0 (Definitive Type Safety Fixes)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-08
 * @Description Definitive facade with corrected type safety for the ViewModel,
 *              resolving `undefined` and `readonly` assignment issues.
 */
import { Injectable, Signal, inject } from '@angular/core';
import { toSignal } from '@angular/core/rxjs-interop';
import { Store } from '@ngrx/store';
import { adminProductsFeature } from './admin-products.feature';
import { AdminProductActions } from './admin-products.actions';
import { CreateProductPayload, ProductFilters, UpdateProductPayload } from '@royal-code/features/products/domain';
import { AdminProductListViewModel } from './admin-products.types';

@Injectable({ providedIn: 'root' })
export class AdminProductsFacade {
  private readonly store = inject(Store);

  // << DE FIX: De cast `as AdminProductListViewModel` is niet langer nodig, omdat de types nu matchen. >>
  readonly viewModel: Signal<AdminProductListViewModel> = toSignal(
      this.store.select(adminProductsFeature.selectViewModel),
      { initialValue: this.createInitialViewModel() }
  );

  initPage(): void { this.store.dispatch(AdminProductActions.adminPageInitialized()); }
  ensureFormLookupsLoaded(): void { this.store.dispatch(AdminProductActions.ensureFormLookupsLoaded()); }
  changeFilters(filters: Partial<ProductFilters>): void { this.store.dispatch(AdminProductActions.filtersChanged({ filters })); }
  openProductDetailPage(productId: string): void { this.store.dispatch(AdminProductActions.productDetailPageOpened({ productId })); }
  selectProduct(productId: string | null): void { this.store.dispatch(AdminProductActions.selectProduct({ productId })); }
  createProduct(payload: CreateProductPayload): void { const tempId = `temp_${Date.now()}`; this.store.dispatch(AdminProductActions.createProductSubmitted({ payload, tempId })); }
  updateProduct(productId: string, payload: UpdateProductPayload): void { this.store.dispatch(AdminProductActions.updateProductSubmitted({ productId, payload })); }
  deleteProduct(productId: string): void { this.store.dispatch(AdminProductActions.deleteProductConfirmed({ productId })); }

  private createInitialViewModel(): AdminProductListViewModel {
    return {
      products: [],
      totalCount: 0,
      isLoading: true,
      isSubmitting: false,
      error: null,
      filters: {},
      predefinedAttributes: null,
      isLoadingAttributes: true,
      attributeNames: [],
      customAttributeDefinitions: [],
      isLoadingCustomAttributeDefinitions: true,
      displaySpecificationDefinitions: [],
      isLoadingDisplaySpecificationDefinitions: true,
      selectedProduct: undefined,
      allCategories: [],
      isLoadingCategories: true,
      categoryDisplayMap: new Map()
    };
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/core/src/lib/state/admin-products.feature.ts ---
/**
 * @file admin-products.feature.ts
 * @Version 6.0.0 (Definitive Readonly Fix)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-08
 * @Description Definitive feature definition. All selectors now correctly return
 *              `readonly` arrays where appropriate, ensuring full type compatibility
 *              with the ViewModel and facade.
 */
import { createFeature, createReducer, on, createSelector } from '@ngrx/store';
import { createEntityAdapter, EntityAdapter, EntityState } from '@ngrx/entity';
import { Product, ProductCategory, ProductFilters } from '@royal-code/features/products/domain';
import { AdminProductActions } from './admin-products.actions';
import { PredefinedAttributesMap } from '../DTOs/predefined-attribute.dto';
import { CustomAttributeDefinitionDto } from '../DTOs/custom-attribute-definition.dto';
import { DisplaySpecificationDefinitionDto } from '../DTOs/display-specification-definition.dto';
import { AuthActions } from 'libs/store/auth/src/lib/state/auth.actions';
import { AdminProductListViewModel } from './admin-products.types';

// === STATE INTERFACE ===
export interface AdminProductsState extends EntityState<Product> {
  totalCount: number;
  isLoading: boolean;
  isSubmitting: boolean;
  error: string | null;
  filters: Partial<ProductFilters>;
  selectedProductId: string | null;
  predefinedAttributes: PredefinedAttributesMap | null;
  isLoadingAttributes: boolean;
  customAttributeDefinitions: readonly CustomAttributeDefinitionDto[];
  isLoadingCustomAttributeDefinitions: boolean;
  displaySpecificationDefinitions: readonly DisplaySpecificationDefinitionDto[];
  isLoadingDisplaySpecificationDefinitions: boolean;
  allCategories: readonly ProductCategory[];
  isLoadingCategories: boolean;
  lastUpdated: number;
}

// === ENTITY ADAPTER ===
export const adminProductAdapter: EntityAdapter<Product> = createEntityAdapter<Product>({
  sortComparer: (a: Product, b: Product) => (b.lastModified?.timestamp ?? 0) - (a.lastModified?.timestamp ?? 0)
});

// === INITIAL STATE ===
export const initialAdminProductsState: AdminProductsState = adminProductAdapter.getInitialState({
  totalCount: 0,
  isLoading: true,
  isSubmitting: false,
  error: null,
  filters: {},
  selectedProductId: null,
  predefinedAttributes: null,
  isLoadingAttributes: false,
  customAttributeDefinitions: [],
  isLoadingCustomAttributeDefinitions: false,
  displaySpecificationDefinitions: [],
  isLoadingDisplaySpecificationDefinitions: false,
  allCategories: [],
  isLoadingCategories: false,
  lastUpdated: 0,
});

// === HELPER FUNCTION (voor selectors) ===
const getDisplayNameFromKey = (key: string): string => {
  const parts = key.split('.');
  const lastPart = parts[parts.length - 1];
  return lastPart.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).trim();
};

// === FEATURE (REDUCER & SELECTORS) ===
export const adminProductsFeature = createFeature({
  name: 'adminProducts',
  reducer: createReducer(
    initialAdminProductsState,
    on(AuthActions.logoutCompleted, () => initialAdminProductsState),
    on(AdminProductActions.adminPageInitialized, (state) => ({ ...state, isLoading: true, error: null, lastUpdated: Date.now() })),
    on(AdminProductActions.filtersChanged, (state, { filters }) => ({ ...state, filters: { ...state.filters, ...filters, page: 1 }, isLoading: true, error: null, lastUpdated: Date.now() })),
    on(AdminProductActions.loadProducts, (state, { filters }) => ({ ...state, isLoading: true, filters: { ...state.filters, ...filters }, lastUpdated: Date.now() })),
    on(AdminProductActions.loadProductsSuccess, (state, { products, totalCount }) => {
        const selectedId = state.selectedProductId;
        const currentDetailedProduct = selectedId ? state.entities[selectedId] : undefined;
        let newState = adminProductAdapter.upsertMany(products, { ...state, totalCount, isLoading: false, lastUpdated: Date.now() });
        if (currentDetailedProduct && products.some(p => p.id === currentDetailedProduct.id) && (currentDetailedProduct.variantCombinations?.length ?? 0) > 0) {
            const listVersion = products.find(p => p.id === currentDetailedProduct.id);
            if (!listVersion?.variantCombinations?.length) { newState = adminProductAdapter.upsertOne(currentDetailedProduct, newState); }
        }
        return newState;
    }),
    on(AdminProductActions.loadProductsFailure, (state, { error }) => ({ ...state, isLoading: false, error, lastUpdated: Date.now() })),
    on(AdminProductActions.loadLookups, (state) => ({ ...state, isLoadingAttributes: true, isLoadingCustomAttributeDefinitions: true, isLoadingDisplaySpecificationDefinitions: true, error: null })),
    on(AdminProductActions.loadLookupsFailure, (state, { error }) => ({ ...state, isLoadingAttributes: false, isLoadingCustomAttributeDefinitions: false, isLoadingDisplaySpecificationDefinitions: false, error: `Failed to load form lookups: ${error}` })),
    on(AdminProductActions.loadPredefinedAttributesSuccess, (state, { attributes }) => ({ ...state, predefinedAttributes: attributes, isLoadingAttributes: false })),
    on(AdminProductActions.loadCustomAttributeDefinitionsSuccess, (state, { definitions }) => ({ ...state, customAttributeDefinitions: definitions, isLoadingCustomAttributeDefinitions: false })),
    on(AdminProductActions.loadDisplaySpecificationDefinitionsSuccess, (state, { definitions }) => ({ ...state, displaySpecificationDefinitions: definitions, isLoadingDisplaySpecificationDefinitions: false })),
    on(AdminProductActions.productDetailPageOpened, (state, { productId }) => ({ ...state, isLoading: true, error: null, selectedProductId: productId })),
    on(AdminProductActions.loadProductDetailSuccess, (state, { product }) => adminProductAdapter.upsertOne(product, { ...state, isLoading: false, selectedProductId: product.id, error: null, lastUpdated: Date.now() })),
    on(AdminProductActions.loadProductDetailFailure, (state, { error }) => ({ ...state, isLoading: false, error, lastUpdated: Date.now() })),
    on(AdminProductActions.selectProduct, (state, { productId }) => {
      const hasProduct = productId && state.entities[productId];
      const hasDetailData = hasProduct && state.entities[productId]?.variantCombinations && state.entities[productId]!.variantCombinations!.length > 0;
      return { ...state, selectedProductId: productId, isLoading: hasDetailData ? false : state.isLoading, error: hasDetailData ? null : state.error };
    }),
    on(AdminProductActions.loadCategories, (state) => ({ ...state, isLoadingCategories: true })),
    on(AdminProductActions.loadCategoriesSuccess, (state, { categories }) => ({ ...state, allCategories: categories, isLoadingCategories: false })),
    on(AdminProductActions.loadCategoriesFailure, (state, { error }) => ({ ...state, error: `Failed to load categories: ${error}`, isLoadingCategories: false })),
    on(AdminProductActions.createProductSubmitted, (state) => ({ ...state, isSubmitting: true, error: null })),
    on(AdminProductActions.createProductSuccess, (state, { product }) => {
        if (!product?.id) { return { ...state, isSubmitting: false, error: 'Received product without ID after creation.' }; }
        return adminProductAdapter.addOne(product, { ...state, isSubmitting: false, totalCount: state.totalCount + 1, selectedProductId: product.id, lastUpdated: Date.now() });
    }),
    on(AdminProductActions.createProductFailure, (state, { error }) => ({ ...state, isSubmitting: false, error })),
    on(AdminProductActions.updateProductSubmitted, (state) => ({ ...state, isSubmitting: true, error: null })),
    on(AdminProductActions.updateProductSuccess, (state, { productUpdate }) => adminProductAdapter.updateOne(productUpdate, { ...state, isSubmitting: false, lastUpdated: Date.now() })),
    on(AdminProductActions.updateProductFailure, (state, { error }) => ({ ...state, isSubmitting: false, error })),
    on(AdminProductActions.updateStockSuccess, (state, { productUpdate }) => adminProductAdapter.updateOne(productUpdate, { ...state, isSubmitting: false, lastUpdated: Date.now() })),
    on(AdminProductActions.deleteProductSuccess, (state, { productId }) => adminProductAdapter.removeOne(productId, { ...state, isSubmitting: false, totalCount: state.totalCount - 1, selectedProductId: state.selectedProductId === productId ? null : state.selectedProductId, lastUpdated: Date.now() }))
  ),
  extraSelectors: ({ selectAdminProductsState, selectPredefinedAttributes, selectSelectedProductId, selectEntities, selectAllCategories, selectLastUpdated }) => {
    const { selectAll } = adminProductAdapter.getSelectors(selectAdminProductsState);
    const selectSelectedProduct = createSelector(selectEntities, selectSelectedProductId, (entities, selectedId) => (selectedId ? entities[selectedId] : undefined));
    const selectAttributeNames = createSelector(selectPredefinedAttributes, (attributes) => (attributes ? Object.keys(attributes) : []));
    const selectIsDataStale = createSelector(selectLastUpdated, (lastUpdated) => { const fiveMinutesAgo = Date.now() - (5 * 60 * 1000); return lastUpdated < fiveMinutesAgo; });

    const selectCategoriesWithDisplayNames = createSelector(
      selectAllCategories,
      (categories): readonly ProductCategory[] => { // << DE FIX: retourneert nu readonly
        const transformCategory = (cat: ProductCategory): ProductCategory => ({
          ...cat,
          name: getDisplayNameFromKey(cat.key),
          children: cat.children ? cat.children.map(transformCategory) : [],
        });
        return categories.map(transformCategory);
      }
    );

    const selectCategoryDisplayMap = createSelector(
      selectAllCategories,
      (categories): Map<string, string> => {
        const displayMap = new Map<string, string>();
        const processCategory = (cat: ProductCategory) => {
          displayMap.set(cat.id, getDisplayNameFromKey(cat.key));
          if (cat.children) { cat.children.forEach(processCategory); }
        };
        categories.forEach(processCategory);
        return displayMap;
      }
    );

    const selectViewModel = createSelector(
        selectAll,
        selectAdminProductsState,
        selectSelectedProduct,
        selectAttributeNames,
        selectCategoriesWithDisplayNames,
        selectCategoryDisplayMap,
        (products, state, selectedProduct, attributeNames, allCategories, categoryDisplayMap): AdminProductListViewModel => ({
            products,
            selectedProduct,
            attributeNames,
            allCategories,
            categoryDisplayMap,
            isLoading: state.isLoading,
            isSubmitting: state.isSubmitting,
            error: state.error,
            filters: state.filters,
            totalCount: state.totalCount,
            predefinedAttributes: state.predefinedAttributes,
            isLoadingAttributes: state.isLoadingAttributes,
            customAttributeDefinitions: state.customAttributeDefinitions,
            isLoadingCustomAttributeDefinitions: state.isLoadingCustomAttributeDefinitions,
            displaySpecificationDefinitions: state.displaySpecificationDefinitions,
            isLoadingDisplaySpecificationDefinitions: state.isLoadingDisplaySpecificationDefinitions,
            isLoadingCategories: state.isLoadingCategories,
        })
    );

    return {
      selectAll, selectEntities, selectSelectedProduct, selectAttributeNames, selectIsDataStale,
      selectCategoryDisplayMap,
      selectViewModel,
      selectAllCategories: selectCategoriesWithDisplayNames
    };
  }
});

export const {
  name, reducer, selectAdminProductsState, selectTotalCount, selectIsLoading,
  selectIsSubmitting, selectError, selectFilters, selectPredefinedAttributes,
  selectIsLoadingAttributes, selectCustomAttributeDefinitions, selectIsLoadingCustomAttributeDefinitions,
  selectAttributeNames, selectDisplaySpecificationDefinitions, selectIsLoadingDisplaySpecificationDefinitions,
  selectSelectedProduct, selectAllCategories, selectIsLoadingCategories, selectIsDataStale,
  selectCategoryDisplayMap, selectViewModel
} = adminProductsFeature;
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/core/src/lib/state/admin-products.types.ts ---
/**
 * @file admin-products.types.ts
 * @Version 1.7.0 (Definitive Readonly Fix)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-08
 * @Description Definitive type definitions. All array properties in the ViewModel are now
 *              correctly marked as `readonly` to ensure full type compatibility with NgRx state.
 */
import { Product, ProductCategory, ProductFilters } from '@royal-code/features/products/domain';
import { PredefinedAttributesMap } from '../DTOs/predefined-attribute.dto';
import { CustomAttributeDefinitionDto } from '../DTOs/custom-attribute-definition.dto';
import { DisplaySpecificationDefinitionDto } from '../DTOs/display-specification-definition.dto';

export interface AdminProductListViewModel {
  readonly products: readonly Product[];
  readonly isLoading: boolean;
  readonly isSubmitting: boolean;
  readonly error: string | null;
  readonly filters: Partial<ProductFilters>;
  readonly totalCount: number;
  readonly predefinedAttributes: PredefinedAttributesMap | null;
  readonly isLoadingAttributes: boolean;
  readonly attributeNames: readonly string[];
  readonly customAttributeDefinitions: readonly CustomAttributeDefinitionDto[];
  readonly isLoadingCustomAttributeDefinitions: boolean;
  readonly displaySpecificationDefinitions: readonly DisplaySpecificationDefinitionDto[];
  readonly isLoadingDisplaySpecificationDefinitions: boolean;
  readonly selectedProduct: Product | undefined;
  readonly isLoadingCategories: boolean;
  readonly allCategories: readonly ProductCategory[];
  readonly categoryDisplayMap?: Map<string, string>;
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/core/src/lib/state/type-safe-helpers.ts ---
/**
 * @file type-safe-helpers.ts
 * @Version 1.0.0 (NEW - TYPE SAFETY IMPROVEMENTS)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-04  
 * @Description Type-safe helpers and error handling for the product form
 */

// === TYPE GUARDS ===
export function isValidProductPayload(payload: any): payload is CreateProductPayload | UpdateProductPayload {
  return payload && 
         typeof payload.name === 'string' && 
         payload.name.trim().length > 0 &&
         typeof payload.type === 'string';
}

export function isValidVariantOverride(override: any): override is CreateVariantOverrideDto {
  return override && 
         Array.isArray(override.tempAttributeValueIds) &&
         override.tempAttributeValueIds.length > 0 &&
         typeof override.price === 'number' &&
         override.price > 0;
}

export function hasValidVariantAttributes(attributes: any[]): boolean {
  return attributes.every(attr => 
    attr.tempId && 
    attr.nameKeyOrText && 
    Array.isArray(attr.values) && 
    attr.values.length > 0
  );
}

// === VALIDATION HELPERS ===
export class ProductFormValidator {
  static validatePayloadBeforeSubmit(payload: CreateProductPayload | UpdateProductPayload): ValidationResult {
    const errors: string[] = [];
    
    // Basic validation
    if (!payload.name?.trim()) {
      errors.push('Product name is required');
    }
    
    if (payload.name && payload.name.length > 255) {
      errors.push('Product name must be less than 255 characters');
    }
    
    // Variant validation
    if (payload.variantAttributes && payload.variantAttributes.length > 0) {
      if (!hasValidVariantAttributes(payload.variantAttributes)) {
        errors.push('All variant attributes must have valid names and values');
      }
      
      // Check for duplicate attribute names
      const attributeNames = payload.variantAttributes.map(a => a.nameKeyOrText);
      const duplicates = attributeNames.filter((name, index) => attributeNames.indexOf(name) !== index);
      if (duplicates.length > 0) {
        errors.push(`Duplicate attribute names found: ${duplicates.join(', ')}`);
      }
    }
    
    // Variant overrides validation
    if (payload.variantOverrides && payload.variantOverrides.length > 0) {
      const invalidOverrides = payload.variantOverrides.filter(o => !isValidVariantOverride(o));
      if (invalidOverrides.length > 0) {
        errors.push(`${invalidOverrides.length} variant override(s) have invalid data`);
      }
      
      // Check for duplicate SKUs
      const skus = payload.variantOverrides.map(o => o.sku).filter(Boolean);
      const duplicateSkus = skus.filter((sku, index) => skus.indexOf(sku) !== index);
      if (duplicateSkus.length > 0) {
        errors.push(`Duplicate SKUs found: ${duplicateSkus.join(', ')}`);
      }
      
      // Ensure at least one default variant
      const hasDefault = payload.variantOverrides.some(o => o.isDefault);
      if (!hasDefault) {
        errors.push('At least one variant must be set as default');
      }
    }
    
    // Physical product validation
    if (payload.physicalProductConfig) {
      const config = payload.physicalProductConfig;
      
      if (config.pricing) {
        if (!config.pricing.price || config.pricing.price <= 0) {
          errors.push('Product price must be greater than 0');
        }
        
        if (config.pricing.originalPrice && config.pricing.originalPrice < config.pricing.price) {
          errors.push('Original price cannot be lower than sale price');
        }
      }
      
      if (config.manageStock && (!payload.variantOverrides || payload.variantOverrides.length === 0)) {
        if (!config.stockQuantity || config.stockQuantity < 0) {
          errors.push('Stock quantity is required when managing stock');
        }
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  
  static validateVariantCombination(combination: any, index: number): ValidationResult {
    const errors: string[] = [];
    const prefix = `Variant ${index + 1}:`;
    
    if (!combination.sku?.trim()) {
      errors.push(`${prefix} SKU is required`);
    }
    
    if (!combination.price || combination.price <= 0) {
      errors.push(`${prefix} Price must be greater than 0`);
    }
    
    if (combination.originalPrice && combination.originalPrice < combination.price) {
      errors.push(`${prefix} Original price cannot be lower than sale price`);
    }
    
    if (!combination.attributes || !Array.isArray(combination.attributes) || combination.attributes.length === 0) {
      errors.push(`${prefix} Must have at least one attribute assignment`);
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

// === ERROR HANDLING HELPERS ===
export class ProductFormErrorHandler {
  static handleApiError(error: any, context: string): string {
    console.error(`[ProductForm] API Error in ${context}:`, error);
    
    if (error?.status === 400) {
      if (error.error?.errors) {
        // Validation errors from backend
        const validationErrors = Object.values(error.error.errors).flat();
        return `Validation failed: ${validationErrors.join(', ')}`;
      }
      return error.error?.message || 'Invalid request data';
    }
    
    if (error?.status === 409) {
      return error.error?.message || 'Conflict: Resource already exists or has been modified';
    }
    
    if (error?.status === 422) {
      return error.error?.message || 'Business rule validation failed';
    }
    
    if (error?.status >= 500) {
      return 'Server error. Please try again later.';
    }
    
    return error?.message || 'An unexpected error occurred';
  }
  
  static extractValidationErrors(error: any): Record<string, string[]> {
    const errors: Record<string, string[]> = {};
    
    if (error?.error?.errors) {
      return error.error.errors;
    }
    
    if (error?.error?.message) {
      errors['general'] = [error.error.message];
    }
    
    return errors;
  }
}

// === SAFE CONVERSION HELPERS ===
export class SafeConverters {
  static toNumber(value: any, fallback: number = 0): number {
    const num = Number(value);
    return isNaN(num) ? fallback : num;
  }
  
  static toPositiveNumber(value: any, fallback: number = 0): number {
    const num = this.toNumber(value, fallback);
    return Math.max(0, num);
  }
  
  static toString(value: any, fallback: string = ''): string {
    return value != null ? String(value).trim() : fallback;
  }
  
  static toArray<T>(value: any, fallback: T[] = []): T[] {
    return Array.isArray(value) ? value : fallback;
  }
  
  static toNullableArray<T>(value: any): T[] | null {
    return Array.isArray(value) && value.length > 0 ? value : null;
  }
  
  static toBoolean(value: any, fallback: boolean = false): boolean {
    if (typeof value === 'boolean') return value;
    if (typeof value === 'string') return value.toLowerCase() === 'true';
    if (typeof value === 'number') return value !== 0;
    return fallback;
  }
}

// === FORM UTILITIES ===
export class FormUtils {
  static markFormGroupTouched(formGroup: AbstractControl): void {
    Object.keys(formGroup.controls || {}).forEach(key => {
      const control = formGroup.get(key);
      if (control) {
        control.markAsTouched();
        if (control instanceof FormGroup || control instanceof FormArray) {
          this.markFormGroupTouched(control);
        }
      }
    });
  }
  
  static findFormErrors(formGroup: AbstractControl, errors: any[] = [], prefix: string = ''): any[] {
    Object.keys(formGroup.controls || {}).forEach(key => {
      const control = formGroup.get(key);
      const fieldName = prefix ? `${prefix}.${key}` : key;
      
      if (control && control.errors) {
        Object.keys(control.errors).forEach(errorKey => {
          errors.push({
            field: fieldName,
            error: errorKey,
            message: this.getErrorMessage(errorKey, fieldName)
          });
        });
      }
      
      if (control instanceof FormGroup || control instanceof FormArray) {
        this.findFormErrors(control, errors, fieldName);
      }
    });
    
    return errors;
  }
  
  private static getErrorMessage(errorKey: string, fieldName: string): string {
    const fieldDisplayName = fieldName.split('.').pop() || fieldName;
    
    switch (errorKey) {
      case 'required':
        return `${fieldDisplayName} is required`;
      case 'email':
        return `${fieldDisplayName} must be a valid email`;
      case 'min':
        return `${fieldDisplayName} is too small`;
      case 'max':
        return `${fieldDisplayName} is too large`;
      case 'pattern':
        return `${fieldDisplayName} has invalid format`;
      default:
        return `${fieldDisplayName} is invalid`;
    }
  }
}

// === TYPES ===
interface ValidationResult {
  isValid: boolean;
  errors: string[];
}

// Usage in ProductFormComponent:
/*
// Add to your component:

import { 
  ProductFormValidator, 
  ProductFormErrorHandler, 
  SafeConverters, 
  FormUtils 
} from './type-safe-helpers';

export class ProductFormComponent {
  
  onSave(): void {
    FormUtils.markFormGroupTouched(this.productForm);
    
    if (this.productForm.invalid) {
      const errors = FormUtils.findFormErrors(this.productForm);
      console.error('Form validation errors:', errors);
      this.showValidationErrors();
      return;
    }

    const payload = this.mapFormToPayload();
    
    // Pre-submit validation
    const validation = ProductFormValidator.validatePayloadBeforeSubmit(payload);
    if (!validation.isValid) {
      this.notificationService.showError(`Validation failed: ${validation.errors.join(', ')}`);
      return;
    }
    
    this.saveProduct.emit(payload);
  }

  private mapFormToPayload(): CreateProductPayload | UpdateProductPayload {
    const formValue = this.productForm.getRawValue();
    
    // Use safe converters
    const payload = {
      ...formValue,
      name: SafeConverters.toString(formValue.name),
      price: SafeConverters.toPositiveNumber(formValue.physicalProductConfig?.pricing?.price),
      stockQuantity: SafeConverters.toNumber(formValue.physicalProductConfig?.stockQuantity),
      tags: SafeConverters.toNullableArray(formValue.tags),
      variantOverrides: SafeConverters.toArray(formValue.variantCombinations).map(combo => ({
        tempAttributeValueIds: SafeConverters.toArray(combo.attributes?.map(a => a.attributeValueId)),
        price: SafeConverters.toPositiveNumber(combo.price),
        stockQuantity: SafeConverters.toNumber(combo.stockQuantity),
        isDefault: SafeConverters.toBoolean(combo.isDefault),
        isActive: SafeConverters.toBoolean(combo.isActive, true),
        sku: SafeConverters.toString(combo.sku)
      }))
    };
    
    return payload as CreateProductPayload | UpdateProductPayload;
  }
}
*/
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/data-access/src/index.ts ---
export * from './lib/admin-product-api.service';
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/data-access/src/lib/admin-product-api.service.ts ---
/**
 * @file admin-product-api.service.ts
 * @Version 2.1.0 (FIXED: Proper pagination parameters)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-08
 * @Description Fixed API service that ensures required PageNumber and PageSize are always provided
 */
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { map, Observable, of } from 'rxjs';
import { APP_CONFIG } from '@royal-code/core/config';
import { AbstractProductApiService, BackendPaginatedListDto, BackendProductListItemDto, BackendProductDetailDto, BackendMediaDto } from '@royal-code/features/products/core';
import { ProductFilters, CreateProductPayload, UpdateProductPayload, ProductCategory, AvailableFiltersResponse, SearchSuggestionResponse } from '@royal-code/features/products/domain';
import { CustomAttributeDefinitionDto, DisplaySpecificationDefinitionDto, PredefinedAttributesMap } from '@royal-code/features/admin-products/core';
import { ProductLookups, ProductTagLookup } from '@royal-code/features/admin-products/domain';
import { LoggerService } from '@royal-code/core/logging';

@Injectable({ providedIn: 'root' })
export class AdminProductApiService extends AbstractProductApiService {
    private readonly http = inject(HttpClient);
    private readonly config = inject(APP_CONFIG);
    // --- DE FIX: De apiUrl is hier gecorrigeerd naar 'AdminProducts' (meervoud) ---
    private readonly apiUrl = `${this.config.backendUrl}/AdminProducts`;
    private readonly logger = inject(LoggerService);
    private readonly logPrefix = '[AdminProductApiService]';

    // === FIXED: Proper pagination parameters ===
    override getProducts(filters?: ProductFilters | null, page?: number, pageSize?: number): Observable<BackendPaginatedListDto<BackendProductListItemDto>> {
    // SIMPLE FIX: Ensure required parameters are always present
    const finalPage = page ?? filters?.page ?? 1;
    const finalPageSize = pageSize ?? filters?.pageSize ?? 20;
    
    let params = new HttpParams()
        .set('PageNumber', Math.max(1, finalPage).toString())
        .set('PageSize', Math.min(100, Math.max(1, finalPageSize)).toString());

    // Add optional filters only if they have values
    if (filters?.searchTerm?.trim()) {
        params = params.set('SearchTerm', filters.searchTerm.trim());
    }
    if (filters?.statuses && filters.statuses.length > 0) {
        params = params.set('Status', filters.statuses.join(','));
    }
    if (filters?.sortBy?.trim()) {
        params = params.set('SortBy', filters.sortBy.trim());
    }
    if (filters?.sortDirection?.trim()) {
        params = params.set('SortDirection', filters.sortDirection.trim());
    }

    return this.http.get<BackendPaginatedListDto<BackendProductListItemDto>>(this.apiUrl, { params });
}

    // === OPTIMIZED: Batch operations for better performance ===
    getProductsByIds(productIds: string[]): Observable<BackendProductListItemDto[]> {
        if (productIds.length === 0) {
            return of([]);
        }
        
        // For admin, we can use the main endpoint with filtering if needed
        // or implement a dedicated batch endpoint
        const params = new HttpParams()
            .set('PageNumber', '1')
            .set('PageSize', productIds.length.toString());
            
        return this.http.get<BackendPaginatedListDto<BackendProductListItemDto>>(this.apiUrl, { params })
            .pipe(
                map(response => response.items.filter(item => productIds.includes(item.id)))
            );
    }

    // === CACHED: Lookup data with minimal API calls ===
    override getPredefinedAttributes(): Observable<PredefinedAttributesMap> {
        // Deze methode wordt niet meer direct aangeroepen door de effects, maar de implementatie is hier correct.
        return this.http.get<PredefinedAttributesMap>(`${this.apiUrl}/attributes`);
    }

    public getCustomAttributeDefinitions(): Observable<CustomAttributeDefinitionDto[]> {
        return this.http.get<CustomAttributeDefinitionDto[]>(`${this.apiUrl}/custom-attribute-definitions`);
    }

    public getDisplaySpecificationDefinitions(): Observable<DisplaySpecificationDefinitionDto[]> {
        return this.http.get<DisplaySpecificationDefinitionDto[]>(`${this.apiUrl}/display-specification-definitions`);
    }

    override getProductById(id: string): Observable<BackendProductDetailDto> {
        if (!id?.trim()) {
            throw new Error('Product ID is required');
        }
        return this.http.get<BackendProductDetailDto>(`${this.apiUrl}/${id.trim()}`);
    }
    
    override getCategories(): Observable<ProductCategory[]> {
        return this.http.get<ProductCategory[]>(`${this.apiUrl}/categories`);
    }

    // === OPTIMIZED: Combined lookups call ===
    public override getLookups(): Observable<ProductLookups> {
        // De effecten gebruiken deze methode om alle formulierdata in één keer op te halen.
        return this.http.get<ProductLookups>(`${this.apiUrl}/lookups`);
    }

    public override getTags(searchTerm?: string): Observable<ProductTagLookup[]> {
        let params = new HttpParams();
        if (searchTerm?.trim()) {
            params = params.set('searchTerm', searchTerm.trim());
        }
        return this.http.get<ProductTagLookup[]>(`${this.apiUrl}/tags`, { params });
    }

    // === CREATE/UPDATE/DELETE operations ===
    override createProduct(payload: CreateProductPayload): Observable<BackendProductDetailDto> {
        return this.http.post<BackendProductDetailDto>(this.apiUrl, payload);
    }

    override updateProduct(id: string, payload: UpdateProductPayload): Observable<BackendProductDetailDto> {
        if (!id?.trim()) {
            throw new Error('Product ID is required for update');
        }
        return this.http.put<BackendProductDetailDto>(`${this.apiUrl}/${id.trim()}`, payload);
    }
    
    override updatePhysicalStock(productId: string, variantInstanceId: string | undefined, changeInQuantity: number, reason: string, userId: string): Observable<BackendProductDetailDto> {
        const payload: UpdateProductPayload = { physicalProductConfig: { stockQuantity: changeInQuantity } };
        return this.updateProduct(productId, payload);
    }

    override deleteProduct(id: string): Observable<void> {
        if (!id?.trim()) {
            throw new Error('Product ID is required for deletion');
        }
        return this.http.delete<void>(`${this.apiUrl}/${id.trim()}`);
    }

    // === NOT IMPLEMENTED for Admin ===
    override getFeaturedProducts(): Observable<BackendPaginatedListDto<BackendProductListItemDto>> { 
        throw new Error('Featured products not available in admin API'); 
    }
    
    override getRecommendations(): Observable<BackendPaginatedListDto<BackendProductListItemDto>> { 
        throw new Error('Recommendations not available in admin API'); 
    }
    
    override bulkDeleteProducts(ids: string[]): Observable<void> { 
        throw new Error('Bulk delete not implemented yet'); 
    }

    public override getAvailableFilters(currentFilters?: ProductFilters | null): Observable<AvailableFiltersResponse> {
        // Use general products endpoint for filters
        const generalApiUrl = `${this.config.backendUrl}/Products`;
        const params = new HttpParams();
        return this.http.get<AvailableFiltersResponse>(`${generalApiUrl}/filters`, { params });
    }

    public override searchProducts(query: string, filters?: ProductFilters | null): Observable<BackendPaginatedListDto<BackendProductListItemDto>> {
        const searchUrl = `${this.config.backendUrl}/Search/products`;
        let params = new HttpParams()
            .set('q', query)
            .set('PageNumber', (filters?.page ?? 1).toString())
            .set('PageSize', (filters?.pageSize ?? 20).toString());
        return this.http.get<BackendPaginatedListDto<BackendProductListItemDto>>(searchUrl, { params });
    }

    public override getSuggestions(query: string): Observable<SearchSuggestionResponse> {
        return of({ suggestions: [] });
    }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/domain/src/index.ts ---
/**
 * @file index.ts (admin-products-domain)
 * @description Public API for the Admin Products Domain library.
 */
export * from './lib/models/product-lookups.model';
// Voeg hier eventueel andere admin-product-specifieke domain modellen toe
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/domain/src/lib/models/product-lookups.model.ts ---
/**
 * @file product-lookups.model.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-03
 * @Description
 *   Defines the frontend interfaces that exactly match the structure of the
 *   /api/Products/lookups backend endpoint response.
 */
import { AppIcon } from '@royal-code/shared/domain';

export interface VariantAttributeValueLookup {
  id: string;
  value: string;
  displayName: string;
  name: string;
  colorHex: string | null;
  priceModifier: number | null;
}

export interface DisplaySpecificationLookup {
  id: string;
  specKey: string;
  labelKeyOrText: string;
  icon: AppIcon | string;
  groupKeyOrText: string;
  displayOrder: number;
}

export interface CustomAttributeLookup {
  id: string;
  key: string;
  nameKeyOrText: string;
  descriptionKeyOrText: string;
  valueType: 'integer' | 'string' | 'boolean';
  uiControlType: 'slider' | 'toggle' | 'text';
  validationRulesJson: string | null;
  defaultValue: string;
  group: string;
  icon: AppIcon | string;
}

export interface ProductLookups {
  productTypes: string[];
  productStatuses: string[];
  variantAttributes: Record<string, VariantAttributeValueLookup[]>;
  displaySpecifications: DisplaySpecificationLookup[];
  customAttributes: CustomAttributeLookup[];
}

export interface ProductTagLookup {
    name: string;
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/ui/src/index.ts ---
export * from './lib/components/product-list/product-list.component';
--- END OF FILE ---

--- START OF FILE libs/features/admin-products/ui/src/lib/components/product-list/product-list.component.ts ---
/**
 * @file product-list.component.ts
 * @Version 3.4.0 (Styling en Button Fixes)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-20
 * @Description Corrected styling for images and confirmed UiInputComponent for stock editing.
 */
import { Component, ChangeDetectionStrategy, input, output } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { Product, ProductStatus, isPhysicalProduct } from '@royal-code/features/products/domain';
import { UiIconComponent } from '@royal-code/ui/icon';
import { UiButtonComponent } from '@royal-code/ui/button';
import { AppIcon } from '@royal-code/shared/domain';
import { UiImageComponent } from '@royal-code/ui/image';
import { UiInputComponent } from '@royal-code/ui/input';
import { FormsModule } from '@angular/forms';
import { filterImageMedia } from '@royal-code/shared/utils';
import { Image, Media } from '@royal-code/shared/domain';

@Component({
  selector: 'admin-product-list',
  standalone: true,
  imports: [CommonModule, CurrencyPipe, UiIconComponent, UiButtonComponent, UiImageComponent, UiInputComponent, FormsModule],
  template: `
    <div class="bg-card border border-border rounded-xs overflow-x-auto">
      <table class="w-full text-sm text-left text-secondary whitespace-nowrap">
        <thead class="text-xs text-muted uppercase bg-surface-alt">
          <tr>
            <th scope="col" class="p-4">Product</th>
            <th scope="col" class="p-4">Status</th>
            <th scope="col" class="p-4">Voorraad</th>
            <th scope="col" class="p-4">Prijs</th>
            <th scope="col" class="p-4 text-right">Acties</th>
          </tr>
        </thead>
        <tbody>
          @for (product of products(); track product.id) {
            <tr class="border-b border-border hover:bg-hover">
              <td class="p-2 font-medium text-foreground">
                <div class="flex items-center gap-4">
                  <!-- FIX: Afbeelding container is nu een simpele div zonder negatieve marges -->
                  <div class="w-12 h-12 rounded-md overflow-hidden bg-muted flex-shrink-0">
                    @if (getPrimaryImage(product.media); as primaryImage) {
                      <royal-code-ui-image [src]="primaryImage.variants[0].url" [alt]="product.name" objectFit="cover" extraClasses="h-full w-full" />
                    } @else {
                      <div class="w-full h-full flex items-center justify-center text-secondary">
                        <royal-code-ui-icon [icon]="AppIcon.ImageOff" sizeVariant="sm" />
                      </div>
                    }
                  </div>
                  <span>{{ product.name }}</span>
                </div>
              </td>
              <td class="p-4">
                 <select
                   [ngModel]="product.status"
                   (ngModelChange)="statusChanged.emit({ productId: product.id, newStatus: $event })"
                   class="w-full p-2 border border-input rounded-md bg-background text-sm focus:ring-primary focus:border-primary">
                   @for (status of productStatuses; track status) {
                     <option [value]="status">{{ status | titlecase }}</option>
                   }
                 </select>
              </td>
              <td class="p-4">
                @if (isPhysical(product) && product.stockQuantity !== null && product.stockQuantity !== undefined) {
                  <!-- BEVESTIGING: Dit is de UiInputComponent voor directe aanpassing -->
                  <royal-code-ui-input
                    type="number"
                    [ngModel]="product.stockQuantity"
                    (ngModelChange)="stockChanged.emit({ productId: product.id, newStock: $event })"
                    extraClasses="w-24"
                  />
                } @else {
                  <span class="text-muted italic">N/A</span>
                }
              </td>
              <td class="p-4">
                @if (product.price !== null && product.price !== undefined) {
                  {{ product.price | currency:'EUR' }}
                } @else {
                  <span class="text-muted italic">Variabel</span>
                }
              </td>
              <td class="p-4 text-right">
                <div class="flex items-center justify-end gap-2">
                  <royal-code-ui-button type="outline" sizeVariant="icon" (clicked)="editClicked.emit(product.id)" title="Bewerken">
                    <royal-code-ui-icon [icon]="AppIcon.Edit" />
                  </royal-code-ui-button>
                  <royal-code-ui-button type="fire" sizeVariant="icon" (clicked)="deleteClicked.emit(product.id)" title="Verwijderen">
                    <royal-code-ui-icon [icon]="AppIcon.Trash2" />
                  </royal-code-ui-button>
                </div>
              </td>
            </tr>
          } @empty {
            <tr>
              <td colspan="5" class="p-8 text-center">Geen producten gevonden.</td>
            </tr>
          }
        </tbody>
      </table>
    </div>
  `,
  styles: [`
    td, th { vertical-align: middle; }
    .w-12.h-12 { height: 3rem; width: 3rem; }
  `]
})
export class ProductListComponent {
  products = input.required<readonly Product[]>();

  editClicked = output<string>();
  deleteClicked = output<string>();
  statusChanged = output<{ productId: string; newStatus: ProductStatus }>();
  stockChanged = output<{ productId: string; newStock: number }>();

  protected readonly AppIcon = AppIcon;
  protected readonly productStatuses = Object.values(ProductStatus);

  isPhysical(product: Product): product is Product & { stockQuantity?: number | null } {
    return isPhysicalProduct(product);
  }

  getPrimaryImage(media: readonly Media[] | null | undefined): Image | undefined {
    return filterImageMedia(media)?.[0];
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/core/src/index.ts ---
// --- State management exports ---
export * from './lib/state/admin-users.actions';
export * from './lib/state/admin-users.types';
export * from './lib/state/admin-users.effects';
export * from './lib/state/admin-users.facade';
export * from './lib/state/admin-users.feature';
export * from './lib/admin-users.providers';

// --- Export domain models and DTOs ---
export * from './lib/mappers/admin-user-mapping.service';
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/core/src/lib/admin-users.providers.ts ---
import { EnvironmentProviders, makeEnvironmentProviders } from '@angular/core';
import { provideState } from '@ngrx/store';
import { provideEffects } from '@ngrx/effects';
import { adminUsersFeature } from './state/admin-users.feature';
import { AdminUsersEffects } from './state/admin-users.effects';
import { AdminUserApiService } from '@royal-code/features/admin-users/data-access';

export function provideAdminUsersFeature(): EnvironmentProviders {
  return makeEnvironmentProviders([
    provideState(adminUsersFeature),
    provideEffects(AdminUsersEffects),
    AdminUserApiService, // Zorg ervoor dat de service hier wordt voorzien
  ]);
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/core/src/lib/mappers/admin-user-mapping.service.ts ---
/**
 * @file admin-user-mapping.service.ts
 * @version 1.1.0 (Corrected DateTime Handling)
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-08-30
 * @description Provides mapping logic between AdminUser DTOs and AdminUser domain models.
 *              This version corrects the creation of DateTimeInfo objects to use the
 *              DateTimeUtil helper, ensuring serializable state for NgRx.
 */
import { Injectable } from '@angular/core';
import { AdminUserDetailDto, AdminUserListItemDto, AdminUser } from '@royal-code/features/admin-users/domain';
import { DateTimeUtil } from '@royal-code/shared/utils';

@Injectable({ providedIn: 'root' })
export class AdminUserMappingService {

  mapListItemToAdminUser(dto: AdminUserListItemDto): AdminUser {
    return {
      id: dto.id,
      displayName: dto.displayName,
      fullName: dto.fullName, 
      email: dto.email,
      roles: dto.roles || [],
      isLockedOut: dto.isLockedOut,
      // --- DE FIX: Gebruik DateTimeUtil voor serialiseerbare objecten ---
      createdAt: DateTimeUtil.createDateTimeInfo(dto.createdAt),
      firstName: '', 
      lastName: '',
      middleName: null,
      bio: null,
      emailConfirmed: false,
      lockoutEnd: null,
      accessFailedCount: 0,
    };
  }

mapDetailDtoToAdminUser(dto: AdminUserDetailDto): AdminUser {
    return {
        id: dto.id,
        displayName: dto.displayName,
        fullName: `${dto.firstName || ''} ${dto.lastName || ''}`.trim(),
        email: dto.email,
        roles: dto.roles || [],
        isLockedOut: dto.isLockedOut,
        // --- DE FIX: Gebruik DateTimeUtil voor serialiseerbare objecten ---
        createdAt: DateTimeUtil.createDateTimeInfo(), // DTO heeft geen createdAt, dus we nemen 'nu' als fallback
        firstName: dto.firstName,
        lastName: dto.lastName,
        middleName: dto.middleName,
        bio: dto.bio,
        emailConfirmed: dto.emailConfirmed,
        // --- DE FIX: Gebruik DateTimeUtil voor serialiseerbare objecten ---
        lockoutEnd: dto.lockoutEnd ? DateTimeUtil.createDateTimeInfo(dto.lockoutEnd) : null,
        accessFailedCount: dto.accessFailedCount,
    };
}

}
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/core/src/lib/state/admin-users.actions.ts ---
/**
 * @file admin-users.actions.ts
 * @version 4.0.0 (Full Permission Management)
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-07-30
 * @description NgRx Actions for Admin User, Role, and Permission Management.
 */
import { createActionGroup, emptyProps, props } from '@ngrx/store';
import { Update } from '@ngrx/entity';
import { AdminUser, CreateUserPayload, UpdateUserPayload, CreateRolePayload, UpdateRolePayload, Role, Permission, UpdateRolePermissionsPayload, LockUserPayload, SetPasswordPayload } from '@royal-code/features/admin-users/domain';

export const AdminUserActions = createActionGroup({
  source: 'Admin Users',
  events: {
    // === PAGE LIFECYCLE & FILTERS ===
    'Page Initialized': emptyProps(),
    'Filters Changed': props<{ filters: { searchTerm?: string; role?: string; page?: number } }>(),

    // === USER CRUD OPERATIONS ===
    // --- Read ---
    'Load Users': props<{ page: number, pageSize: number, searchTerm?: string, role?: string }>(),
    'Load Users Success': props<{ users: AdminUser[], totalCount: number }>(),
    'Load Users Failure': props<{ error: string }>(),
    'Load User Detail': props<{ userId: string }>(),
    'Load User Detail Success': props<{ user: AdminUser }>(),
    'Load User Detail Failure': props<{ error: string }>(),
    // --- Create ---
    'Create User Submitted': props<{ payload: CreateUserPayload }>(),
    'Create User Success': props<{ user: AdminUser }>(),
    'Create User Failure': props<{ error: string }>(),
    // --- Update ---
    'Update User Submitted': props<{ userId: string, payload: UpdateUserPayload }>(),
    'Update User Success': props<{ userUpdate: Update<AdminUser> }>(),
    'Update User Failure': props<{ error: string }>(),
    // --- Delete ---
    'Delete User Confirmed': props<{ userId: string }>(),
    'Delete User Success': props<{ userId: string }>(),
    'Delete User Failure': props<{ error: string }>(),
    // --- Selection ---
    'Select User': props<{ userId: string | null }>(),

    // --- Account Status & Password ---
    'Lock User Submitted': props<{ userId: string, payload: LockUserPayload }>(),
    'Lock User Success': props<{ userUpdate: Update<AdminUser> }>(),
    'Lock User Failure': props<{ error: string }>(),

    'Unlock User Submitted': props<{ userId: string }>(),
    'Unlock User Success': props<{ userUpdate: Update<AdminUser> }>(),
    'Unlock User Failure': props<{ error: string }>(),

    'Set Password Submitted': props<{ userId: string, payload: SetPasswordPayload }>(),
    'Set Password Success': emptyProps(), // We hoeven de state niet te updaten
    'Set Password Failure': props<{ error: string }>(),


    // === ROLE & PERMISSION MANAGEMENT ===
    // --- Roles ---
    'Load Available Roles': emptyProps(),
    'Load Available Roles Success': props<{ roles: Role[] }>(),
    'Load Available Roles Failure': props<{ error: string }>(),
    'Create Role Submitted': props<{ payload: CreateRolePayload }>(),
    'Create Role Success': props<{ role: Role }>(),
    'Create Role Failure': props<{ error: string }>(),
    'Update Role Submitted': props<{ payload: UpdateRolePayload }>(),
    'Update Role Success': props<{ role: Role }>(),
    'Update Role Failure': props<{ error: string }>(),
    'Delete Role Confirmed': props<{ roleId: string }>(),
    'Delete Role Success': props<{ roleId: string }>(),
    'Delete Role Failure': props<{ error: string }>(),
    // --- Permissions ---
    'Load All Permissions': emptyProps(),
    'Load All Permissions Success': props<{ permissions: Permission[] }>(),
    'Load All Permissions Failure': props<{ error: string }>(),
    'Load Role Permissions': props<{ roleId: string }>(),
    'Load Role Permissions Success': props<{ roleId: string, permissions: Permission[] }>(),
    'Load Role Permissions Failure': props<{ roleId: string, error: string }>(),
    'Update Role Permissions Submitted': props<{ payload: UpdateRolePermissionsPayload }>(),
    'Update Role Permissions Success': props<{ roleId: string, permissions: Permission[] }>(),
    'Update Role Permissions Failure': props<{ roleId: string, error: string }>(),
  },
});
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/core/src/lib/state/admin-users.effects.ts ---
/**
 * @file admin-users.effects.ts
 * @version 5.0.0 (Fixed Race Condition & Conflicting Notifications for User Creation)
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-09-02
 * @description NgRx Effects for Admin User, Role, and Permission Management, with fixes for user creation flow.
 */
import { Injectable, inject } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { of } from 'rxjs';
import { catchError, map, switchMap, withLatestFrom, tap, filter } from 'rxjs/operators';
import { Store } from '@ngrx/store';
import { AdminUserApiService } from '@royal-code/features/admin-users/data-access';
import { AdminUserMappingService } from '../mappers/admin-user-mapping.service';
import { AdminUserActions } from './admin-users.actions';
import { adminUsersFeature } from './admin-users.feature';
import { NotificationService } from '@royal-code/ui/notifications';
import { Router } from '@angular/router';
import { AdminUser } from '@royal-code/features/admin-users/domain';
import { Update } from '@ngrx/entity';

@Injectable()
export class AdminUsersEffects {
  private actions$ = inject(Actions);
  private store = inject(Store);
  private router = inject(Router);
  private apiService = inject(AdminUserApiService);
  private mappingService = inject(AdminUserMappingService);
  private notificationService = inject(NotificationService);

  // === PAGE LIFECYCLE ===
  init$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.pageInitialized),
      switchMap(() => {
        return [
          AdminUserActions.loadUsers({ page: 1, pageSize: 20 }),
          AdminUserActions.loadAvailableRoles(),
          AdminUserActions.loadAllPermissions()
        ];
      })
    )
  );

  changeFilters$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.filtersChanged),
      withLatestFrom(this.store.select(adminUsersFeature.selectAdminUsersState)),
      map(([, state]) => {
        return AdminUserActions.loadUsers({
          page: state.currentPage,
          pageSize: state.pageSize,
          searchTerm: state.searchTerm,
          role: state.roleFilter
        });
      })
    )
  );

  // === USER EFFECTS ===
  // --- Read (List) ---
  loadUsers$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.loadUsers),
      withLatestFrom(
        this.store.select(adminUsersFeature.selectCurrentPage),
        this.store.select(adminUsersFeature.selectPageSize),
        this.store.select(adminUsersFeature.selectSearchTerm),
        this.store.select(adminUsersFeature.selectRoleFilter)
      ),
      switchMap(([action, currentPage, pageSize, searchTerm, roleFilter]) =>
        this.apiService.getUsers({
          pageNumber: currentPage,
          pageSize: pageSize,
          searchTerm: searchTerm,
          role: roleFilter
        }).pipe(
          map(response => AdminUserActions.loadUsersSuccess({
            users: response.items.map(dto => this.mappingService.mapListItemToAdminUser(dto)),
            totalCount: response.totalCount
          })),
          catchError(error => {
            this.notificationService.showError(`Failed to load users: ${error.message}`);
            return of(AdminUserActions.loadUsersFailure({ error: error.message }));
          })
        )
      )
    )
  );

  // --- Read (Detail Trigger): selectUser => loadUserDetail ---
  triggerLoadUserDetail$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.selectUser),
      filter(({ userId }) => !!userId),
      map(({ userId }) => AdminUserActions.loadUserDetail({ userId: userId! }))
    )
  );

  // --- Read (Detail Load): loadUserDetail => API Call ---
  loadUserDetail$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.loadUserDetail),
      switchMap(({ userId }) =>
        this.apiService.getUserById(userId).pipe(
          map(dto => AdminUserActions.loadUserDetailSuccess({ user: this.mappingService.mapDetailDtoToAdminUser(dto) })),
          catchError(error => {
            this.notificationService.showError(`Failed to load user details: ${error.message}`);
            return of(AdminUserActions.loadUserDetailFailure({ error: error.message }));
          })
        )
      )
    )
  );

  // --- Create User (API Call Only) ---
  createUser$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.createUserSubmitted),
      switchMap(({ payload }) =>
        this.apiService.createUser(payload).pipe(
          map((response) => AdminUserActions.createUserSuccess({ user: { id: response.userId, ...payload, createdAt: {} as any, fullName: '', isLockedOut: false, emailConfirmed: false, accessFailedCount: 0 } as AdminUser })), // Map response to AdminUser
          catchError(error => {
            this.notificationService.showError(`Failed to create user: ${error.message}`);
            return of(AdminUserActions.createUserFailure({ error: error.message }));
          })
        )
      )
    )
  );

  // --- Handle Create User Success (Navigation & Load Detail) ---
  createUserSuccessRedirectAndLoadDetail$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.createUserSuccess),
      tap(({ user }) => {
        this.notificationService.showSuccess(`Gebruiker '${user.displayName}' succesvol aangemaakt!`);
        this.router.navigate(['/users', user.id]);
      }),
      map(({ user }) => AdminUserActions.loadUserDetail({ userId: user.id }))
    )
  );

  // --- Update User ---
   updateUser$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.updateUserSubmitted),
      switchMap(({ userId, payload }) =>
        this.apiService.updateUser(userId, payload).pipe(
          map(() => {
            this.notificationService.showSuccess('User successfully updated.');
            return AdminUserActions.updateUserSuccess({ userUpdate: { id: userId, changes: payload } });
          }),
          catchError(error => {
            this.notificationService.showError(`Failed to update user: ${error.message}`);
            return of(AdminUserActions.updateUserFailure({ error: error.message }));
          })
        )
      )
    )
  );
  // --- Delete User ---
  deleteUser$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.deleteUserConfirmed),
      switchMap(({ userId }) =>
        this.apiService.deleteUser(userId).pipe(
          map(() => {
            this.notificationService.showSuccess('User successfully deleted.');
            return AdminUserActions.deleteUserSuccess({ userId });
          }),
          catchError(error => {
            this.notificationService.showError(`Failed to delete user: ${error.message}`);
            return of(AdminUserActions.deleteUserFailure({ error: error.message }));
          })
        )
      )
    )
  );

    // --- Account Status & Password Effects ---
  lockUser$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.lockUserSubmitted),
      switchMap(({ userId, payload }) =>
        this.apiService.lockUser(userId, payload).pipe(
          map(() => {
            this.notificationService.showSuccess('User account locked successfully.');
            // Creëer een update voor de state
            const userUpdate: Update<AdminUser> = {
              id: userId,
              changes: { isLockedOut: true }
            };
            return AdminUserActions.lockUserSuccess({ userUpdate });
          }),
          catchError(error => {
            this.notificationService.showError(`Failed to lock user: ${error.message}`);
            return of(AdminUserActions.lockUserFailure({ error: error.message }));
          })
        )
      )
    )
  );

  unlockUser$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.unlockUserSubmitted),
      switchMap(({ userId }) =>
        this.apiService.unlockUser(userId).pipe(
          map(() => {
            this.notificationService.showSuccess('User account unlocked successfully.');
            const userUpdate: Update<AdminUser> = {
              id: userId,
              changes: { isLockedOut: false, lockoutEnd: null } // Reset ook lockoutEnd
            };
            return AdminUserActions.unlockUserSuccess({ userUpdate });
          }),
          catchError(error => {
            this.notificationService.showError(`Failed to unlock user: ${error.message}`);
            return of(AdminUserActions.unlockUserFailure({ error: error.message }));
          })
        )
      )
    )
  );

  setPassword$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.setPasswordSubmitted),
      switchMap(({ userId, payload }) =>
        this.apiService.setPassword(userId, payload).pipe(
          map(() => {
            this.notificationService.showSuccess("User's password has been updated successfully.");
            return AdminUserActions.setPasswordSuccess();
          }),
          catchError(error => {
            this.notificationService.showError(`Failed to set password: ${error.message}`);
            return of(AdminUserActions.setPasswordFailure({ error: error.message }));
          })
        )
      )
    )
  );


  // === ROLE & PERMISSION EFFECTS ===
  // --- Roles - Read ---
  loadRoles$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.loadAvailableRoles),
      switchMap(() =>
        this.apiService.getAvailableRoles().pipe(
          map(roles => {
            return AdminUserActions.loadAvailableRolesSuccess({ roles });
          }),
          catchError(error => {
            this.notificationService.showError(`Failed to load roles: ${error.message}`);
            return of(AdminUserActions.loadAvailableRolesFailure({ error: error.message }));
          })
        )
      )
    )
  );
  // --- Roles - Create ---
  createRole$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.createRoleSubmitted),
      switchMap(({ payload }) =>
        this.apiService.createRole(payload).pipe(
          map((newRole) => {
            this.notificationService.showSuccess(`Role '${newRole.name}' successfully created.`);
            return AdminUserActions.createRoleSuccess({ role: newRole });
          }),
          catchError(error => {
            const errorMessage = error.status === 409 ? `Role '${payload.name}' already exists.` : error.message;
            this.notificationService.showError(`Failed to create role: ${errorMessage}`);
            return of(AdminUserActions.createRoleFailure({ error: errorMessage }));
          })
        )
      )
    )
  );
  // --- Roles - Update ---
  updateRole$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.updateRoleSubmitted),
      switchMap(({ payload }) =>
        this.apiService.updateRole(payload.id, { name: payload.name }).pipe(
          map((updatedRole) => {
            this.notificationService.showSuccess(`Role '${updatedRole.name}' was updated.`);
            return AdminUserActions.updateRoleSuccess({ role: updatedRole });
          }),
          catchError(error => {
            this.notificationService.showError(`Failed to update role: ${error.message}`);
            return of(AdminUserActions.updateRoleFailure({ error: error.message }));
          })
        )
      )
    )
  );
  // --- Roles - Delete ---
  deleteRole$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.deleteRoleConfirmed),
      switchMap(({ roleId }) =>
        this.apiService.deleteRole(roleId).pipe(
          map(() => {
            this.notificationService.showSuccess(`Role was successfully deleted.`);
            return AdminUserActions.deleteRoleSuccess({ roleId });
          }),
          catchError(error => {
            this.notificationService.showError(`Failed to delete role: ${error.message}`);
            return of(AdminUserActions.deleteRoleFailure({ error: error.message }));
          })
        )
      )
    )
  );

  // --- Permissions - Read All ---
  loadAllPermissions$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.loadAllPermissions),
      switchMap(() =>
        this.apiService.getAllPermissions().pipe(
          map(permissions => {
            return AdminUserActions.loadAllPermissionsSuccess({ permissions });
          }),
          catchError(error => {
            this.notificationService.showError(`Failed to load all permissions: ${error.message}`);
            return of(AdminUserActions.loadAllPermissionsFailure({ error: error.message }));
          })
        )
      )
    )
  );

  // --- Permissions - Read Role Specific ---
  loadRolePermissions$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.loadRolePermissions),
      switchMap(({ roleId }) =>
        this.apiService.getRolePermissions(roleId).pipe(
          map(permissions => {
            return AdminUserActions.loadRolePermissionsSuccess({ roleId, permissions });
          }),
          catchError(error => {
            this.notificationService.showError(`Failed to load permissions for role ${roleId}: ${error.message}`);
            return of(AdminUserActions.loadRolePermissionsFailure({ roleId, error: error.message }));
          })
        )
      )
    )
  );

  // --- Permissions - Update Role Specific ---
  updateRolePermissions$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AdminUserActions.updateRolePermissionsSubmitted),
      switchMap(({ payload }) =>
        this.apiService.updateRolePermissions(payload.roleId, payload.permissions).pipe(
          // Na een succesvolle PUT, roepen we de GET opnieuw aan om de *volledige* permissie-objecten op te halen
          switchMap(() => this.apiService.getRolePermissions(payload.roleId)),
          map(permissions => {
            this.notificationService.showSuccess('Permissions updated successfully.');
            return AdminUserActions.updateRolePermissionsSuccess({ roleId: payload.roleId, permissions });
          }),
          catchError(error => {
            this.notificationService.showError(`Failed to update permissions for role ${payload.roleId}: ${error.message}`);
            return of(AdminUserActions.updateRolePermissionsFailure({ roleId: payload.roleId, error: error.message }));
          })
        )
      )
    )
  );
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/core/src/lib/state/admin-users.facade.ts ---
/**
 * @file admin-users.facade.ts
 * @version 8.0.0 (Full Permission Management & Expanded Methods)
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-07-30
 * @description Facade for Admin User, Role, and Permission Management with expanded method bodies.
 */
import { Injectable, inject } from '@angular/core';
import { toSignal } from '@angular/core/rxjs-interop';
import { Store } from '@ngrx/store';
import { AdminUserActions } from './admin-users.actions';
import {
  adminUsersFeature,
  selectAllUsers,
  selectSelectedUser,
  selectTotalCount,
  selectIsLoading,
  selectIsSubmitting,
  selectError,
  selectAvailableRoles,
  selectAllPermissions,
  selectPermissionsByRoleId,
  selectLoadingPermissionsForRoleId,
  selectCurrentPage,
  selectPageSize,
  selectSearchTerm,
  selectRoleFilter,
} from './admin-users.feature';
import { combineLatest, map } from 'rxjs';
import { AdminUsersViewModel } from './admin-users.types';
import { CreateUserPayload, UpdateUserPayload, CreateRolePayload, UpdateRolePayload, UpdateRolePermissionsPayload } from '@royal-code/features/admin-users/domain';

@Injectable({ providedIn: 'root' })
export class AdminUsersFacade {
  private readonly store = inject(Store);

  // === ViewModels ===
  private readonly viewModel$ = combineLatest({
    users: this.store.select(selectAllUsers),
    selectedUser: this.store.select(selectSelectedUser),
    availableRoles: this.store.select(selectAvailableRoles),
    allPermissions: this.store.select(selectAllPermissions),
    permissionsByRoleId: this.store.select(selectPermissionsByRoleId),
    loadingPermissionsForRoleId: this.store.select(selectLoadingPermissionsForRoleId),
    totalCount: this.store.select(selectTotalCount),
    isLoading: this.store.select(selectIsLoading),
    isSubmitting: this.store.select(selectIsSubmitting),
    error: this.store.select(selectError),
    page: this.store.select(selectCurrentPage),
    pageSize: this.store.select(selectPageSize),
    searchTerm: this.store.select(selectSearchTerm),
    roleFilter: this.store.select(selectRoleFilter)
  }).pipe(
    map((vm): AdminUsersViewModel => ({ ...vm }))
  );
  readonly viewModel = toSignal(this.viewModel$);

  // === Page & Filter Actions ===
  initPage(): void {
    this.store.dispatch(AdminUserActions.pageInitialized());
  }

  changeFilters(filters: { searchTerm?: string; role?: string; page?: number }): void {
    this.store.dispatch(AdminUserActions.filtersChanged({ filters }));
  }

  // === User Actions ===
  selectUser(userId: string | null): void {
    this.store.dispatch(AdminUserActions.selectUser({ userId }));
  }

  createUser(payload: CreateUserPayload): void {
    this.store.dispatch(AdminUserActions.createUserSubmitted({ payload }));
  }

  updateUser(userId: string, payload: UpdateUserPayload): void {
    this.store.dispatch(AdminUserActions.updateUserSubmitted({ userId, payload }));
  }

  deleteUser(userId: string): void {
    this.store.dispatch(AdminUserActions.deleteUserConfirmed({ userId }));
  }

    // --- Account Status & Password ---
  lockUser(userId: string, lockoutEnd?: string | null): void {
    this.store.dispatch(AdminUserActions.lockUserSubmitted({ userId, payload: { lockoutEnd } }));
  }

  unlockUser(userId: string): void {
    this.store.dispatch(AdminUserActions.unlockUserSubmitted({ userId }));
  }

  setPassword(userId: string, newPassword: string): void {
    this.store.dispatch(AdminUserActions.setPasswordSubmitted({ userId, payload: { newPassword } }));
  }


  // === Role & Permission Actions ===
  createRole(payload: CreateRolePayload): void {
    this.store.dispatch(AdminUserActions.createRoleSubmitted({ payload }));
  }

  updateRole(payload: UpdateRolePayload): void {
    this.store.dispatch(AdminUserActions.updateRoleSubmitted({ payload }));
  }

  deleteRole(roleId: string): void {
    this.store.dispatch(AdminUserActions.deleteRoleConfirmed({ roleId }));
  }

  loadRolePermissions(roleId: string): void {
    this.store.dispatch(AdminUserActions.loadRolePermissions({ roleId }));
  }

  updateRolePermissions(payload: UpdateRolePermissionsPayload): void {
    this.store.dispatch(AdminUserActions.updateRolePermissionsSubmitted({ payload }));
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/core/src/lib/state/admin-users.feature.ts ---
/**
 * @file admin-users.feature.ts
 * @version 12.0.0 (Definitive State with Full Permission Management)
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-07-30
 * @description The definitive NgRx Feature for Admin User, Role, and Permission Management.
 */
import { createFeature, createReducer, on, createSelector, MemoizedSelector } from '@ngrx/store';
import { createEntityAdapter, EntityAdapter, EntityState } from '@ngrx/entity';
import { AdminUser, Role, Permission } from '@royal-code/features/admin-users/domain';
import { AdminUserActions } from './admin-users.actions';
import { createSafeEntitySelectors } from '@royal-code/shared/utils';

export const ADMIN_USERS_FEATURE_KEY = 'adminUsers';

// === STATE INTERFACE ===
export interface AdminUsersState extends EntityState<AdminUser> {
  totalCount: number;
  isLoading: boolean;
  isSubmitting: boolean;
  error: string | null;
  selectedUserId: string | null;
  // Role & Permission State
  availableRoles: readonly Role[];
  allPermissions: readonly Permission[];
  permissionsByRoleId: Record<string, readonly Permission[]>;
  loadingPermissionsForRoleId: string | null;
  // Pagination & Filter State
  currentPage: number;
  pageSize: number;
  searchTerm: string;
  roleFilter: string;
}

// === ENTITY ADAPTER ===
export const adminUserAdapter: EntityAdapter<AdminUser> = createEntityAdapter<AdminUser>();

// === INITIAL STATE ===
export const initialAdminUsersState: AdminUsersState = adminUserAdapter.getInitialState({
  totalCount: 0,
  isLoading: false,
  isSubmitting: false,
  error: null,
  selectedUserId: null,
  availableRoles: [],
  allPermissions: [],
  permissionsByRoleId: {},
  loadingPermissionsForRoleId: null,
  currentPage: 1,
  pageSize: 20,
  searchTerm: '',
  roleFilter: '',
});

// === FEATURE (REDUCER & SELECTORS) ===
export const adminUsersFeature = createFeature({
  name: ADMIN_USERS_FEATURE_KEY,
  reducer: createReducer(
    initialAdminUsersState,
    // === PAGE LIFECYCLE & FILTERS ===
    on(AdminUserActions.pageInitialized, (state) => ({ ...state, isLoading: true, error: null })),
    on(AdminUserActions.filtersChanged, (state, { filters }) => ({
      ...state,
      isLoading: true,
      currentPage: filters.page ?? 1,
      searchTerm: filters.searchTerm ?? state.searchTerm,
      roleFilter: filters.role ?? state.roleFilter,    
      error: null
    })),


    // === USER CRUD OPERATIONS ===
    // --- Read ---
    on(AdminUserActions.loadUsersSuccess, (state, { users, totalCount }) =>
      adminUserAdapter.setAll(users, { ...state, totalCount, isLoading: false, error: null })
    ),
    on(AdminUserActions.loadUsersFailure, (state, { error }) => ({ ...state, isLoading: false, error })),
    on(AdminUserActions.loadUserDetailSuccess, (state, { user }) => adminUserAdapter.upsertOne(user, { ...state, isLoading: false, selectedUserId: user.id, error: null })),
    on(AdminUserActions.createUserSuccess, (state, { user }) => adminUserAdapter.addOne(user, { ...state, totalCount: state.totalCount + 1, isSubmitting: false, error: null })),
    on(AdminUserActions.updateUserSuccess, (state, { userUpdate }) => adminUserAdapter.updateOne(userUpdate, { ...state, isSubmitting: false, error: null })),
    on(AdminUserActions.deleteUserSuccess, (state, { userId }) => adminUserAdapter.removeOne(userId, { ...state, totalCount: state.totalCount - 1, isSubmitting: false, error: null })),
    on(AdminUserActions.selectUser, (state, { userId }) => ({ ...state, selectedUserId: userId, isLoading: !!userId })),
    
    // --- Common submission/failure states for user operations ---
    on(AdminUserActions.createUserSubmitted, AdminUserActions.updateUserSubmitted, (state) => ({ ...state, isSubmitting: true, error: null })),
    on(AdminUserActions.createUserFailure, AdminUserActions.updateUserFailure, (state) => ({ ...state, isSubmitting: false })),
    on(AdminUserActions.deleteUserConfirmed, (state) => ({ ...state, isSubmitting: true, error: null })),
    on(AdminUserActions.deleteUserFailure, (state) => ({ ...state, isSubmitting: false })),
    on(AdminUserActions.loadUserDetail, (state) => ({ ...state, isLoading: true, error: null })),
    on(AdminUserActions.loadUserDetailFailure, (state, { error }) => ({ ...state, isLoading: false, error })),

    // --- Account Status ---
    on(AdminUserActions.lockUserSubmitted, AdminUserActions.unlockUserSubmitted, (state) => ({ ...state, isSubmitting: true, error: null })),
    on(AdminUserActions.lockUserSuccess, AdminUserActions.unlockUserSuccess, (state, { userUpdate }) =>
      adminUserAdapter.updateOne(userUpdate, { ...state, isSubmitting: false })
    ),
    on(AdminUserActions.lockUserFailure, AdminUserActions.unlockUserFailure, (state, { error }) => ({ ...state, isSubmitting: false, error })),


    // === ROLE & PERMISSION MANAGEMENT ===
    // --- Roles ---
    on(AdminUserActions.loadAvailableRolesSuccess, (state, { roles }) => ({ ...state, availableRoles: [...roles].sort((a, b) => a.name.localeCompare(b.name)), error: null })),
    on(AdminUserActions.loadAvailableRolesFailure, (state, { error }) => ({ ...state, error })),
    on(AdminUserActions.createRoleSubmitted, (state) => ({ ...state, isSubmitting: true, error: null })),
    on(AdminUserActions.createRoleSuccess, (state, { role }) => ({ ...state, isSubmitting: false, availableRoles: [...state.availableRoles, role].sort((a, b) => a.name.localeCompare(b.name)),})),
    on(AdminUserActions.createRoleFailure, (state, { error }) => ({ ...state, isSubmitting: false, error })),
    on(AdminUserActions.updateRoleSubmitted, (state) => ({...state, isSubmitting: true, error: null })),
    on(AdminUserActions.updateRoleSuccess, (state, { role }) => ({ ...state, isSubmitting: false, availableRoles: [...state.availableRoles.map(r => r.id === role.id ? role : r)].sort((a, b) => a.name.localeCompare(b.name)) })),
    on(AdminUserActions.updateRoleFailure, (state, { error }) => ({ ...state, isSubmitting: false, error })),
    on(AdminUserActions.deleteRoleConfirmed, (state) => ({ ...state, isSubmitting: true, error: null })),
    on(AdminUserActions.deleteRoleSuccess, (state, { roleId }) => ({ ...state, isSubmitting: false, availableRoles: state.availableRoles.filter(r => r.id !== roleId) })),
    on(AdminUserActions.deleteRoleFailure, (state, { error }) => ({ ...state, isSubmitting: false, error })),
    // --- Permissions ---
    on(AdminUserActions.loadAllPermissionsSuccess, (state, { permissions }) => ({ ...state, allPermissions: permissions })),
    on(AdminUserActions.loadAllPermissionsFailure, (state, { error }) => ({ ...state, error })),
    on(AdminUserActions.loadRolePermissions, (state, { roleId }) => ({ ...state, loadingPermissionsForRoleId: roleId })),
    on(AdminUserActions.loadRolePermissionsSuccess, (state, { roleId, permissions }) => ({
      ...state,
      permissionsByRoleId: { ...state.permissionsByRoleId, [roleId]: permissions },
      loadingPermissionsForRoleId: null
    })),
    on(AdminUserActions.loadRolePermissionsFailure, (state, { roleId, error }) => ({ ...state, loadingPermissionsForRoleId: null, error: `Failed to load permissions for role ${roleId}: ${error}` })),
    on(AdminUserActions.updateRolePermissionsSubmitted, (state) => ({ ...state, isSubmitting: true, error: null })),
    on(AdminUserActions.updateRolePermissionsSuccess, (state, { roleId, permissions }) => ({
      ...state,
      permissionsByRoleId: { ...state.permissionsByRoleId, [roleId]: permissions },
      isSubmitting: false,
    })),
    on(AdminUserActions.updateRolePermissionsFailure, (state, { roleId, error }) => ({ ...state, isSubmitting: false, error: `Failed to update permissions for role ${roleId}: ${error}` })),

  ),
  extraSelectors: ({ selectAdminUsersState, selectSelectedUserId, selectPermissionsByRoleId }) => {
    const { selectAll, selectEntities } = createSafeEntitySelectors(adminUserAdapter, selectAdminUsersState as MemoizedSelector<object, AdminUsersState | undefined>);

    return {
      selectAllUsers: selectAll,
      selectUserEntities: selectEntities,
      selectSelectedUser: createSelector(
        selectEntities,
        selectSelectedUserId,
        (entities, selectedId) => (selectedId ? entities[selectedId] : undefined)
      ),
      selectPermissionsForRole: (roleId: string) => createSelector(
        selectPermissionsByRoleId,
        (permissions) => permissions[roleId]
      )
    };
  }
});

// === EXPORTED SELECTORS ===
export const {
  name,
  reducer,
  selectAdminUsersState,
  selectTotalCount,
  selectIsLoading,
  selectIsSubmitting,
  selectError,
  selectSelectedUserId,
  selectAvailableRoles,
  selectAllPermissions,
  selectPermissionsByRoleId,
  selectLoadingPermissionsForRoleId,
  selectCurrentPage,
  selectPageSize,
  selectSearchTerm,
  selectRoleFilter,
  selectAllUsers,
  selectUserEntities,
  selectSelectedUser,
  selectPermissionsForRole,
} = adminUsersFeature;
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/core/src/lib/state/admin-users.types.ts ---
/**
 * @file admin-users.types.ts
 * @version 4.0.0 (Confirmed Full Permission Management Types)
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-07-30
 * @description Type definitions for the Admin Users feature, including full permission management.
 *              This version explicitly confirms the presence of all required properties.
 */
import { AdminUser, Role, Permission } from '@royal-code/features/admin-users/domain';

export interface AdminUsersViewModel {
  users: readonly AdminUser[];
  selectedUser: AdminUser | undefined;
  // Role & Permission State - DEZE ZIJN CRUCIAAL
  availableRoles: readonly Role[];
  allPermissions: readonly Permission[]; // MOET HIER ZIJN
  permissionsByRoleId: Record<string, readonly Permission[]>; // MOET HIER ZIJN
  loadingPermissionsForRoleId: string | null; // MOET HIER ZIJN
  // General State
  totalCount: number;
  isLoading: boolean;
  isSubmitting: boolean;
  error: string | null;
  // Pagination & Filter State
  page: number;
  pageSize: number;
  searchTerm?: string;
  roleFilter?: string;
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/data-access/src/index.ts ---
export * from './lib/admin-user-api.service';
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/data-access/src/lib/admin-user-api.service.ts ---
/**
 * @file admin-user-api.service.ts
 * @version 1.0.0
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-07-28
 * @description Service for interacting with the admin user management API endpoints.
 */
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs';
import { APP_CONFIG } from '@royal-code/core/config';
import { AdminUserDetailDto, AdminUserListItemDto, CreateRolePayload, CreateUserPayload, LockUserPayload, Permission, Role, SetPasswordPayload, UpdateUserPayload } from '@royal-code/features/admin-users/domain';
import { PaginatedList } from '@royal-code/shared/utils';

@Injectable({ providedIn: 'root' })
export class AdminUserApiService {
  private readonly http = inject(HttpClient);
  private readonly config = inject(APP_CONFIG);
  private readonly apiUrl = `${this.config.backendUrl}/admin/users`;

  getUsers(filters: { pageNumber?: number; pageSize?: number; searchTerm?: string; role?: string; }): Observable<PaginatedList<AdminUserListItemDto>> {
    let params = new HttpParams()
      .set('pageNumber', (filters.pageNumber ?? 1).toString())
      .set('pageSize', (filters.pageSize ?? 20).toString());

    if (filters.searchTerm) {
      params = params.set('searchTerm', filters.searchTerm);
    }
    if (filters.role) {
      params = params.set('role', filters.role);
    }

    return this.http.get<PaginatedList<AdminUserListItemDto>>(this.apiUrl, { params });
  }

  public getUserById(id: string): Observable<AdminUserDetailDto> {
    return this.http.get<AdminUserDetailDto>(`${this.apiUrl}/${id}`);
  }

  createUser(payload: CreateUserPayload): Observable<{ userId: string }> {
    return this.http.post<{ userId: string }>(this.apiUrl, payload);
  }

  updateUser(id: string, payload: UpdateUserPayload): Observable<void> {
    return this.http.put<void>(`${this.apiUrl}/${id}`, payload);
  }

  deleteUser(id: string): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`);
  }

    public lockUser(id: string, payload: LockUserPayload): Observable<void> {
    return this.http.post<void>(`${this.apiUrl}/${id}/lock`, payload);
  }

  public unlockUser(id: string): Observable<void> {
    return this.http.post<void>(`${this.apiUrl}/${id}/unlock`, {}); // Lege body
  }

  public setPassword(id: string, payload: SetPasswordPayload): Observable<void> {
    return this.http.post<void>(`${this.apiUrl}/${id}/set-password`, payload);
  }



  // === ROLE MANAGEMENT ===
  public getAvailableRoles(): Observable<Role[]> { // Returneert nu Role[]
    return this.http.get<Role[]>(`${this.config.backendUrl}/admin/roles`); // Nieuw Role-specifiek endpoint
  }

  public createRole(payload: CreateRolePayload): Observable<Role> { // Payload en return type zijn nu Role
    return this.http.post<Role>(`${this.config.backendUrl}/admin/roles`, payload); // Nieuw Role-specifiek endpoint
  }

  public updateRole(id: string, payload: { name: string }): Observable<Role> { // Nu met ID en payload { name }
    return this.http.put<Role>(`${this.config.backendUrl}/admin/roles/${id}`, payload); // Nieuw Role-specifiek endpoint
  }

  public deleteRole(id: string): Observable<void> { // Nu met ID
    return this.http.delete<void>(`${this.config.backendUrl}/admin/roles/${id}`); // Nieuw Role-specifiek endpoint
  }

  public getAllPermissions(): Observable<Permission[]> {
    return this.http.get<Permission[]>(`${this.config.backendUrl}/admin/permissions`);
  }

  public getRolePermissions(roleId: string): Observable<Permission[]> {
    return this.http.get<Permission[]>(`${this.config.backendUrl}/admin/roles/${roleId}/permissions`);
  }

  public updateRolePermissions(roleId: string, permissions: string[]): Observable<void> {
    return this.http.put<void>(`${this.config.backendUrl}/admin/roles/${roleId}/permissions`, { permissions });
  }


}
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/domain/src/index.ts ---
export * from './lib/admin-users.models';
export * from './lib/admin-roles.models';
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/domain/src/lib/admin-roles.models.ts ---
/**
 * @file admin-roles.models.ts
 * @version 3.0.0 (With Permissions)
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-07-29
 * @description Models and Payloads for role and permission management.
 */

export interface Permission {
  readonly value: string;
  readonly description: string;
}

export interface Role {
  readonly id: string;
  name: string;
  permissions?: readonly Permission[]; // Permissions for a specific role
}

export interface CreateRolePayload {
  name: string;
}

export interface UpdateRolePayload {
  id: string;
  name: string;
}

export interface UpdateRolePermissionsPayload {
  roleId: string;
  permissions: string[]; // Array of permission values
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/domain/src/lib/admin-users.models.ts ---
/**
 * @file admin-users.models.ts
 * @version 1.0.0
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-07-28
 * @description DTOs and domain models for the admin user management feature.
 */
import { DateTimeInfo } from '@royal-code/shared/base-models';

// === DTOs for API Communication ===

export interface AdminUserListItemDto {
  readonly id: string;
  readonly displayName: string;
  readonly fullName: string;
  readonly email: string;
  readonly roles: readonly string[];
  readonly isLockedOut: boolean;
  readonly createdAt: string; // ISO string
}

export interface AdminUserDetailDto {
  readonly id: string;
  readonly displayName: string;
  readonly firstName: string;
  readonly middleName: string | null;
  readonly lastName: string;
  readonly email: string;
  readonly bio: string | null;
  readonly emailConfirmed: boolean;
  readonly roles: readonly string[];
  readonly isLockedOut: boolean;
  readonly lockoutEnd: string | null; // ISO string
  readonly accessFailedCount: number;
}

export interface CreateUserPayload {
  email: string;
  password?: string; // Password might be optional if confirmation is separate
  displayName: string;
  firstName: string;
  middleName?: string | null;
  lastName: string;
  bio?: string | null;
  roles: string[];
}

export interface UpdateUserPayload {
  displayName: string;
  firstName: string;
  middleName?: string | null;
  lastName: string;
  bio: string | null;
  roles: string[];
}

// === Domain Models (for NgRx State) ===

export interface AdminUser {
  readonly id: string;
  displayName: string;
  fullName: string;
  firstName: string;
  lastName: string;
  middleName?: string | null;
  email: string;
  bio?: string | null; 
  roles: readonly string[];
  isLockedOut: boolean;
  emailConfirmed: boolean;
  lockoutEnd?: DateTimeInfo | null;
  accessFailedCount: number;
  createdAt: DateTimeInfo;
}

export interface LockUserPayload {
  lockoutEnd?: string | null; // ISO 8601 date string
}

export interface SetPasswordPayload {
  newPassword: string;
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/ui/src/index.ts ---
export * from './lib/components/admin-user-list/admin-user-list.component';
export * from './lib/components/admin-user-filter/admin-user-filter.component';
export * from './lib/components/role-management-dialog/role-management-dialog.component';
export * from './lib/components/admin-role-list/admin-role-list.component';
export * from './lib/components/permission-manager/permission-manager.component';
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/ui/src/lib/components/admin-role-list/admin-role-list.component.ts ---
/**
 * @file admin-role-list.component.ts
 * @version 11.0.0 (SuperAdmin Protection)
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-07-30
 * @description A list of roles in a table, with disabled actions for the 'SuperAdmin' role.
 */
import { Component, ChangeDetectionStrategy, input, output, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Role, Permission, UpdateRolePermissionsPayload } from '@royal-code/features/admin-users/domain';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiIconComponent } from '@royal-code/ui/icon';
import { AppIcon } from '@royal-code/shared/domain';
import { TranslateModule } from '@ngx-translate/core';
import { PermissionManagerComponent } from '../permission-manager/permission-manager.component';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';

@Component({
  selector: 'admin-role-list',
  standalone: true,
  imports: [CommonModule, TranslateModule, UiButtonComponent, UiIconComponent, PermissionManagerComponent, UiSpinnerComponent],
  template: `
    <div class="bg-card border border-border rounded-xs overflow-x-auto">
      <table class="w-full text-sm text-left text-secondary">
        <thead class="text-xs text-muted uppercase bg-surface-alt">
          <tr>
            <th scope="col" class="p-4">Role Name</th>
            <th scope="col" class="p-4 w-48 text-right">Actions</th>
          </tr>
        </thead>
        @for(role of roles(); track role.id) {
          <tbody class="border-b border-border last:border-b-0">
            <tr class="hover:bg-hover cursor-pointer" (click)="toggleExpand(role.id)">
              <td class="p-4 font-medium text-foreground">
                {{ role.name }}
                @if (role.name === 'SuperAdmin') {
                  <span class="ml-2 text-xs text-sun">(Protected)</span>
                }
              </td>
              <td class="p-4 text-right">
                <div class="flex items-center justify-end gap-2">
                  <royal-code-ui-button 
                    type="outline" 
                    sizeVariant="icon" 
                    (click)="editClicked.emit(role); $event.stopPropagation()" 
                    [title]="'common.buttons.edit' | translate"
                    [disabled]="role.name === 'SuperAdmin'">
                      <royal-code-ui-icon [icon]="AppIcon.Edit" sizeVariant="sm" />
                  </royal-code-ui-button>
                  <royal-code-ui-button 
                    type="fire" 
                    sizeVariant="icon" 
                    (click)="deleteClicked.emit(role); $event.stopPropagation()" 
                    [title]="'common.buttons.delete' | translate"
                    [disabled]="role.name === 'SuperAdmin'">
                      <royal-code-ui-icon [icon]="AppIcon.Trash2" sizeVariant="sm" />
                  </royal-code-ui-button>
                  <div class="w-8 h-8 flex items-center justify-center">
                    <royal-code-ui-icon 
                      [icon]="AppIcon.ChevronRight" 
                      sizeVariant="sm" 
                      class="transition-transform duration-200"
                      [ngClass]="{ 'rotate-90': expandedRoleId() === role.id }"
                    />
                  </div>
                </div>
              </td>
            </tr>
            @if (expandedRoleId() === role.id) {
              <tr>
                <td colspan="2" class="p-0">
                  <admin-permission-manager
                    [allPermissions]="allPermissions()"
                    [assignedPermissions]="permissionsByRoleId()[role.id]"
                    [isLoading]="loadingPermissionsForRoleId() === role.id"
                    (savePermissions)="onSavePermissions(role.id, $event)"
                    [isSuperAdmin]="role.name === 'SuperAdmin'"
                  />
                </td>
              </tr>
            }
          </tbody>
        } @empty {
          <tbody>
            <tr>
              <td colspan="2" class="p-8 text-center text-secondary">
                {{ 'admin.roles.messages.noRolesAvailable' | translate }}
              </td>
            </tr>
          </tbody>
        }
      </table>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class AdminRoleListComponent {
  roles = input.required<readonly Role[]>();
  allPermissions = input.required<readonly Permission[]>();
  permissionsByRoleId = input.required<Record<string, readonly Permission[]>>();
  loadingPermissionsForRoleId = input<string | null>(null);
  
  editClicked = output<Role>();
  deleteClicked = output<Role>();
  permissionsUpdated = output<UpdateRolePermissionsPayload>();
  loadPermissionsForRole = output<string>();

  protected readonly AppIcon = AppIcon;
  protected expandedRoleId = signal<string | null>(null);

  toggleExpand(roleId: string): void {
    const newId = this.expandedRoleId() === roleId ? null : roleId;
    this.expandedRoleId.set(newId);
    if (newId && !this.permissionsByRoleId()[newId]) {
      this.loadPermissionsForRole.emit(newId);
    }
  }

  onSavePermissions(roleId: string, permissions: string[]): void {
    this.permissionsUpdated.emit({ roleId, permissions });
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/ui/src/lib/components/admin-user-filter/admin-user-filter.component.ts ---
/**
 * @file admin-user-filter.component.ts
 * @version 1.0.0
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-07-29
 * @description Dumb component for filtering the admin user list.
 */
import { Component, ChangeDetectionStrategy, output, signal, input, effect } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { toObservable } from '@angular/core/rxjs-interop';
import { debounceTime, distinctUntilChanged } from 'rxjs';
import { UiInputComponent } from '@royal-code/ui/input';
import { AppIcon } from '@royal-code/shared/domain';

export interface UserFilters {
  searchTerm?: string;
  role?: string;
}

@Component({
  selector: 'admin-user-filter',
  standalone: true,
  imports: [CommonModule, FormsModule, UiInputComponent],
  template: `
    <div class="flex flex-col sm:flex-row gap-4 p-4 bg-surface-alt border border-border rounded-xs">
      <royal-code-ui-input
        [(ngModel)]="searchTerm"
        placeholder="Zoek op naam of e-mail..."
        [icon]="AppIcon.Search" iconPosition="left" extraClasses="flex-grow" />
      <select [(ngModel)]="roleFilter"
        class="w-full sm:w-48 p-2 border border-input rounded-md bg-background text-sm focus:ring-primary focus:border-primary">
        <option value="">Alle Rollen</option>
        @for (role of availableRoles(); track role) {
          <option [value]="role">{{ role }}</option>
        }
      </select>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class AdminUserFilterComponent {
  availableRoles = input.required<readonly string[]>();
  filtersChanged = output<UserFilters>();

  protected readonly AppIcon = AppIcon;
  protected searchTerm = '';
  protected roleFilter = '';

  constructor() {
    effect(() => {
      const filters: UserFilters = {
        searchTerm: this.searchTerm || undefined,
        role: this.roleFilter || undefined,
      };
      this.filtersChanged.emit(filters);
    });
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/ui/src/lib/components/admin-user-list/admin-user-list.component.ts ---
/**
 * @file admin-user-list.component.ts
 * @version 1.0.0
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-07-28
 * @description Dumb component to display a list of admin users.
 */
import { Component, ChangeDetectionStrategy, input, output } from '@angular/core';
import { CommonModule, DatePipe } from '@angular/common';
import { AdminUser } from '@royal-code/features/admin-users/domain';
import { UiIconComponent } from '@royal-code/ui/icon';
import { UiButtonComponent } from '@royal-code/ui/button';
import { AppIcon } from '@royal-code/shared/domain';
import { UiBadgeComponent } from '@royal-code/ui/badge';

@Component({
  selector: 'admin-user-list',
  standalone: true,
  imports: [CommonModule, DatePipe, UiIconComponent, UiButtonComponent, UiBadgeComponent],
  template: `
    <div class="bg-card border border-border rounded-xs overflow-x-auto">
      <table class="w-full text-sm text-left text-secondary whitespace-nowrap">
        <thead class="text-xs text-muted uppercase bg-surface-alt">
          <tr>
            <th scope="col" class="p-4">Display Name</th>
            <th scope="col" class="p-4">Email</th>
            <th scope="col" class="p-4">Roles</th>
            <th scope="col" class="p-4">Status</th>
            <th scope="col" class="p-4">Created At</th>
            <th scope="col" class="p-4 text-right">Actions</th>
          </tr>
        </thead>
        <tbody>
          @for (user of users(); track user.id) {
            <tr class="border-b border-border hover:bg-hover">
              <td class="p-4 font-medium text-foreground">{{ user.displayName }}</td>
              <td class="p-4">{{ user.email }}</td>
              <td class="p-4">
                <div class="flex flex-wrap gap-1">
                  @for(role of user.roles; track role) {
                    <royal-code-ui-badge [color]="'primary'">{{ role }}</royal-code-ui-badge>
                  }
                </div>
              </td>
              <td class="p-4">
                @if(user.isLockedOut) {
                  <royal-code-ui-badge [color]="'error'">Locked</royal-code-ui-badge>
                } @else {
                  <royal-code-ui-badge [color]="'success'">Active</royal-code-ui-badge>
                }
              </td>
              <td class="p-4">{{ user.createdAt.iso | date:'short' }}</td>
              <td class="p-4 text-right">
                <div class="flex items-center justify-end gap-2">
                  <royal-code-ui-button type="outline" sizeVariant="icon" (clicked)="editClicked.emit(user.id)" title="Bewerken">
                    <royal-code-ui-icon [icon]="AppIcon.Edit" />
                  </royal-code-ui-button>
                  <royal-code-ui-button type="fire" sizeVariant="icon" (clicked)="deleteClicked.emit(user.id)" title="Verwijderen">
                    <royal-code-ui-icon [icon]="AppIcon.Trash2" />
                  </royal-code-ui-button>
                </div>
              </td>
            </tr>
          } @empty {
            <tr>
              <td colspan="6" class="p-8 text-center">No users found.</td>
            </tr>
          }
        </tbody>
      </table>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class AdminUserListComponent {
  users = input.required<readonly AdminUser[]>();
  editClicked = output<string>();
  deleteClicked = output<string>();

  protected readonly AppIcon = AppIcon;
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/ui/src/lib/components/permission-manager/permission-manager.component.ts ---
/**
 * @file permission-manager.component.ts
 * @version 2.0.0 (SuperAdmin Protection)
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-07-30
 * @description Dumb component for managing permissions of a role, with protection for SuperAdmin.
 */
import { Component, ChangeDetectionStrategy, input, output, signal, computed, effect, booleanAttribute } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Permission } from '@royal-code/features/admin-users/domain';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { TranslateModule } from '@ngx-translate/core';

@Component({
  selector: 'admin-permission-manager',
  standalone: true,
  imports: [CommonModule, FormsModule, TranslateModule, UiButtonComponent, UiSpinnerComponent],
  template: `
    <div class="p-4 bg-background border-t border-border">
      @if (isLoading()) {
        <div class="flex items-center justify-center p-4"><royal-code-ui-spinner /></div>
      } @else {
        <form (ngSubmit)="onSave()">
          <h4 class="text-sm font-semibold mb-3 text-foreground">Permissions</h4>
           @if (isSuperAdmin()) {
            <p class="text-xs text-sun bg-sun/10 p-2 rounded-md mb-3">
              SuperAdmin has all permissions by default. These cannot be changed.
            </p>
          }
          <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-3 max-h-48 overflow-y-auto pr-2">
            @for(permission of allPermissions(); track permission.value) {
              <label class="flex items-center text-sm p-2 rounded-md cursor-pointer" [class.hover:bg-hover]="!isSuperAdmin()">
                <input
                  type="checkbox"
                  class="mr-2 h-4 w-4 rounded text-primary focus:ring-primary border-border"
                  [checked]="selection().has(permission.value)"
                  (change)="togglePermission(permission.value)"
                  [disabled]="isSuperAdmin()"
                />
                <span class="flex flex-col">
                  <span class="font-medium text-foreground">{{ permission.value }}</span>
                  <span class="text-xs text-muted">{{ permission.description }}</span>
                </span>
              </label>
            }
          </div>
          @if (!isSuperAdmin()) {
            <div class="flex justify-end mt-4 pt-4 border-t border-border">
              <royal-code-ui-button type="primary" htmlType="submit" [disabled]="!isDirty()">
                Save Permissions
              </royal-code-ui-button>
            </div>
          }
        </form>
      }
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class PermissionManagerComponent {
  allPermissions = input.required<readonly Permission[]>();
  assignedPermissions = input<readonly Permission[] | undefined>();
  isLoading = input<boolean>(false);
  isSuperAdmin = input(false, { transform: booleanAttribute }); // Nieuwe input
  savePermissions = output<string[]>();

  protected selection = signal<Set<string>>(new Set());
  private initialSelection = new Set<string>();
  
  protected isDirty = computed(() => {
    if (this.isSuperAdmin()) return false; // SuperAdmin is nooit 'dirty'
    if (this.selection().size !== this.initialSelection.size) return true;
    for (const item of this.selection()) {
      if (!this.initialSelection.has(item)) return true;
    }
    return false;
  });

  constructor() {
    effect(() => {
      const assigned = this.assignedPermissions();
      // Als het SuperAdmin is, selecteer dan ALLES.
      const newSelection = this.isSuperAdmin()
        ? new Set(this.allPermissions().map(p => p.value))
        : new Set(assigned?.map(p => p.value) ?? []);
      
      this.selection.set(newSelection);
      this.initialSelection = new Set(newSelection);
    });
  }

  togglePermission(permissionValue: string): void {
    if (this.isSuperAdmin()) return; // Extra beveiliging
    this.selection.update(currentSet => {
      const newSet = new Set(currentSet);
      if (newSet.has(permissionValue)) {
        newSet.delete(permissionValue);
      } else {
        newSet.add(permissionValue);
      }
      return newSet;
    });
  }

  onSave(): void {
    if (this.isSuperAdmin()) return; // Extra beveiliging
    this.savePermissions.emit(Array.from(this.selection()));
    this.initialSelection = new Set(this.selection());
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/admin-users/ui/src/lib/components/role-management-dialog/role-management-dialog.component.ts ---
/**
 * @file role-management-dialog.component.ts
 * @version 1.0.0
 * @author Royal-Code MonorepoAppDevAI
 * @date 2025-07-29
 * @description Dialog for creating, updating, and deleting roles.
 */
import { Component, ChangeDetectionStrategy, inject, output, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { DYNAMIC_OVERLAY_DATA, DYNAMIC_OVERLAY_REF, DynamicOverlayRef } from '@royal-code/ui/overlay';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiIconComponent } from '@royal-code/ui/icon';
import { AppIcon } from '@royal-code/shared/domain';
import { CreateRolePayload, Role, UpdateRolePayload } from '@royal-code/features/admin-users/domain';
import { TranslateModule, TranslateService } from '@ngx-translate/core';

@Component({
  selector: 'admin-role-management-dialog',
  standalone: true,
  imports: [CommonModule, FormsModule, TranslateModule, UiTitleComponent, UiButtonComponent, UiInputComponent, UiIconComponent],
  template: `
    <div class="p-6 bg-card rounded-xs shadow-lg w-full max-w-md">
      <!-- === HEADER === -->
      <div class="flex justify-between items-center mb-4">
        <royal-code-ui-title [level]="TitleTypeEnum.H2" [text]="'admin.roles.manageRoles' | translate" />
        <royal-code-ui-button type="transparent" sizeVariant="icon" (clicked)="close()">
          <royal-code-ui-icon [icon]="AppIcon.X" />
        </royal-code-ui-button>
      </div>

      <!-- === CREATE NEW ROLE FORM === -->
      <div class="flex items-center gap-2 mb-6 pb-6 border-b border-border">
        <royal-code-ui-input
          class="flex-grow"
          [(ngModel)]="newRoleName"
          [placeholder]="'admin.roles.newRolePlaceholder' | translate"
          (keydown.enter)="onCreateRole()"
        />
        <royal-code-ui-button type="primary" (clicked)="onCreateRole()" [disabled]="!newRoleName.trim()">
          {{ 'admin.roles.createButton' | translate }}
        </royal-code-ui-button>
      </div>

      <!-- === EXISTING ROLES LIST === -->
      <div class="space-y-2 max-h-64 overflow-y-auto">
        @for(role of data.roles; track role.id) {
          <div class="flex items-center justify-between p-2 rounded-md hover:bg-hover group">
            <span class="text-foreground">{{ role.name }}</span>
            <div class="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
              <royal-code-ui-button type="outline" sizeVariant="icon" (clicked)="onUpdateRole(role)" [title]="'common.buttons.edit' | translate">
                <royal-code-ui-icon [icon]="AppIcon.Edit" sizeVariant="sm" />
              </royal-code-ui-button>
              <royal-code-ui-button type="fire" sizeVariant="icon" (clicked)="onDeleteRole(role)" [title]="'common.buttons.delete' | translate">
                <royal-code-ui-icon [icon]="AppIcon.Trash2" sizeVariant="sm" />
              </royal-code-ui-button>
            </div>
          </div>
        }
      </div>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class RoleManagementDialogComponent {
  // === DEPENDENCIES ===
  private readonly overlayRef = inject(DYNAMIC_OVERLAY_REF);
  public readonly data: { roles: Role[] } = inject(DYNAMIC_OVERLAY_DATA);
  private readonly translate = inject(TranslateService);

  // === OUTPUTS ===
  create = output<CreateRolePayload>();
  update = output<UpdateRolePayload>();
  delete = output<string>(); // Outputs roleId

  // === INTERNAL STATE ===
  protected newRoleName = '';
  protected readonly AppIcon = AppIcon;
  protected readonly TitleTypeEnum = TitleTypeEnum;

  // === PUBLIC METHODS ===
  close(): void {
    this.overlayRef.close();
  }

  onCreateRole(): void {
    const trimmedName = this.newRoleName.trim();
    if (trimmedName) {
      this.create.emit({ name: trimmedName });
      this.newRoleName = ''; // Reset form
    }
  }

  onUpdateRole(role: Role): void {
    const newName = prompt(this.translate.instant('admin.roles.prompts.newNameForRole', { roleName: role.name }));
    if (newName && newName.trim()) {
      this.update.emit({ id: role.id, name: newName.trim() });
    }
  }

  onDeleteRole(role: Role): void {
    if (confirm(this.translate.instant('admin.roles.prompts.confirmDeleteRole', { roleName: role.name }))) {
      this.delete.emit(role.id);
    }
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/chat/core/src/index.ts ---
/**
 * @file index.ts (chat-core)
 * @description Public API for the chat core library.
 */
export * from './lib/state/chat.facade';
export * from './lib/state/chat.providers';
export * from './lib/data-access/abstract-chat-api.service';
export * from './lib/mappers/chat-mapping.service';

export * from './lib/state/chat.actions';
export * from './lib/state/chat.effects';
export * from './lib/state/chat.reducers';
export * from './lib/state/chat.selectors';
export * from './lib/state/chat.state';
export * from './lib/state/chat.feature';
--- END OF FILE ---

--- START OF FILE libs/features/chat/core/src/lib/data-access/abstract-chat-api.service.ts ---
/**
 * @file abstract-chat-api.service.ts
 * @Version 3.0.0 (Anonymous Chat Support)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-30
 * @description
 *   Abstract service defining the contract for the chat data-access layer.
 *   This version adds support for the full anonymous chat lifecycle, including
 *   sending messages and associating the session with a user account after login.
 */
import { Observable } from 'rxjs';
import { Conversation, Message, ConversationType } from '@royal-code/features/chat/domain';
import { PaginatedList } from '@royal-code/shared/utils';
import { Media } from '@royal-code/shared/domain';
import { AnonymousChatResponseDto, AnonymousConversationDto, AnonymousSendMessagePayloadDto, BackendMessageDto } from '@royal-code/features/chat/data-access-plushie';

export abstract class AbstractChatApiService {
  abstract getConversations(): Observable<Conversation[]>;
  abstract getMessages(conversationId: string, before?: string, limit?: number): Observable<PaginatedList<Message>>;
  abstract sendMessage(conversationId: string, content: string, media?: Media[], gifUrl?: string): Observable<Message>;

  abstract startConversation(
    conversationType: ConversationType.AIBOT | ConversationType.DIRECTMESSAGE,
    targetUserId?: string,
    initialMessageContent?: string
  ): Observable<Conversation>;

  abstract sendMessageToAiBot(
    conversationId: string,
    content: string,
    media?: Media[],
    gifUrl?: string
  ): Observable<{ userMessage: Message; botReply: Message }>;

/**
   * @method sendAnonymousMessageToAiBot
   * @description Sends a message as an anonymous user to the AI bot.
   * @param payload The message content and AI persona ID.
   * @param anonymousSessionId Optional ID for an existing anonymous session.
   * @returns An Observable of the AnonymousChatResponseDto from the AI, which includes the session ID.
   */
  abstract sendAnonymousMessageToAiBot(
    payload: AnonymousSendMessagePayloadDto,
    anonymousSessionId?: string | null
  ): Observable<AnonymousChatResponseDto>; 

  /**
   * @method associateAnonymousChat
   * @description Associates a given anonymous chat session with the currently authenticated user.
   * @param anonymousSessionId The ID of the session to associate.
   * @returns An Observable that completes with void on success.
   */
  abstract associateAnonymousChat(anonymousSessionId: string): Observable<void>;

  /**
   * @method getAnonymousConversation
   * @description Retrieves the full conversation history for a given anonymous session ID.
   * @param anonymousSessionId The unique identifier of the anonymous chat session.
   * @returns An Observable of the AnonymousConversationDto, or null if not found.
   */
  abstract getAnonymousConversation(anonymousSessionId: string): Observable<AnonymousConversationDto | null>;

}
--- END OF FILE ---

--- START OF FILE libs/features/chat/core/src/lib/mappers/chat-mapping.service.ts ---
/**
 * @file chat-mapping.service.ts
 * @Version 3.1.0 (Restored to Clean Mapping)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-29
 * @description
 *   This clean version of the mapper trusts the backend to provide the correct
 *   message status. The defensive `status: MessageStatus.SENT` override has been
 *   removed now that the backend bug is fixed, restoring a clean data flow.
 */
import { Injectable } from '@angular/core';
import { Message, MessageStatus } from '@royal-code/features/chat/domain';
import { BackendMessageDto } from '@royal-code/features/chat/data-access-plushie';
import { DateTimeUtil } from '@royal-code/shared/utils';
import { MediaType, Image } from '@royal-code/shared/domain';

@Injectable({ providedIn: 'root' })
export class ChatMappingService {

  public mapMessage(dto: BackendMessageDto): Message {
    return {
      id: dto.id,
      conversationId: dto.conversationId,
      senderId: dto.sender.id,
      senderType: 'user', // Aanname, dit moet wellicht uit de DTO komen
      senderProfile: {
          id: dto.sender.id,
          displayName: dto.sender.displayName || 'Unknown User',
          avatar: dto.sender.avatarUrl ? { id: 'avatar-' + dto.sender.id, type: MediaType.IMAGE, variants: [{ url: dto.sender.avatarUrl, purpose: 'thumbnail' }] } as Image : undefined
      },
      content: dto.content,
      createdAt: DateTimeUtil.fromISO(dto.timestamp),
      // --- DE FIX IS HIER ---
      // We vertrouwen nu weer op de status die de (gefixte) backend ons geeft.
      status: dto.status ?? MessageStatus.SENT, // Fallback voor het geval de DTO het veld mist
    };
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/chat/core/src/lib/state/chat.actions.ts ---
/**
 * @file chat.actions.ts
 * @version 3.0.0 (Refactored for StructuredError & Payload Consistency)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-28
 * @description
 *   Defines all NgRx actions for the Chat domain, now consistently using `StructuredError`
 *   for error payloads and ensuring `SendMessagePayload.tempId` is explicitly required.
 *   This version aligns with the enterprise blueprint for robust state management.
 */
import { createActionGroup, emptyProps, props } from '@ngrx/store';
import { Update } from '@ngrx/entity';
import { Conversation, Message } from '@royal-code/features/chat/domain';
import { ReactionType } from '@royal-code/features/social/domain';
import { Media } from '@royal-code/shared/domain';
import { ConversationType } from '@royal-code/features/chat/domain';


// --- IMPORTS VOOR STRUCTURED ERROR ---
import { StructuredError } from '@royal-code/shared/domain'; 
import { AnonymousConversationDto, AnonymousSendMessagePayloadDto } from '@royal-code/features/chat/data-access-plushie';

// Payload voor het verzenden van een nieuw bericht
export interface SendMessagePayload {
  conversationId: string;
  senderId: string;
  content: string;
  media?: (File | Media)[];
  gifUrl?: string;
  tempId: string; 
}

// << GEBRUIK NU STRUCTUREDERROR OVERAL WAAR EEN FOUT WORDT VERSTUURD >>
export type ChatErrorPayload = { error: StructuredError };

export const ChatActions = createActionGroup({
  source: 'Chat',
  events: {
    // --- Conversation Actions ---
    'Load Conversations Requested': emptyProps(),
    'Load Conversations Success': props<{ conversations: Conversation[] }>(),
    'Load Conversations Failure': props<ChatErrorPayload>(), // << AANGEPAST

    'Load Anonymous Conversation Requested': props<{ anonymousSessionId: string }>(),
    'Load Anonymous Conversation Success': props<{ conversation: Conversation; messages: Message[] }>(),
    'Load Anonymous Conversation Failure': props<ChatErrorPayload>(),

    'Select Conversation': props<{ conversationId: string | null }>(),

    'Start Conversation Requested': props<{ conversationType: ConversationType.AIBOT | ConversationType.DIRECTMESSAGE; targetUserId?: string; initialMessage?: Partial<Message> }>(),
    'Start Conversation Success': props<{ conversation: Conversation }>(),
    'Start Conversation Failure': props<ChatErrorPayload>(), // << AANGEPAST

    // --- Message Actions ---
    'Load Messages Requested': props<{ conversationId: string; beforeMessageId?: string; limit?: number }>(),
    'Load Messages Success': props<{ conversationId: string; messages: readonly Message[]; prepended?: boolean }>(),
    'Load Messages Failure': props<{ conversationId: string } & ChatErrorPayload>(), // << AANGEPAST

    'Send Message Requested': props<{ payload: SendMessagePayload }>(),
    'Send Message Success': props<{ conversationId: string; sentMessage: Message; tempId: string }>(),
    'Send Message Failure': props<{ conversationId:string; tempId: string } & ChatErrorPayload>(), // << AANGEPAST

    'Send Message To AI Bot Requested': props<{ payload: SendMessagePayload }>(),
  'Send Message To AI Bot Success': props<{
        userMessage: Message;
        botReply: Message;
        tempId: string;
        conversationId: string; 
    }>(),
    'Send Message To AI Bot Failure': props<{ conversationId:string; tempId: string } & ChatErrorPayload>(),

    // --- Real-time & UI Updates ---
    'Message Received': props<{ conversationId: string; message: Message }>(),
    'Message Updated': props<{ conversationId: string; messageUpdate: Update<Message> }>(),
    'Message Deleted': props<{ conversationId: string; messageId: string }>(),

    // --- React To Message ---
    'React To Message Requested': props<{ conversationId: string; messageId: string; reactionType: ReactionType | null }>(),
    'React To Message Success': props<{ conversationId: string; messageUpdate: Update<Message> }>(),
    'React To Message Failure': props<{ conversationId: string; messageId: string } & ChatErrorPayload>(), // << AANGEPAST

    'Edit Message Requested': props<{ conversationId: string; messageUpdate: Update<Message> }>(),
    'Edit Message Success': props<{ conversationId: string; messageUpdate: Update<Message> }>(),
    'Edit Message Failure': props<{ conversationId: string; messageId: string } & ChatErrorPayload>(), // << AANGEPAST

    'Delete Message Requested': props<{ conversationId: string; messageId: string }>(),
    'Delete Message Success': props<{ conversationId: string; messageId: string }>(),
    'Delete Message Failure': props<{ conversationId: string; messageId: string } & ChatErrorPayload>(), // << AANGEPAST

    'Report Message Requested': props<{ conversationId: string; messageId: string; reason: string }>(),
    'Report Message Success': props<{ conversationId: string; messageId: string }>(),
    'Report Message Failure': props<{ conversationId: string; messageId: string } & ChatErrorPayload>(), // << AANGEPAST

    // === ANONYMOUS AI CHAT FLOW ===
    'Send Anonymous Message To AI Bot Requested': props<{ payload: AnonymousSendMessagePayloadDto; tempId: string }>(),
'Send Anonymous Message To AI Bot Success': props<{
      userMessage: Message;
      aiReply: Message;
      anonymousSessionId: string;
      tempId: string
    }>(),
    'Send Anonymous Message To AI Bot Failure': props<{ error: StructuredError; tempId: string }>(),

    // === CHAT ASSOCIATION FLOW ===
    'Associate Anonymous Chat On Login': emptyProps(),
    'Associate Anonymous Chat Success': emptyProps(),
    'Associate Anonymous Chat Failure': props<ChatErrorPayload>(),
    
    // Clear Chat Error: deze actie ontvangt al de scope en optionele conversationId,
    // en de reducer zal de error uit de state verwijderen. De payload hoeft hier
    // geen error object meer mee te geven als je de error via een andere action dispatchet.
    'Clear Chat Error': props<{ scope: 'Conversations' | 'Messages'; conversationId?: string }>(),
  }
});
--- END OF FILE ---

--- START OF FILE libs/features/chat/core/src/lib/state/chat.effects.ts ---
/**
 * @file chat.effects.ts
 * @version 5.0.0 (Definitive, Corrected & Complete)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-30
 * @description
 *   The definitive, enterprise-grade effects for the Chat domain. This version
 *   corrects all previous dependency injection and import errors. It implements
 *   a robust, streamlined effect for associating anonymous chat sessions upon
 *   user login and contains the complete logic for all chat-related side effects.
 */
import { Injectable, inject } from '@angular/core';
import { HttpErrorResponse, HttpEvent, HttpEventType, HttpResponse } from '@angular/common/http';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { Action, Store } from '@ngrx/store';
import { of, Observable, forkJoin, throwError } from 'rxjs';
import { map, switchMap, catchError, mergeMap, exhaustMap, tap, filter, withLatestFrom } from 'rxjs/operators';

// --- Domain & State ---
import { Conversation, ConversationType, Message } from '@royal-code/features/chat/domain';
import { Media, StructuredError } from '@royal-code/shared/domain';
import { AuthActions } from '@royal-code/store/auth';
import { ErrorActions } from '@royal-code/store/error';
import { ChatActions } from './chat.actions';

// --- Services ---
import { StorageService } from '@royal-code/core/storage';
import { LoggerService } from '@royal-code/core/logging';
import { NotificationService } from '@royal-code/ui/notifications';
import { ChatMappingService } from '../mappers/chat-mapping.service';
import { AbstractChatApiService } from '../data-access/abstract-chat-api.service';
import { PlushieMediaApiService } from '@royal-code/features/media/data-access-plushie';
import { TranslateService } from '@ngx-translate/core';
import { LoginComponent } from '@royal-code/features/authentication';
import { DynamicOverlayService } from '@royal-code/ui/overlay';
import { AnonymousChatResponseDto } from '@royal-code/features/chat/data-access-plushie';

const ANONYMOUS_AI_SESSION_ID_KEY = 'anonymousAiSessionId';

@Injectable()
export class ChatEffects {
  // === DEPS ===
  private readonly actions$ = inject(Actions);
  private readonly store = inject(Store);
  private readonly chatApiService = inject(AbstractChatApiService);
  private readonly mappingService = inject(ChatMappingService);
  private readonly storageService = inject(StorageService);
  private readonly mediaService = inject(PlushieMediaApiService);
  private readonly logger = inject(LoggerService);
  private readonly notificationService = inject(NotificationService);
  private readonly logPrefix = '[ChatEffects]';
  private readonly overlayService = inject(DynamicOverlayService);
  private readonly translate = inject(TranslateService);

  // === CATEGORY: ANONYMOUS & AUTHENTICATION FLOWS ===

sendAnonymousMessage$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ChatActions.sendAnonymousMessageToAIBotRequested),
      mergeMap(({ payload, tempId }) => {
        const sessionId = this.storageService.getItem<string>(ANONYMOUS_AI_SESSION_ID_KEY);
        return this.chatApiService.sendAnonymousMessageToAiBot(payload, sessionId).pipe(
          map((response: AnonymousChatResponseDto) => { // <-- FIX: Type-assertie toegevoegd
            if (response.anonymousSessionId) {
              this.storageService.setItem(ANONYMOUS_AI_SESSION_ID_KEY, response.anonymousSessionId);
            }
            const userMessage = this.mappingService.mapMessage(response.userMessage);
            const aiReply = this.mappingService.mapMessage(response.aiReply);

            // --- FIX: Zorg ervoor dat `anonymousSessionId` altijd een string is ---
            const finalAnonymousSessionId = response.anonymousSessionId ?? ''; // Default naar lege string

            return ChatActions.sendAnonymousMessageToAIBotSuccess({
              userMessage,
              aiReply,
              anonymousSessionId: finalAnonymousSessionId, // <-- FIX: Gebruik de gegarandeerde string
              tempId,
            });
          }),
          catchError((error: unknown) => {
            if (error instanceof HttpErrorResponse && error.status === 403 && error.error?.errorCode === 'MESSAGE_LIMIT_REACHED') {
              return of(AuthActions.loginPromptRequired({
                messageKey: 'chat.errors.messageLimitReached',
                reason: 'MESSAGE_LIMIT_REACHED'
              }));
            }
            return of(ChatActions.sendAnonymousMessageToAIBotFailure({
              error: this.createStructuredError(error, 'Send Anonymous AI Message'),
              tempId,
            }));
          })
        );
      })
    )
  );





  associateOnLogin$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AuthActions.loginSuccess),
      exhaustMap(() => {
        const sessionId = this.storageService.getItem<string>(ANONYMOUS_AI_SESSION_ID_KEY);
        if (!sessionId) {
          return of({ type: '[ChatEffects] Association skipped, no session ID found.' });
        }
        return this.chatApiService.associateAnonymousChat(sessionId).pipe(
          map(() => {
            this.storageService.removeItem(ANONYMOUS_AI_SESSION_ID_KEY);
            this.notificationService.showSuccess('Vorige chat is opgeslagen in je account!');
            return ChatActions.loadConversationsRequested();
          }),
          catchError((error: unknown) => {
             this.logger.error(`${this.logPrefix} Failed to associate anonymous chat.`, error);
             this.storageService.removeItem(ANONYMOUS_AI_SESSION_ID_KEY);
             const structuredError = this.createStructuredError(error, 'Associate Anonymous Chat');
             return of(ChatActions.associateAnonymousChatFailure({ error: structuredError }), ErrorActions.reportError({ error: structuredError }));
          })
        );
      })
    )
  );


  // === CATEGORY: STANDARD CHAT OPERATIONS (Authenticated) ===

  loadConversations$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ChatActions.loadConversationsRequested),
      switchMap(() =>
        this.chatApiService.getConversations().pipe(
          map((conversations: Conversation[]) => ChatActions.loadConversationsSuccess({ conversations })),
          catchError((error: unknown) => of(ChatActions.loadConversationsFailure({ error: this.createStructuredError(error, 'Load Conversations') })))
        )
      )
    )
  );

  startConversation$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ChatActions.startConversationRequested),
      mergeMap(({ conversationType, targetUserId, initialMessage }) =>
        this.chatApiService.startConversation(conversationType, targetUserId, initialMessage?.content).pipe(
          map((conversation: Conversation) => ChatActions.startConversationSuccess({ conversation })),
          catchError((error: unknown) => of(ChatActions.startConversationFailure({ error: this.createStructuredError(error, 'Start Conversation', { conversationType, targetUserId }) })))
        )
      )
    )
  );

  sendMessage$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ChatActions.sendMessageRequested),
       mergeMap(({ payload }) => {
        const filesToUpload: File[] = (payload.media ?? []).filter((item): item is File => item instanceof File);
        const { conversationId, content, gifUrl, tempId } = payload;

        return this.uploadMediaAndProceed(filesToUpload).pipe(
            switchMap((uploadedMedia: Media[]) =>
              this.chatApiService.sendMessage(conversationId, content, uploadedMedia.length > 0 ? uploadedMedia : undefined, gifUrl).pipe(
                map((sentMessage: Message) => ChatActions.sendMessageSuccess({ conversationId, sentMessage, tempId })),
                catchError((error: unknown) => of(ChatActions.sendMessageFailure({ conversationId, tempId, error: this.createStructuredError(error, 'Send Message') })))
              )
            ),
            catchError((uploadError: unknown) => of(ChatActions.sendMessageFailure({ conversationId, tempId, error: this.createStructuredError(uploadError, 'File Upload for Send Message') })))
        );
      })
    )
  );

  loadAnonymousConversation$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ChatActions.loadAnonymousConversationRequested),
      exhaustMap(({ anonymousSessionId }) =>
        this.chatApiService.getAnonymousConversation(anonymousSessionId).pipe(
          map(responseDto => {
            if (responseDto) {
              const messages = responseDto.messages.map(dto => this.mappingService.mapMessage(dto));
              const conversation: Conversation = {
                id: responseDto.conversationId,
                type: ConversationType.AIBOT,
                name: responseDto.aiPersona.name,
                lastMessage: messages.length ? messages[messages.length - 1] : undefined,
              } as Conversation;
              return ChatActions.loadAnonymousConversationSuccess({ conversation, messages });
            }
            // Als de backend null retourneert (404), is de sessie ongeldig
            this.storageService.removeItem(ANONYMOUS_AI_SESSION_ID_KEY);
            return ChatActions.loadAnonymousConversationFailure({
              error: this.createStructuredError(new Error(`Session ${anonymousSessionId} not found or expired.`), 'Load Anonymous Conversation')
            });
          }),
          catchError((error: unknown) => {
            this.logger.error(`${this.logPrefix} Failed to load anonymous conversation.`, error);
            this.storageService.removeItem(ANONYMOUS_AI_SESSION_ID_KEY); // Verwijder de ongeldige ID
            return of(ChatActions.loadAnonymousConversationFailure({
              error: this.createStructuredError(error, 'Load Anonymous Conversation')
            }));
          })
        )
      )
    )
  );


  sendMessageToAiBot$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ChatActions.sendMessageToAIBotRequested),
      mergeMap(({ payload }) => {
        const { conversationId, content, gifUrl, tempId, media } = payload;
        const filesToUpload: File[] = (media ?? []).filter((item): item is File => item instanceof File);

        return this.uploadMediaAndProceed(filesToUpload).pipe(
          switchMap((uploadedMedia: Media[]) =>
            this.chatApiService.sendMessageToAiBot(conversationId, content, uploadedMedia.length > 0 ? uploadedMedia : undefined, gifUrl).pipe(
              map(response => ChatActions.sendMessageToAIBotSuccess({
                userMessage: response.userMessage,
                botReply: response.botReply,
                tempId,
                conversationId: response.userMessage.conversationId // <-- DE FIX
              })),
              catchError((error: unknown) => of(ChatActions.sendMessageToAIBotFailure({ conversationId, tempId, error: this.createStructuredError(error, 'Send AI Message') })))
            )
          ),
          catchError((uploadError: unknown) => of(ChatActions.sendMessageToAIBotFailure({ conversationId, tempId, error: this.createStructuredError(uploadError, 'Upload for AI Message') })))
        );
      })
    )
  );


  // === UTILITY METHODS ===

  private uploadMediaAndProceed(filesToUpload: File[]): Observable<Media[]> {
    if (filesToUpload.length === 0) {
        return of([]);
    }
    const uploadObservables$: Observable<Media>[] = filesToUpload.map((file: File) =>
      this.mediaService.uploadMediaWithProgress(file).pipe(
        filter((event: HttpEvent<Media>): event is HttpResponse<Media> => event.type === HttpEventType.Response),
        map(event => {
          if (event.body) return event.body;
          throw new Error(`Invalid media data for ${file.name}.`);
        })
      )
    );
    return forkJoin(uploadObservables$);
  }

  private createStructuredError(error: unknown, operation: string, context: Record<string, any> = {}): StructuredError {
    const rawMessage = (error instanceof Error) ? error.message : 'An unknown error occurred';
    return {
      message: `${operation} failed: ${rawMessage.split('\n')[0]}`,
      code: `CHAT_${operation.toUpperCase().replace(/\s/g, '_')}_FAILED`,
      operation,
      context: { ...context, rawError: rawMessage },
      timestamp: Date.now(),
      severity: 'error',
      source: this.logPrefix
    };
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/chat/core/src/lib/state/chat.facade.ts ---
/**
 * @file chat.facade.ts
 * @version 5.1.0 (Definitive with Anonymous Guest ID)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-30
 * @description
 *   The definitive, public-facing API for the Chat feature state. This facade
 *   now exposes the `anonymousGuestId` for consistent anonymous user identification
 *   in the UI layer.
 */
import { Injectable, inject, Signal, computed } from '@angular/core';
import { Store, select } from '@ngrx/store';
import { Observable, of } from 'rxjs';
import { take, tap, map, switchMap, filter, catchError, distinctUntilChanged, startWith } from 'rxjs/operators';
import { toSignal } from '@angular/core/rxjs-interop';
import { Update } from '@ngrx/entity';

import { ChatActions, SendMessagePayload } from './chat.actions';
import * as ChatSelectors from './chat.selectors';
import { LoggerService } from '@royal-code/core/logging';
import { DateTimeUtil } from '@royal-code/shared/utils';
import { Conversation, Message, ConversationType } from '@royal-code/features/chat/domain';
import { ReactionType } from '@royal-code/features/social/domain';
import { StructuredError } from '@royal-code/shared/domain';
import { AnonymousSendMessagePayloadDto } from '@royal-code/features/chat/data-access-plushie';
import { AuthFacade } from '@royal-code/store/auth';

@Injectable({ providedIn: 'root' })
export class ChatFacade {
  private readonly store = inject(Store);
  private readonly logger = inject(LoggerService);
  private readonly authFacade = inject(AuthFacade);
  private readonly logPrefix = '[ChatFacade]';

  // === EXPOSED STATE (SIGNALS) ===
  readonly allConversations: Signal<Conversation[]> = toSignal(this.store.pipe(select(ChatSelectors.selectAllConversations)), { initialValue: [] });
  readonly selectedConversation: Signal<Conversation | undefined> = toSignal(this.store.pipe(select(ChatSelectors.selectSelectedConversation)), { initialValue: undefined });
  readonly conversationsLoading: Signal<boolean> = toSignal(this.store.pipe(select(ChatSelectors.selectIsLoadingConversations)), { initialValue: true });
  readonly aiConversation: Signal<Conversation | undefined> = toSignal(this.store.pipe(select(ChatSelectors.selectAiConversation)), { initialValue: undefined });
  readonly aiConversationMessages: Signal<Message[]> = toSignal(this.store.pipe(select(ChatSelectors.selectAiConversationMessages)), { initialValue: [] });
  readonly currentSelectedConversationMessages: Signal<Message[]> = toSignal(this.store.pipe(select(ChatSelectors.selectMessagesForSelectedConversation)), { initialValue: [] });
  readonly selectedConversationMessagesLoading: Signal<boolean> = toSignal(this.store.pipe(select(ChatSelectors.selectSelectedConversationId), distinctUntilChanged(), switchMap(selectedId => selectedId ? this.store.pipe(select(ChatSelectors.selectMessagesLoadingForConversation(selectedId))) : of(false)), startWith(false)), { initialValue: false });
  readonly isAiChatLoading: Signal<boolean> = toSignal(this.store.select(ChatSelectors.selectIsAiChatLoading), { initialValue: false });
  readonly selectedConversationId: Signal<string | null> = toSignal(this.store.pipe(select(ChatSelectors.selectSelectedConversationId)), { initialValue: null });
  readonly anonymousGuestId: Signal<string | null> = toSignal(this.store.select(ChatSelectors.selectAnonymousGuestId), { initialValue: null });

  // === ACTION DISPATCHERS ===

  public ensureAiConversationIsActiveAndLoaded(): Observable<string | null> {
    const logCtx = `${this.logPrefix} [ensureAiConversationIsActiveAndLoaded]`;
    return this.store.pipe(
      select(ChatSelectors.selectAiConversation), take(1),
      switchMap(aiConv => {
        if (aiConv?.id) {
          if (this.selectedConversationId() !== aiConv.id) { this.selectConversation(aiConv.id); }
          this.loadMessagesIfNotLoaded(aiConv.id).pipe(take(1)).subscribe();
          return of(aiConv.id);
        } else {
          this.store.dispatch(ChatActions.startConversationRequested({ conversationType: ConversationType.AIBOT }));
          return this.store.pipe(
            select(ChatSelectors.selectAiConversation), filter((newlyCreatedConv): newlyCreatedConv is Conversation => !!(newlyCreatedConv?.id)),
            take(1),
            tap(newlyCreatedConvWithId => {
              this.selectConversation(newlyCreatedConvWithId.id);
              this.loadMessages(newlyCreatedConvWithId.id, undefined, 20);
            }),
            map(newlyCreatedConvWithId => newlyCreatedConvWithId.id)
          );
        }
      }),
      catchError(err => {
        this.logger.error(`${logCtx} CRITICAL error during ensure process:`, err);
        return of(null);
      })
    );
  }

  public sendMessageToAiBot(payload: Omit<SendMessagePayload, 'conversationId' | 'tempId' | 'senderId'> & { aiPersonaId: string }): void {
    const tempId = `temp-ai-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    const currentUserId = this.authFacade.currentUser()?.id;

    if (currentUserId) {
      this.logger.debug(`${this.logPrefix} Sending message as authenticated user.`);
      this.ensureAiConversationIsActiveAndLoaded().pipe(take(1)).subscribe({
        next: (aiConvId) => {
          if (aiConvId) {
            const finalPayload: SendMessagePayload = { ...payload, conversationId: aiConvId, tempId, senderId: currentUserId };
            this.store.dispatch(ChatActions.sendMessageToAIBotRequested({ payload: finalPayload }));
          } else {
            const error: StructuredError = { message: 'AI conversation could not be initialized.', code: 'CHAT_AI_CONV_INIT_FAILED', operation: 'sendMessageToAiBot', context: { tempId }, timestamp: Date.now(), severity: 'error' };
            this.store.dispatch(ChatActions.sendMessageToAIBotFailure({ conversationId: 'init-failed-ai-conv', tempId: tempId, error: error }));
          }
        }
      });
    } else {
      this.logger.debug(`${this.logPrefix} Sending message as anonymous user.`);
      const anonymousPayload: AnonymousSendMessagePayloadDto = {
        aiPersonaId: payload.aiPersonaId,
        content: payload.content,
      };
      this.store.dispatch(ChatActions.sendAnonymousMessageToAIBotRequested({ payload: anonymousPayload, tempId }));
    }
  }

  public sendMessage(payload: Omit<SendMessagePayload, 'tempId'>): void {
    const finalPayload: SendMessagePayload = { ...payload, tempId: `temp-msg-${Date.now()}` };
    this.store.dispatch(ChatActions.sendMessageRequested({ payload: finalPayload }));
  }

  public loadConversations(): void { this.store.dispatch(ChatActions.loadConversationsRequested()); }
  public selectConversation(conversationId: string | null): void { this.store.dispatch(ChatActions.selectConversation({ conversationId })); }
  public loadMessages(conversationId: string, beforeMessageId?: string, limit?: number): void { this.store.dispatch(ChatActions.loadMessagesRequested({ conversationId, beforeMessageId, limit })); }

  public loadMessagesIfNotLoaded(conversationId: string | null): Observable<boolean> {
    if (!conversationId) return of(false);
    return this.getAllMessagesLoadedForConversation$(conversationId).pipe(
      take(1),
      switchMap(areLoaded => this.getMessagesLoadingForConversation$(conversationId).pipe(
        take(1),
        tap(isLoading => { if (!isLoading && !areLoaded) this.loadMessages(conversationId); }),
        map(() => !areLoaded)
      ))
    );
  }

  public editMessage(conversationId: string, messageId: string, newContent: string): void {
    const messageUpdate: Update<Message> = { id: messageId, changes: { content: newContent, isEdited: true, lastModified: DateTimeUtil.now() } };
    this.store.dispatch(ChatActions.editMessageRequested({ conversationId, messageUpdate }));
  }

  public deleteMessage(conversationId: string, messageId: string): void {
    this.store.dispatch(ChatActions.deleteMessageRequested({ conversationId, messageId }));
  }

  public reportMessage(conversationId: string, messageId: string, reason: string): void {
    this.store.dispatch(ChatActions.reportMessageRequested({ conversationId, messageId, reason }));
  }

  // === OBSERVABLE ACCESSORS ===
  public getAllMessagesLoadedForConversation$(conversationId: string): Observable<boolean> {
    return this.store.pipe(select(ChatSelectors.selectAllMessagesLoadedForConversation(conversationId)));
  }

  public getMessagesLoadingForConversation$(conversationId: string): Observable<boolean> {
    return this.store.pipe(select(ChatSelectors.selectMessagesLoadingForConversation(conversationId)));
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/chat/core/src/lib/state/chat.feature.ts ---
/**
 * @file chat.feature.ts
 * @version 2.3.0 (Added Anonymous Guest ID Selector)
 * @description The definitive NgRx feature definition for the Chat domain.
 *              This version adds and exports the `selectAnonymousGuestId` selector.
 */
import { createFeature, createSelector } from '@ngrx/store';
import { chatReducer } from './chat.reducers';
import { conversationAdapter, messageAdapter } from './chat.state';
import { ChatViewModel } from './chat.types';
import { ConversationType } from '@royal-code/features/chat/domain';
import { StructuredError } from '@royal-code/shared/domain';

export const CHAT_FEATURE_KEY = 'chat';

export const chatFeature = createFeature({
  name: CHAT_FEATURE_KEY,
  reducer: chatReducer,
  extraSelectors: ({
    selectConversations, selectMessages, selectSelectedConversationId,
    selectIsLoadingConversations, selectIsLoadingMessages, selectIsSendingMessage,
    selectError, selectPagination, selectAnonymousGuestId,
  }) => {
    const { selectAll: selectAllConversations, selectEntities: selectConversationEntities } = conversationAdapter.getSelectors(selectConversations);
    const { selectAll: selectAllMessages } = messageAdapter.getSelectors(selectMessages);

    const selectSelectedConversation = createSelector(selectConversationEntities, selectSelectedConversationId, (entities, selectedId) => (selectedId ? entities[selectedId] : undefined));
    const selectMessagesForConversation = (conversationId: string) => createSelector(selectAllMessages, (allMessages) => allMessages.filter(msg => msg.conversationId === conversationId));
    const selectMessagesForSelectedConversation = createSelector(selectAllMessages, selectSelectedConversationId, (allMessages, selectedId) => { if (!selectedId) return []; return allMessages.filter(msg => msg.conversationId === selectedId); });
    const selectAiConversation = createSelector(selectAllConversations, (convs) => convs.find(c => c.type === ConversationType.AIBOT));
    const selectAiConversationMessages = createSelector(selectAllMessages, selectAiConversation, (allMessages, aiConv) => { if (!aiConv) return []; return allMessages.filter(msg => msg.conversationId === aiConv.id); });
    const selectConversationsError = createSelector(selectError, (errorState) => errorState.conversations);
    const selectMessagesLoadingForConversation = (conversationId: string) => createSelector(selectIsLoadingMessages, (loadingMap) => !!loadingMap[conversationId]);
    const selectMessagesErrorForConversation = (conversationId: string) => createSelector(selectError, (errorState) => errorState.messages[conversationId] ?? null);
    const selectAllMessagesLoadedForConversation = (conversationId: string) => createSelector(selectPagination, (paginationState) => paginationState[conversationId]?.allMessagesLoaded ?? false);
    const selectIsAiChatLoading = createSelector(selectIsLoadingConversations, selectIsLoadingMessages, selectAiConversation, (convsLoading, msgLoadingMap, aiConv) => { if (!aiConv) return convsLoading; return convsLoading || !!msgLoadingMap[aiConv.id]; });
    const selectAiChatError = createSelector(selectError, selectAiConversation, (errorState, aiConv) => { const convError = errorState.conversations; const msgError = aiConv?.id ? errorState.messages[aiConv.id] : null; return convError || msgError || null; });
    const selectChatViewModel = createSelector(
      selectAllConversations, selectSelectedConversation, selectMessagesForSelectedConversation,
      selectIsLoadingConversations, selectIsLoadingMessages, selectIsSendingMessage,
      selectError, selectSelectedConversationId,
      (conversations, selectedConversation, messages, isLoadingConv, msgLoadingMap, isSendingMap, errorState, selectedId): ChatViewModel => {
        let combinedError: StructuredError | null = null;
        if (errorState.conversations) { combinedError = errorState.conversations; }
        else if (selectedId && errorState.messages[selectedId]) { combinedError = errorState.messages[selectedId]; }
        return {
          conversations, selectedConversation, messages, isLoadingConversations: isLoadingConv,
          isLoadingMessages: selectedId ? !!msgLoadingMap[selectedId] : false,
          isSendingMessage: Object.values(isSendingMap).some(v => v),
          error: combinedError, hasConversations: conversations.length > 0, hasMessages: messages.length > 0,
          isBusy: isLoadingConv || (selectedId ? !!msgLoadingMap[selectedId] : false) || Object.values(isSendingMap).some(v => v),
        }
      }
    );
    return {
      selectAllConversations, selectConversationEntities, selectSelectedConversation, selectMessagesForConversation,
      selectMessagesForSelectedConversation, selectAiConversation, selectAiConversationMessages, selectIsAiChatLoading,
      selectAiChatError, selectChatViewModel, selectAllMessagesLoadedForConversation, selectMessagesLoadingForConversation,
      selectMessagesErrorForConversation, selectConversationsError,
    };
  },
});

export const {
  name, reducer, selectChatState, selectSelectedConversationId,
  selectIsLoadingConversations, selectIsSendingMessage,
  selectError, selectAllConversations, selectConversationEntities, selectSelectedConversation,
  selectMessagesForConversation, selectMessagesForSelectedConversation, selectAiConversation,
  selectAiConversationMessages, selectIsAiChatLoading, selectAiChatError, selectChatViewModel,
  selectAllMessagesLoadedForConversation, selectMessagesLoadingForConversation,
  selectMessagesErrorForConversation, selectConversationsError,
  selectAnonymousGuestId,
} = chatFeature;
--- END OF FILE ---

--- START OF FILE libs/features/chat/core/src/lib/state/chat.providers.ts ---
/**
 * @file chat.providers.ts
 * @description Provides the NgRx feature state and effects for the chat module.
 */
import { EnvironmentProviders, makeEnvironmentProviders } from '@angular/core';
import { provideState } from '@ngrx/store';
import { provideEffects } from '@ngrx/effects';
import { chatFeature } from './chat.feature';
import { ChatEffects } from './chat.effects';

export function provideChatFeature(): EnvironmentProviders {
  return makeEnvironmentProviders([
    provideState(chatFeature),
    provideEffects(ChatEffects),
  ]);
}
--- END OF FILE ---

--- START OF FILE libs/features/chat/core/src/lib/state/chat.reducers.ts ---
/**
 * @file chat.reducers.ts
 * @version 9.1.0 (Definitive with Anonymous Guest ID Sync)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-30
 * @Description
 *   The definitive, enterprise-grade reducer for the Chat domain. This version
 *   correctly synchronizes the `anonymousGuestId` from the backend API responses,
 *   ensuring consistent UI rendering for anonymous user messages.
 */
import { createReducer, on, Action } from '@ngrx/store';
import { initialChatState, ChatState, conversationAdapter, messageAdapter } from './chat.state';
import { ChatActions } from './chat.actions';
import { Conversation, Message, MessageStatus, ConversationType } from '@royal-code/features/chat/domain';
import { DateTimeUtil } from '@royal-code/shared/utils';
import { EntityState } from '@ngrx/entity';

const _chatReducer = createReducer(
  initialChatState,

  // === CATEGORY: CONVERSATION MANAGEMENT ===

  on(ChatActions.loadConversationsRequested, ChatActions.startConversationRequested, ChatActions.loadAnonymousConversationRequested, (state): ChatState => ({
    ...state,
    isLoadingConversations: true,
    error: { ...state.error, conversations: null },
  })),

  on(ChatActions.loadConversationsSuccess, (state, { conversations }): ChatState => ({
    ...state,
    conversations: conversationAdapter.setAll(conversations, state.conversations),
    isLoadingConversations: false,
  })),

  on(ChatActions.startConversationSuccess, (state, { conversation }): ChatState => ({
    ...state,
    conversations: conversationAdapter.addOne(conversation, state.conversations),
    isLoadingConversations: false,
  })),

  on(ChatActions.loadConversationsFailure, ChatActions.startConversationFailure, ChatActions.loadAnonymousConversationFailure, (state, { error }): ChatState => ({
    ...state,
    isLoadingConversations: false,
    error: { ...state.error, conversations: error },
  })),

  on(ChatActions.loadAnonymousConversationSuccess, (state, { conversation, messages }): ChatState => {
    const updatedConversations = conversationAdapter.upsertOne(conversation, state.conversations);
    const updatedMessages = messageAdapter.upsertMany(messages, state.messages);
    const userMessage = messages.find(m => m.senderProfile?.displayName === 'You');
    const guestId = userMessage?.senderId ?? null;

    return {
      ...state,
      conversations: updatedConversations,
      messages: updatedMessages,
      selectedConversationId: conversation.id,
      anonymousGuestId: guestId,
      isLoadingConversations: false,
    };
  }),

  // === CATEGORY: MESSAGE MANAGEMENT ===

  on(ChatActions.loadMessagesRequested, (state, { conversationId }): ChatState => ({
    ...state,
    isLoadingMessages: { ...state.isLoadingMessages, [conversationId]: true },
    error: { ...state.error, messages: { ...state.error.messages, [conversationId]: null } },
  })),

  on(ChatActions.loadMessagesSuccess, (state, { messages, conversationId }): ChatState => ({
    ...state,
    messages: messageAdapter.upsertMany([...messages], state.messages),
    isLoadingMessages: { ...state.isLoadingMessages, [conversationId]: false }
  })),

  on(ChatActions.loadMessagesFailure, (state, { conversationId, error }): ChatState => ({
    ...state,
    isLoadingMessages: { ...state.isLoadingMessages, [conversationId]: false },
    error: { ...state.error, messages: { ...state.error.messages, [conversationId]: error } },
  })),

  on(ChatActions.messageReceived, (state, { message }): ChatState => ({
    ...state,
    messages: messageAdapter.upsertOne(message, state.messages),
  })),


  // === CATEGORY: OPTIMISTIC MESSAGE SENDING (ALL FLOWS) ===

  on(ChatActions.sendMessageRequested, (state, { payload }): ChatState => {
    const optimisticMessage: Message = {
      id: payload.tempId,
      conversationId: payload.conversationId,
      content: payload.content,
      gifUrl: payload.gifUrl,
      media: [],
      status: MessageStatus.SENDING,
      senderId: payload.senderId,
      senderType: 'user',
      createdAt: DateTimeUtil.now(),
    };
    return {
      ...state,
      messages: messageAdapter.addOne(optimisticMessage, state.messages),
      isSendingMessage: { ...state.isSendingMessage, [payload.tempId]: true },
    };
  }),

  on(ChatActions.sendMessageToAIBotRequested, (state, { payload }): ChatState => {
    const optimisticMessage: Message = {
      id: payload.tempId,
      conversationId: payload.conversationId,
      content: payload.content,
      gifUrl: payload.gifUrl,
      media: [],
      status: MessageStatus.SENDING,
      senderId: payload.senderId,
      senderType: 'user',
      createdAt: DateTimeUtil.now(),
    };
    return {
      ...state,
      messages: messageAdapter.addOne(optimisticMessage, state.messages),
      isSendingMessage: { ...state.isSendingMessage, [payload.tempId]: true },
    };
  }),

  on(ChatActions.sendAnonymousMessageToAIBotRequested, (state, { payload, tempId }): ChatState => {
    const aiConv = Object.values(state.conversations.entities).find(c => c?.type === ConversationType.AIBOT);
    const optimisticMessage: Message = {
      id: tempId,
      conversationId: aiConv?.id ?? 'anonymous-ai-conv',
      content: payload.content,
      status: MessageStatus.SENDING,
      senderId: state.anonymousGuestId ?? 'anonymous-user',
      senderType: 'user',
      createdAt: DateTimeUtil.now(),
    };
    return {
      ...state,
      messages: messageAdapter.addOne(optimisticMessage, state.messages),
      isSendingMessage: { ...state.isSendingMessage, [tempId]: true },
    };
  }),

  // === CATEGORY: MESSAGE SEND SUCCESS (IDEMPOTENT & STATE SYNC) ===

  on(ChatActions.sendMessageSuccess, (state, { tempId, sentMessage, conversationId }): ChatState => {
    const { [tempId]: _, ...newIsSendingState } = state.isSendingMessage;
    const stateWithoutTemp = messageAdapter.removeOne(tempId, state.messages);
    const finalMessagesState = messageAdapter.upsertOne(sentMessage, stateWithoutTemp);

    const updatedConversation = conversationAdapter.updateOne({
      id: conversationId,
      changes: { lastMessage: sentMessage }
    }, state.conversations);

    return { ...state, messages: finalMessagesState, conversations: updatedConversation, isSendingMessage: newIsSendingState };
  }),

  on(ChatActions.sendMessageToAIBotSuccess, (state, { tempId, userMessage, botReply, conversationId }): ChatState => {
    const { [tempId]: _, ...newIsSendingState } = state.isSendingMessage;
    const stateWithoutTemp = messageAdapter.removeOne(tempId, state.messages);
    const finalMessagesState = messageAdapter.upsertMany([userMessage, botReply], stateWithoutTemp);

    const updatedConversation = conversationAdapter.updateOne({
      id: conversationId,
      changes: { lastMessage: botReply }
    }, state.conversations);

    return { ...state, messages: finalMessagesState, conversations: updatedConversation, isSendingMessage: newIsSendingState };
  }),

  on(ChatActions.sendAnonymousMessageToAIBotSuccess, (state, { userMessage, aiReply, tempId }): ChatState => {
    const { [tempId]: _, ...newIsSendingState } = state.isSendingMessage;
    const stateWithoutTemp = messageAdapter.removeOne(tempId, state.messages);
    const finalMessagesState = messageAdapter.upsertMany([userMessage, aiReply], stateWithoutTemp);

    const aiConvExists = !!state.conversations.entities[userMessage.conversationId];
    let finalConversationsState: EntityState<Conversation>;
  
    if (!aiConvExists) {
      finalConversationsState = conversationAdapter.addOne({
        id: userMessage.conversationId,
        type: ConversationType.AIBOT,
        name: 'Plushie Pal',
        lastMessage: aiReply,
      } as Conversation, state.conversations);
    } else {
      finalConversationsState = conversationAdapter.updateOne({
        id: userMessage.conversationId,
        changes: { lastMessage: aiReply }
      }, state.conversations);
    }

    return {
      ...state,
      messages: finalMessagesState,
      conversations: finalConversationsState,
      isSendingMessage: newIsSendingState,
      anonymousGuestId: userMessage.senderId,
    };
  }),

  // === CATEGORY: MESSAGE SEND FAILURE (ALL FLOWS) ===

  on(ChatActions.sendMessageFailure, ChatActions.sendMessageToAIBotFailure, ChatActions.sendAnonymousMessageToAIBotFailure, (state, { tempId, error }): ChatState => {
    if (!tempId) return state;
    const { [tempId]: __, ...newIsSendingState } = state.isSendingMessage;
    const messageUpdate = { id: tempId, changes: { status: MessageStatus.FAILED, error: error } };
    return { ...state, messages: messageAdapter.updateOne(messageUpdate, state.messages), isSendingMessage: newIsSendingState };
  }),

  // === CATEGORY: OTHER UPDATES & CLEANUP ===
  
  on(ChatActions.selectConversation, (state, { conversationId }): ChatState => ({
    ...state,
    selectedConversationId: conversationId,
  })),

  on(ChatActions.reactToMessageSuccess, ChatActions.editMessageSuccess, ChatActions.messageUpdated, (state, { messageUpdate }): ChatState => ({
    ...state,
    messages: messageAdapter.updateOne(messageUpdate, state.messages),
  })),

  on(ChatActions.deleteMessageSuccess, ChatActions.messageDeleted, (state, { messageId }): ChatState => ({
    ...state,
    messages: messageAdapter.removeOne(messageId, state.messages),
  })),

  on(ChatActions.clearChatError, (state, { scope, conversationId }): ChatState => {
    if (scope === 'Conversations') return { ...state, error: { ...state.error, conversations: null } };
    if (scope === 'Messages' && conversationId) {
      const { [conversationId]: _, ...remainingMessagesErrors } = state.error.messages;
      return { ...state, error: { ...state.error, messages: remainingMessagesErrors } };
    }
    return state;
  })
);

export function chatReducer(state: ChatState | undefined, action: Action): ChatState {
  return _chatReducer(state, action);
}
--- END OF FILE ---

--- START OF FILE libs/features/chat/core/src/lib/state/chat.selectors.ts ---
/**
 * @file chat.selectors.ts
 * @version 2.2.0 (Clean Export Gateway)
 * @description This file serves as a clean, public-facing export gateway for all
 *              selectors defined within `chat.feature.ts`.
 */
export {
  CHAT_FEATURE_KEY,
  selectChatState,
  selectSelectedConversationId,
  selectIsLoadingConversations,
  selectIsSendingMessage,
  selectError,
  selectAllConversations,
  selectConversationEntities,
  selectSelectedConversation,
  selectMessagesForConversation,
  selectMessagesForSelectedConversation,
  selectAiConversation,
  selectAiConversationMessages,
  selectIsAiChatLoading,
  selectAiChatError,
  selectChatViewModel,
  selectAllMessagesLoadedForConversation,
  selectMessagesLoadingForConversation,
  selectMessagesErrorForConversation,
  selectConversationsError,
  selectAnonymousGuestId,
} from './chat.feature';

import { createSelector } from '@ngrx/store';
import { selectConversationEntities } from './chat.feature';

export const selectConversationById = (id: string) => createSelector(
  selectConversationEntities,
  (entities) => entities?.[id]
);
--- END OF FILE ---

--- START OF FILE libs/features/chat/core/src/lib/state/chat.state.ts ---
/**
 * @file chat.state.ts
 * @version 2.3.0 (Corrected Interface & Anonymous Guest ID)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-30
 * @description Defines the NgRx state structure for the Chat feature, now
 *              with the `ChatState` interface correctly defined (not extending `EntityState`)
 *              and including the `anonymousGuestId` for consistent anonymous user identification.
 */
import { EntityState, createEntityAdapter, EntityAdapter } from '@ngrx/entity';
import { Conversation, Message } from '@royal-code/features/chat/domain';
import { StructuredError } from '@royal-code/shared/domain';

// === CATEGORY: ADAPTERS ===
export const conversationAdapter: EntityAdapter<Conversation> = createEntityAdapter<Conversation>({
  selectId: (conversation: Conversation) => conversation.id,
  sortComparer: (a, b) => (b.lastMessage?.createdAt?.timestamp ?? 0) - (a.lastMessage?.createdAt?.timestamp ?? 0),
});

export const messageAdapter: EntityAdapter<Message> = createEntityAdapter<Message>({
  selectId: (message: Message) => message.id,
  sortComparer: (a, b) => (a.createdAt?.timestamp ?? 0) - (b.createdAt?.timestamp ?? 0),
});

// === CATEGORY: STATE INTERFACE ===
export interface ChatState {
  conversations: EntityState<Conversation>;
  messages: EntityState<Message>;

  isLoadingConversations: boolean;
  isLoadingMessages: Record<string, boolean>; // Keyed by conversationId
  isSendingMessage: Record<string, boolean>; // Keyed by tempId
  error: {
    conversations: StructuredError | null;
    messages: Record<string, StructuredError | null>;
  };

  selectedConversationId: string | null;
  anonymousGuestId: string | null;
  pagination: Record<string, { allMessagesLoaded: boolean }>;
}

// === CATEGORY: INITIAL STATE ===
export const initialChatState: ChatState = {
  conversations: conversationAdapter.getInitialState(),
  messages: messageAdapter.getInitialState(),
  isLoadingConversations: false,
  isLoadingMessages: {},
  isSendingMessage: {},
  error: {
    conversations: null,
    messages: {},
  },
  selectedConversationId: null,
  anonymousGuestId: null,
  pagination: {},
};
--- END OF FILE ---

--- START OF FILE libs/features/chat/core/src/lib/state/chat.types.ts ---
/**
 * @file chat.types.ts
 * @version 2.1.0 (Synchronized with StructuredError)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-28
 * @description Defines TypeScript interfaces specific to the chat feature's NgRx state,
 *              now fully synchronized to store `StructuredError` objects.
 */

import { Conversation, Message } from "@royal-code/features/chat/domain";
import { StructuredError } from "@royal-code/shared/domain"; // << BELANGRIJKE IMPORT


/**
 * @interface ChatError
 * @description Represents a simple, localized error within the chat feature's state.
 *              Nu direct gekoppeld aan StructuredError, of als een deel ervan.
 */
export type ChatError = StructuredError; // << NU DIRECT STRUCTUREDERROR

/**
 * @interface ChatViewModel
 * @description A comprehensive, flattened data structure for a chat component.
 *              It aggregates all necessary state into a single object to simplify component logic.
 */
export interface ChatViewModel {
  readonly conversations: readonly Conversation[];
  readonly selectedConversation: Conversation | undefined;
  readonly messages: readonly Message[];
  readonly isLoadingConversations: boolean;
  readonly isLoadingMessages: boolean;
  readonly isSendingMessage: boolean;
  readonly error: StructuredError | null; // << AANGEPAST NAAR StructuredError
  readonly hasConversations: boolean;
  readonly hasMessages: boolean;
  readonly isBusy: boolean;
}
--- END OF FILE ---

--- START OF FILE libs/features/chat/data-access-plushie/src/index.ts ---
export * from './lib/services/plushie-chat-api.service';
export * from './lib/dto/backend.types';
--- END OF FILE ---

--- START OF FILE libs/features/chat/data-access-plushie/src/lib/dto/backend.types.ts ---
/**
 * @file backend.types.ts (chat/data-access-plushie)
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-28
 * @Description
 *   Defines the Data Transfer Object (DTO) contracts for the Chat API backend.
 */
import { Conversation, ConversationType, Message, MessageStatus } from '@royal-code/features/chat/domain';
import { AuditableEntityBase } from '@royal-code/shared/base-models';

export interface BackendParticipantDto {
  userId: string;
  displayName?: string;
  avatarUrl?: string;
}

export interface BackendSenderDto {
  id: string;
  displayName?: string;
  avatarUrl?: string;
}

export interface AnonymousSendMessagePayloadDto {
  aiPersonaId: string;
  content: string;
}

export interface BackendMessageDto {
  id: string;
  conversationId: string;
  sender: BackendSenderDto;
  content: string;
  timestamp: string; 
  isRead: boolean;
  status?: MessageStatus;
  anonymousSessionId?: string;
  replyToMessageId?: string; 
  isEdited?: boolean;       
}
export interface AnonymousChatResponseDto {
    userMessage: BackendMessageDto;
    aiReply: BackendMessageDto;
    anonymousSessionId: string; 
}

export interface AnonymousConversationDto {
    conversationId: string;
    anonymousSessionId: string;
    aiPersona: AIPersonaDto;
    messages: BackendMessageDto[]; 
}


export interface BackendConversationDto {
  id: string; 
  participants?: BackendParticipantDto[];
  type: ConversationType;
  createdAt?: string;
  lastModified?: string;
  lastMessage?: BackendMessageDto;
}


export interface StartConversationResponseDto {
  conversationId: string;
  isNew: boolean;
}

export interface AIPersonaDto {
  id: string;
  name: string;
  description?: string;
  avatarMediaId?: string;
}
--- END OF FILE ---

--- START OF FILE libs/features/chat/data-access-plushie/src/lib/services/plushie-chat-api.service.ts ---
/**
 * @file plushie-chat-api.service.ts
 * @version 4.0.1 (Definitive & Robust AI Bot Mock)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-29
 * @description
 *   The definitive, simplified, and architecturally correct implementation.
 *   This version includes a more robust and realistic mock for `sendMessageToAiBot`
 *   that correctly simulates the API returning the user's message before the bot replies.
 */
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable, of, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { APP_CONFIG } from '@royal-code/core/config';
import { AbstractChatApiService, ChatMappingService } from '@royal-code/features/chat/core';
import { Conversation, Message, ConversationType, MessageStatus } from '@royal-code/features/chat/domain';
import { DateTimeUtil, PaginatedList } from '@royal-code/shared/utils';
import { Media } from '@royal-code/shared/domain';
import { AnonymousChatResponseDto, AnonymousConversationDto, AnonymousSendMessagePayloadDto, BackendMessageDto, StartConversationResponseDto } from '../dto/backend.types';

@Injectable({ providedIn: 'root' })
export class PlushieChatApiService extends AbstractChatApiService {
  private readonly http = inject(HttpClient);
  private readonly config = inject(APP_CONFIG);
  private readonly mappingService = inject(ChatMappingService);
  private readonly apiUrl = `${this.config.backendUrl}/Chat`;

  override getConversations(): Observable<Conversation[]> {
    console.warn('[PlushieChatApiService] getConversations is mocked.');
    return of([]);
  }

  override getMessages(conversationId: string, before?: string, limit = 20): Observable<PaginatedList<Message>> {
    let params = new HttpParams().set('pageSize', limit.toString());
    if (before) {
        params = params.set('pageNumber', before);
    }
    return this.http.get<PaginatedList<BackendMessageDto>>(`${this.apiUrl}/conversations/${conversationId}/messages`, { params }).pipe(
      map(paginatedDto => ({
        ...paginatedDto,
        items: paginatedDto.items.map(dto => this.mappingService.mapMessage(dto))
      }))
    );
  }

  override sendMessage(conversationId: string, content: string, media?: Media[], gifUrl?: string): Observable<Message> {
    const payload = { content, mediaIds: media?.map(m => m.id), gifUrl };
    return this.http.post<BackendMessageDto>(`${this.apiUrl}/conversations/${conversationId}/messages`, payload).pipe(
      map(dto => this.mappingService.mapMessage(dto))
    );
  }

  override sendMessageToAiBot(
    conversationId: string,
    content: string,
    media?: Media[],
    gifUrl?: string
  ): Observable<{ userMessage: Message; botReply: Message }> {
    // Stap 1: Hergebruik de echte `sendMessage` om het bericht van de gebruiker te "versturen" en een bevestiging te krijgen.
    // De vernieuwde mapping service zorgt ervoor dat dit bericht `status: 'sent'` krijgt.
    return this.sendMessage(conversationId, content, media, gifUrl).pipe(
      map(confirmedUserMessage => {
        
        // Stap 2: Creëer het bot-antwoord. Dit antwoord moet OOK een expliciete 'sent' status hebben.
        const botReply: Message = {
          id: `bot-reply-to-${confirmedUserMessage.id}`,
          conversationId: confirmedUserMessage.conversationId,
          senderId: 'ai-persona-id-01',
          senderType: 'bot',
          senderProfile: { id: 'ai-persona-id-01', displayName: 'Plushie Pal' },
          content: `Dit is een gesimuleerd antwoord op: "${confirmedUserMessage.content.substring(0, 50)}..."`,
          createdAt: DateTimeUtil.now(),
          status: MessageStatus.SENT, // Expliciet instellen!
        };
        
        // Stap 3: Retourneer het object dat het effect verwacht, nu met correcte statussen.
        return { userMessage: confirmedUserMessage, botReply };
      })
    );
  }

  override startConversation(
    conversationType: ConversationType.AIBOT | ConversationType.DIRECTMESSAGE,
    targetUserId?: string,
    initialMessageContent?: string
  ): Observable<Conversation> {
    if (conversationType === ConversationType.AIBOT) {
      const payload = { aiPersonaName: 'Plushie Pal', initialMessageContent };
      return this.http.post<StartConversationResponseDto>(`${this.apiUrl}/conversations/ai-bot`, payload).pipe(
        map(responseDto => ({
          id: responseDto.conversationId,
          type: ConversationType.AIBOT,
          participantIds: [],
          isNew: responseDto.isNew,
        } as Conversation))
      );
    }

    if (conversationType === ConversationType.DIRECTMESSAGE && targetUserId) {
      const payload = { otherUserId: targetUserId, initialMessageContent };
      return this.http.post<StartConversationResponseDto>(`${this.apiUrl}/conversations/direct-message`, payload).pipe(
        map(responseDto => ({
          id: responseDto.conversationId,
          type: ConversationType.DIRECTMESSAGE,
          participantIds: [],
          isNew: responseDto.isNew,
        } as Conversation))
      );
    }
    
    return throwError(() => new Error('Invalid conversation type or missing targetUserId for user-to-user chat.'));
  }

override sendAnonymousMessageToAiBot(
    payload: AnonymousSendMessagePayloadDto,
    anonymousSessionId?: string | null
  ): Observable<AnonymousChatResponseDto> { // <-- FIX: Return type is nu AnonymousChatResponseDto
    let params = new HttpParams();
    if (anonymousSessionId) {
      params = params.set('anonymousSessionId', anonymousSessionId);
    }
    const url = `${this.apiUrl}/conversations/ai-bot/anonymous`;
    return this.http.post<AnonymousChatResponseDto>(url, payload, { params }); // <-- FIX: Http POST verwacht nu AnonymousChatResponseDto
  }


  override associateAnonymousChat(anonymousSessionId: string): Observable<void> {
    const url = `${this.apiUrl}/conversations/anonymous/associate`;
    const payload = { anonymousSessionId };
    // Verwacht een 204 No Content, dus responseType 'json' is niet nodig.
    return this.http.post<void>(url, payload);
  }

  override getAnonymousConversation(anonymousSessionId: string): Observable<AnonymousConversationDto | null> {
    const url = `${this.apiUrl}/conversations/anonymous/${anonymousSessionId}`;
    return this.http.get<AnonymousConversationDto>(url).pipe(
      catchError(err => {
        if (err.status === 404) {
          return of(null); // Return null for Not Found
        }
        return throwError(() => err); // Re-throw other errors
      })
    );
  }

}
--- END OF FILE ---

--- START OF FILE libs/features/chat/domain/src/index.ts ---
/**
 * @file index.ts (chat-domain)
 * @description Public API for the Chat Domain library.
 */
export * from './lib/models/chat.models';
--- END OF FILE ---

--- START OF FILE libs/features/chat/domain/src/lib/models/chat.models.ts ---
/**
 * @file chat.model.ts
 * @version 2.2.0 (Cleaned Comments & Synchronized)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-28
 * @description Defines the core domain models for the Chat feature, now
 *              synchronized with `StructuredError` and updated DTO expectations,
 *              with cleaned and concise comments.
 */
import { Media, Image } from '@royal-code/shared/domain';
import { Profile, ReactionSummary, ReactionType } from '@royal-code/features/social/domain';
import { AuditableEntityBase } from '@royal-code/shared/base-models';
import { StructuredError } from '@royal-code/shared/domain';

export enum ConversationType {
  DIRECTMESSAGE = 'direct-message',
  GROUPCHAT = 'group-chat',
  AIBOT = 'ai-bot',
}

export enum MessageStatus {
  SENDING = 'sending',
  SENT = 'sent',
  DELIVERED = 'delivered',
  READ = 'read',
  FAILED = 'failed',
}

export interface Message extends AuditableEntityBase {
  id: string;
  conversationId: string;
  senderId: string;
  senderType: 'user' | 'bot';
  senderProfile?: Profile;
  content: string;
  media?: readonly Media[];
  gifUrl?: string;
  status: MessageStatus; // Verwijder het vraagteken. Maak het verplicht.
  isRead?: boolean;
  isEdited?: boolean;
  error?: StructuredError | null;
  reactions?: readonly ReactionSummary[];
  userReaction?: ReactionType | null;
}


export interface Conversation extends AuditableEntityBase {
  id: string;
  type: ConversationType;
  name?: string;
  avatar?: Image;
  participantIds?: readonly string[];
  botId?: string;
  lastMessage?: Message | null;
  unreadCount?: number;
  isMuted?: boolean;
  isNew?: boolean; 
}
--- END OF FILE ---

--- START OF FILE libs/features/chat/ui-challenger/src/index.ts ---
export * from './lib/chat-ui-challenger/chat-ui-challenger.component';
--- END OF FILE ---

--- START OF FILE libs/features/chat/ui-challenger/src/lib/chat-ui-challenger/chat-ui-challenger.component.html ---
<p>ChatUiChallenger works!</p>
--- END OF FILE ---

--- START OF FILE libs/features/chat/ui-challenger/src/lib/chat-ui-challenger/chat-ui-challenger.component.scss ---

--- END OF FILE ---

--- START OF FILE libs/features/chat/ui-challenger/src/lib/chat-ui-challenger/chat-ui-challenger.component.ts ---
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'challenger-chat-ui-challenger',
  imports: [CommonModule],
  templateUrl: './chat-ui-challenger.component.html',
  styleUrl: './chat-ui-challenger.component.scss',
})
export class ChatUiChallengerComponent {}
--- END OF FILE ---

--- START OF FILE libs/features/chat/ui-plushie/src/index.ts ---
// -- chat --
export * from './lib/components/chat-input/chat-input.component';
export * from './lib/components/chat-overlay/chat-overlay.component';
export * from './lib/components/chat-message-item/chat-message-item.component';
export * from './lib/components/ai-chat/ai-chat.component';
export * from './lib/chat-plushie.routes';
--- END OF FILE ---

--- START OF FILE libs/features/chat/ui-plushie/src/lib/chat-plushie.routes.ts ---
/**
 * @file chat-plushie.routes.ts
 * @description Lazy-loaded routes for the plushie chat feature.
 */
import { Routes } from '@angular/router';

export const ChatPlushieRoutes: Routes = [
  {
    path: '',
    children: [
      {
        path: '', // For example, opens an overlay or a dedicated page
        loadComponent: () => import('./components/chat-overlay/chat-overlay.component').then(m => m.ChatOverlayComponent),
      },
    ],
  },
];
--- END OF FILE ---

--- START OF FILE libs/features/chat/ui-plushie/src/lib/components/ai-chat/ai-chat.component.ts ---
/**
 * @fileoverview Component for displaying an AI chat interface.
 * @version 8.1.0 (Definitive Angular v20+ Signal Refactor & SSR Safe - Complete Guards)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-01
 * @Description
 *   The definitive, architecturally correct implementation of the AI chat component.
 *   This version is fully refactored to Angular v20+ signal syntax and is now
 *   robustly SSR-safe by conditionally executing ALL browser-specific APIs (`window`,
 *   `requestAnimationFrame`, `MutationObserver`) only on the client. It ensures
 *   perfect synchronization with the backend's data by deriving `currentUserId`
 *   from authenticated user or anonymous guest ID.
 */
import {
  Component, ChangeDetectionStrategy, inject, OnInit, Signal, computed,
  ElementRef, ViewChild, AfterViewInit, effect, input, booleanAttribute,
  PLATFORM_ID, OnDestroy, // <<< OnDestroy toegevoegd voor opruimen
  AfterViewChecked
} from '@angular/core';
import { CommonModule, isPlatformBrowser } from '@angular/common';
import { TranslateModule } from '@ngx-translate/core';
import { take } from 'rxjs';

import { ChatInputComponent, ChatMessageSubmitData } from '../chat-input/chat-input.component';
import { ChatMessageItemComponent } from '../chat-message-item/chat-message-item.component';
import { AuthFacade } from '@royal-code/store/auth';
import { UiIconComponent } from '@royal-code/ui/icon';
import { ChatFacade } from '@royal-code/features/chat/core';
import { AppIcon } from '@royal-code/shared/domain';
import { Message, MessageStatus } from '@royal-code/features/chat/domain';

@Component({
  selector: 'royal-code-ai-chat',
  standalone: true,
  imports: [ CommonModule, TranslateModule, ChatInputComponent, ChatMessageItemComponent, UiIconComponent ],
  host: { '[class.auto-grow]': 'autoGrow()', },
  template: `
    <div class="ai-chat-interface flex flex-col h-full bg-card border border-border shadow-md overflow-hidden">
      <header class="flex-shrink-0 h-12 px-3 flex items-center border-b border-border bg-card-secondary ">
        <royal-code-ui-icon [icon]="AppIcon.Sparkles" sizeVariant="md" colorClass="text-primary mr-2"></royal-code-ui-icon>
        <h3 class="text-md font-semibold text-foreground truncate">{{ aiConversationName() | translate }}</h3>
      </header>

      <div class="message-area p-3 space-y-2 sm:space-y-3" #messageArea>
        @for (message of messages(); track message.id) {
          <lib-chat-message-item
            [message]="message"
            [currentUserId]="currentUserId()"
          />
        }
      </div>

      <footer class="flex-shrink-0 border-t border-border">
        <lib-chat-input (submitted)="handleSendMessage($event)" [isSending]="isActuallySendingMessage()" [placeholder]="inputPlaceholder()" />
      </footer>
    </div>
  `,
  styles: [`:host { display: flex; flex-direction: column; height: 500px; min-height: 300px; } :host(.auto-grow) { height: 100%; } .message-area { flex-grow: 1; overflow-y: auto; min-height: 0; }`],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class AiChatComponent implements OnInit, AfterViewInit, OnDestroy, AfterViewChecked  { // <<< OnDestroy toegevoegd
  readonly autoGrow = input(false, { transform: booleanAttribute });

  private readonly chatFacade = inject(ChatFacade);
  private readonly authFacade = inject(AuthFacade);
  private readonly platformId = inject(PLATFORM_ID);

  @ViewChild('messageArea') private messageAreaRef?: ElementRef<HTMLDivElement>;
  private messageListScrollableElement?: HTMLDivElement;
  private observer?: MutationObserver;
  private shouldScrollToBottom = false;

  readonly AppIcon = AppIcon;
  readonly messages = this.chatFacade.aiConversationMessages;
  readonly isLoadingMessages = this.chatFacade.isAiChatLoading;
  
  readonly currentUserId: Signal<string | null> = computed(() => {
    return this.authFacade.currentUser()?.id ?? this.chatFacade.anonymousGuestId() ?? 'anonymous-user';
  });

  readonly isActuallySendingMessage = computed(() => {
    const uId = this.currentUserId();
    return this.messages().some(m => m.status === MessageStatus.SENDING && m.senderId === uId);
  });

  readonly aiConversationName = computed(() => this.chatFacade.aiConversation()?.name || 'chat.aiCoachDefaultName');
  readonly inputPlaceholder = computed(() => 'chat.input.typeYourQuestion');

  constructor() {
    effect(() => {
      this.messages(); 
      this.shouldScrollToBottom = true; // <<< Vlag zetten, niet direct scrollen
    });
  }


  ngOnInit(): void {
    if (this.authFacade.isAuthenticated()) {
      this.chatFacade.ensureAiConversationIsActiveAndLoaded().pipe(take(1)).subscribe();
    }
  }

  ngAfterViewInit(): void {
    // DE FIX: Conditioneer browser-specifieke API's
    if (isPlatformBrowser(this.platformId)) {
      this.messageListScrollableElement = this.messageAreaRef?.nativeElement;
      this.scrollToBottom();

      if (this.messageListScrollableElement) {
        // Observer om automatisch naar beneden te scrollen bij nieuwe berichten
        this.observer = new MutationObserver(() => {
          this.scrollToBottom();
        });
        this.observer.observe(this.messageListScrollableElement, { childList: true, subtree: true });
      }
    } else {
      // Loggen dat de initiële scroll en observer worden overgeslagen tijdens SSR.
      console.debug('[AiChatComponent] Skipping scrollToBottom and MutationObserver setup on server (SSR).');
    }
  }

    ngAfterViewChecked(): void {
    // DE FIX: Scroll pas als de vlag is gezet EN in de browser-omgeving.
    if (this.shouldScrollToBottom && isPlatformBrowser(this.platformId)) {
      this.scrollToBottom();
      this.shouldScrollToBottom = false; // Reset de vlag
    }
  }


  ngOnDestroy(): void {
    // DE FIX: Conditioneer opruimen van MutationObserver
    if (isPlatformBrowser(this.platformId) && this.observer) {
      this.observer.disconnect();
    }
  }

  handleSendMessage(data: ChatMessageSubmitData): void {
    if (this.isActuallySendingMessage() || !data.text.trim()) return;

    const payloadForFacade = {
        content: data.text,
        media: data.files,
        gifUrl: data.gifUrl ?? undefined,
        aiPersonaId: '3f2e1a0b-c8d7-4e6f-9a1b-0c2d3e4f5a6b' // Hardcoded AI Persona ID.
    };
    this.chatFacade.sendMessageToAiBot(payloadForFacade);
  }

  private scrollToBottom(): void {
    // DE FIX: Conditioneer browser-specifieke API's
    if (isPlatformBrowser(this.platformId)) {
      if (this.messageAreaRef?.nativeElement) {
        requestAnimationFrame(() => {
          const element = this.messageAreaRef!.nativeElement;
          element.scrollTop = element.scrollHeight;
        });
      }
    }
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/chat/ui-plushie/src/lib/components/chat-input/chat-input.component.ts ---
// libs/features/social/src/lib/components/chat-input/chat-input.component.ts
/**
 * @fileoverview Reusable component for chat message input, featuring text, emoji, GIF,
 * and image attachments. Adapted from CommentInputComponent for chat context.
 * Includes responsive layout for action buttons.
 * @version 2.1.0 - Responsive button layout.
 */
import {
  Component, ChangeDetectionStrategy, OnInit, AfterViewInit, OnDestroy,
  inject, input, output, signal, computed, viewChild, Injector,
  ElementRef, OutputEmitterRef, InputSignal, booleanAttribute, DestroyRef, afterNextRender
} from '@angular/core';

import { FormsModule } from '@angular/forms';
import { TranslateModule } from '@ngx-translate/core';

import { UiIconComponent } from '@royal-code/ui/icon';
import { UiTextareaComponent } from '@royal-code/ui/textarea';
import { AppIcon } from '@royal-code/shared/domain';
import { APP_CONFIG, AppConfig } from '@royal-code/core/config';
import { DynamicOverlayService } from '@royal-code/ui/overlay';
import { LoggerService } from '@royal-code/core/logging';
import { EmojiPickerComponent, GifPickerComponent} from '@royal-code/features/social/ui';
import { EmojiSelectionService } from '@royal-code/features/social/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';

/**
 * @interface ImagePreview
 * @description Structure for local image preview data.
 */
interface ImagePreview {
  file: File;
  dataUrl: string;
  id: string;
}

/**
 * @interface ChatMessageSubmitData
 * @description Data structure emitted when a chat message is submitted.
 */
export interface ChatMessageSubmitData {
  text: string;
  gifUrl?: string | null;
  files?: File[];
}

@Component({
  selector: 'lib-chat-input',
  standalone: true,
  imports: [
    FormsModule,
    TranslateModule,
    UiIconComponent,
    UiTextareaComponent
],
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
<!-- Main wrapper: Altijd flex-col, knoppen onder textarea -->
<div class="chat-input-wrapper flex flex-col items-end">

  <!-- Textarea & Previews (neemt meeste ruimte, altijd volledige breedte) -->
  <div class="flex-grow flex flex-col relative min-w-0 w-full">
    <!-- Media Previews -->
    @if (attachedGifUrl() || selectedImagePreviews().length > 0) {
      <div class="mb-1.5 max-h-24 overflow-y-auto px-1 pt-1 border border-border bg-card-secondary rounded-t-md">
        @if (attachedGifUrl(); as gifUrl) {
          <div class="relative inline-block mr-1 mb-1 border border-border rounded align-bottom max-w-[45%]">
            <img [src]="gifUrl" alt="Selected GIF" class="max-h-20 object-contain rounded">
            <button (click)="removeAttachedGif()" type="button"
                    class="absolute -top-1.5 -right-1.5 bg-destructive text-destructive-foreground rounded-full p-0.5 w-4 h-4 flex items-center justify-center text-xs leading-none focus:outline-none focus:ring-1 focus:ring-ring"
                    aria-label="Remove GIF">✕</button>
          </div>
        }
        @if (selectedImagePreviews().length > 0) {
          <div class="flex flex-wrap ">
            @for (preview of selectedImagePreviews(); track preview.id) {
              <div class="relative border border-border rounded w-16 h-16">
                <img [src]="preview.dataUrl" [alt]="preview.file.name" class="w-full h-full object-cover rounded">
                <button (click)="removeImagePreview(preview.id)" type="button"
                        class="absolute -top-1 -right-1 bg-destructive text-destructive-foreground rounded-full p-0.5 w-4 h-4 flex items-center justify-center text-xs leading-none focus:outline-none focus:ring-1 focus:ring-ring"
                        [attr.aria-label]="'Remove image ' + preview.file.name">✕</button>
              </div>
            }
          </div>
        }
      </div>
    }

    <!-- Textarea -->
    <royal-code-ui-textarea
      #chatTextareaEl
      [(value)]="currentText"
      [placeholder]="placeholder() | translate"
      [maxLength]="500"
      [minHeightPx]="inputMinHeight()"
      [maxHeightPx]="120"
      [extraTextareaClasses]="'!py-2 !px-3 !text-sm !ring-inset !focus:ring-inset !bg-card-secondary ' + (attachedGifUrl() || selectedImagePreviews().length > 0 ? '!rounded-b-md !rounded-t-none' : '!rounded-md')"
      ariaLabel="Chat message input"
      (keydown.enter)="handleEnterKey($event)"
      (keydown.escape)="onCancel()"
      cdkFocusInitial>
    </royal-code-ui-textarea>
  </div>

  @if (!hideBottomBar()) {
    <div class="flex items-center justify-between w-full flex-shrink-0 mt-1.5">
        <!-- Linker Actieknoppen (Emoji, GIF, Foto) - consistent grotere knoppen -->
        <div class="flex items-center gap-1">
          <button
          royal-code-ui-button type="primary" sizeVariant="icon"
          (click)="onEmojiClick()" class="!w-9 !h-9 !p-2"
          [title]="'chat.input.addEmoji' | translate" #emojiButton>
          <royal-code-ui-icon [icon]="AppIcon.Smile" sizeVariant="md" colorClass="text-primary-foreground"></royal-code-ui-icon>
        </button>
        <button
          royal-code-ui-button type="primary" sizeVariant="icon"
          (click)="onGifClick()" class="!w-9 !h-9 !p-2"
          [title]="'chat.input.addGif' | translate" #gifButton>
          <royal-code-ui-icon [icon]="AppIcon.Gift" sizeVariant="md" colorClass="text-primary-foreground"></royal-code-ui-icon>
        </button>
        <button
          royal-code-ui-button type="primary" sizeVariant="icon"
          (click)="onPhotoClick()" class="!w-9 !h-9 !p-2"
          [title]="'chat.input.addPhoto' | translate" #photoButton>
          <royal-code-ui-icon [icon]="AppIcon.Camera" sizeVariant="md" colorClass="text-primary-foreground"></royal-code-ui-icon>
        </button>
      </div>

      <!-- Verzendknop (rechts) - consistent grotere knop -->
      <button
        royal-code-ui-button type="primary" sizeVariant="icon"
        (click)="onSubmit()" [disabled]="isSubmitDisabled() || isSending()"
        class="!w-10 !h-10"
        [title]="'chat.input.send' | translate">
        @if (!isSending()) {
        } @else {
          <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-primary-foreground"></div>
        }
      </button>
    </div>
  }
</div>

<!-- Hidden file input (blijft ongewijzigd) -->
<!-- Hidden file input (blijft ongewijzigd) -->
<input #fileInput type="file" accept="image/*" multiple class="hidden" (change)="onFileSelected($event)">
  `,
})
export class ChatInputComponent implements OnInit, AfterViewInit, OnDestroy {
  // --- Inputs ---
  /** Indicates if a message is currently being sent (e.g., waiting for API response). */
  readonly isSending: InputSignal<boolean> = input(false);
  /** Placeholder text for the textarea. */
    readonly placeholder: InputSignal<string> = input<string>('chat.input.placeholderDefault');
  /** Minimum height for the textarea in pixels. */
  readonly inputMinHeight: InputSignal<number> = input<number>(36); // Aangepast voor consistentie met button height

  /** Hides the bottom action bar (emoji, gif, photo, send buttons). */
  readonly hideBottomBar = input(false, { transform: booleanAttribute });

  // --- Outputs ---
  /** Emitted when the user submits the message data. */
  // --- Outputs ---
  /** Emitted when the user submits the message data. */
  readonly submitted: OutputEmitterRef<ChatMessageSubmitData> = output<ChatMessageSubmitData>();
  /** Emitted when the user cancels the input (e.g., by pressing Escape or if parent requests cancel). */
  readonly cancelled: OutputEmitterRef<void> = output<void>();

  // --- View Child References ---
  private readonly chatTextareaRef = viewChild<UiTextareaComponent>('chatTextareaEl');
  private readonly fileInputRef = viewChild.required<ElementRef<HTMLInputElement>>('fileInput');
  private readonly emojiButtonRef = viewChild.required<ElementRef<HTMLElement>>('emojiButton');
  private readonly gifButtonRef = viewChild.required<ElementRef<HTMLElement>>('gifButton');
  private readonly photoButtonRef = viewChild.required<ElementRef<HTMLElement>>('photoButton');

  // --- Dependencies ---
  private readonly logger = inject(LoggerService);
  private readonly overlayService = inject(DynamicOverlayService);
  private readonly emojiSelectionService = inject(EmojiSelectionService);
  private readonly appConfig = inject<AppConfig>(APP_CONFIG);
  private readonly injector = inject(Injector);
  private readonly destroyRef = inject(DestroyRef);
  private readonly logPrefix = '[ChatInputComponent]';

  // --- Internal State ---
  /** Signal holding the current text content of the textarea. */
  readonly currentText = signal<string>('');
  /** Signal holding the URL of an attached GIF, or null. */
  readonly attachedGifUrl = signal<string | null>(null);
  /** Signal holding an array of local image previews. */
  readonly selectedImagePreviews = signal<ImagePreview[]>([]);

  /** Exposes the AppIcon enum to the template. */
  readonly AppIcon = AppIcon;

  /**
   * @computed isSubmitDisabled
   * @description Determines if the submit button should be disabled.
   * @returns {boolean} True if submission should be disabled.
   */
  readonly isSubmitDisabled = computed(() =>
    (!this.currentText().trim() && !this.attachedGifUrl() && this.selectedImagePreviews().length === 0) || this.isSending()
  );

  constructor() {
    this.logger.debug(`${this.logPrefix} Instance created.`);
  }

  ngOnInit(): void {
    this.emojiSelectionService.emojiSelected$
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe(emoji => this.insertEmoji(emoji));
  }

  ngAfterViewInit(): void {
    this.focusTextarea();
  }

  ngOnDestroy(): void {
    this.logger.debug(`${this.logPrefix} Destroyed.`);
  }

  /**
   * Handles Enter key press: submits if Shift is not held.
   * @param {Event} event - The keyboard event.
   */
  handleEnterKey(event: Event): void {
    const keyboardEvent = event as KeyboardEvent;
    if (!keyboardEvent.shiftKey) {
      keyboardEvent.preventDefault();
      if (!this.isSubmitDisabled()) {
        this.onSubmit();
      }
    }
  }

  /**
   * Emits submitted data and resets the input state.
   */
  onSubmit(): void {
    if (this.isSubmitDisabled()) return;

    const text = this.currentText().trim();
    const gifUrl = this.attachedGifUrl();
    const files = this.selectedImagePreviews().map(p => p.file);

    this.logger.info(`${this.logPrefix} Submitting chat message.`, { textLength: text.length, gifUrl, fileCount: files.length });
    this.submitted.emit({ text, gifUrl, files });
    this.resetInputState();
  }

  /**
   * Handles cancellation: resets state or emits `cancelled` event.
   */
  onCancel(): void {
    if (this.currentText().length > 0 || this.attachedGifUrl() || this.selectedImagePreviews().length > 0) {
        this.resetInputState();
    } else {
        this.cancelled.emit();
    }
  }

  /** Resets input fields and re-focuses the textarea. */
  private resetInputState(): void {
    this.currentText.set('');
    this.attachedGifUrl.set(null);
    this.selectedImagePreviews.set([]);
    this.focusTextarea();
    this.logger.debug(`${this.logPrefix} Input state reset.`);
  }

  /** Programmatically focuses the textarea. */
  private focusTextarea(): void {
    afterNextRender(() => {
      this.chatTextareaRef()?.focus();
    }, { injector: this.injector });
  }

  /** Opens image file picker. */
  onPhotoClick(): void {
    this.logger.debug(`${this.logPrefix} Photo button clicked.`);
    this.fileInputRef().nativeElement.value = ''; // Reset om zelfde bestand opnieuw te kunnen kiezen
    this.fileInputRef().nativeElement.click();
  }

  /** Opens GIF picker overlay. */
  onGifClick(): void {
    const triggerElement = this.gifButtonRef()?.nativeElement;
    if (!triggerElement) { this.logger.error(`${this.logPrefix} GIF button element not found!`); return; }

    this.logger.debug(`${this.logPrefix} Opening GIF picker.`);
    const overlayRef = this.overlayService.open<string>({
      component: GifPickerComponent,
      origin: triggerElement,
      positionStrategy: 'connected',
      connectedPosition: [{ originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom', offsetY: -8 }],
      backdropType: 'transparent',
      closeOnClickOutside: true,
      panelClass: ['gif-picker-overlay', '!max-w-[320px]'],
      mobileFullscreen: true,
    });

    overlayRef.afterClosed$.subscribe(gifUrl => {
      if (gifUrl) {
        this.logger.info(`${this.logPrefix} GIF selected: ${gifUrl}`);
        this.attachedGifUrl.set(gifUrl);
        this.selectedImagePreviews.set([]); // Clear images if GIF is chosen
      }
    });
  }

  /** Opens Emoji picker overlay. */
  onEmojiClick(): void {
    const triggerElement = this.emojiButtonRef()?.nativeElement;
    if (!triggerElement) { this.logger.error(`${this.logPrefix} Emoji button element not found!`); return; }

    this.logger.debug(`${this.logPrefix} Opening emoji picker.`);
    this.overlayService.open<void>({
      component: EmojiPickerComponent,
      origin: triggerElement,
      positionStrategy: 'connected',
      connectedPosition: [{ originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom', offsetY: -8 }],
      backdropType: 'transparent',
      closeOnClickOutside: true,
      mobileFullscreen: true,
      panelClass: ['emoji-picker-overlay'],
    });
  }

  /** Inserts selected emoji into textarea. */
  private insertEmoji(emoji: string): void {
    this.currentText.update(val => (val ?? '') + emoji);
    this.focusTextarea();
  }

  /** Removes attached GIF. */
  removeAttachedGif(): void {
    this.attachedGifUrl.set(null);
  }

  /** Removes an image preview by its ID. */
  removeImagePreview(previewId: string): void {
    this.selectedImagePreviews.update(previews => previews.filter(p => p.id !== previewId));
  }

  /** Handles file selection, validation, and preview generation. */
  onFileSelected(event: Event): void {
    const target = event.target as HTMLInputElement;
    const files = target.files;
    if (!files || files.length === 0) return;

    this.logger.info(`${this.logPrefix} Files selected: ${files.length}`);
    this.attachedGifUrl.set(null); // Clear GIF

    const currentPreviews = this.selectedImagePreviews();
    const maxFiles = this.appConfig.mediaUpload.maxFiles;
    const allowedTypes = this.appConfig.mediaUpload.allowedImageTypes;
    const maxSizeMB = this.appConfig.mediaUpload.maxSizeMb;
    const maxSizeInBytes = maxSizeMB * 1024 * 1024;

    const limit = Math.min(files.length, maxFiles - currentPreviews.length);
    if (limit <= 0 && files.length > 0) {
      this.logger.warn(`${this.logPrefix} Maximum image limit (${maxFiles}) reached.`);
      target.value = ''; return;
    }

    const newPreviews: ImagePreview[] = [];
    let processedCount = 0;

    for (let i = 0; i < limit; i++) {
      const file = files[i];
      if (!allowedTypes.includes(file.type) || file.size > maxSizeInBytes) {
        this.logger.warn(`${this.logPrefix} Skipping invalid file: ${file.name}`);
        processedCount++; if (processedCount === limit) { this.updatePreviewsIfNeeded(newPreviews); }
        continue;
      }

      const reader = new FileReader();
      const previewId = `${file.name}-${file.lastModified}-${Math.random().toString(16).slice(2)}`;
      reader.onload = (e: ProgressEvent<FileReader>) => {
        processedCount++;
        if (e.target?.result) {
          newPreviews.push({ file, dataUrl: e.target.result as string, id: previewId });
        }
        if (processedCount === limit) { this.updatePreviewsIfNeeded(newPreviews); }
      };
      reader.onerror = () => {
        processedCount++;
        this.logger.error(`${this.logPrefix} FileReader error for ${file.name}.`);
        if (processedCount === limit) { this.updatePreviewsIfNeeded(newPreviews); }
      };
      reader.readAsDataURL(file);
    }
    target.value = '';
  }

  /** Updates image previews signal. */
  private updatePreviewsIfNeeded(newPreviews: ImagePreview[]): void {
    if (newPreviews.length > 0) {
      this.selectedImagePreviews.update(existing => [...existing, ...newPreviews]);
    }
  }

  /** TrackBy function for image previews. */
  trackImagePreview(index: number, item: ImagePreview): string {
    return item.id;
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/chat/ui-plushie/src/lib/components/chat-message-item/chat-message-item.component.ts ---
/**
 * @fileoverview Displays a single chat message with appropriate styling.
 * @version 4.1.0 (Definitive & Robust)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-30
 * @Description
 *   The definitive, clean implementation. This component is fully agnostic of
 *   session types and relies on a simple, robust comparison between the message's `senderId`
 *   and the `currentUserId` input to determine message alignment and styling.
 */
import { Component, ChangeDetectionStrategy, InputSignal, computed, input, Signal } from '@angular/core';
import { CommonModule, DatePipe } from '@angular/common';
import { RouterLink } from '@angular/router';
import { TranslateModule } from '@ngx-translate/core';
import { AppIcon } from '@royal-code/shared/domain';
import { DateTimeInfo } from '@royal-code/shared/base-models';
import { UiIconComponent } from '@royal-code/ui/icon';
import { UiProfileImageComponent } from '@royal-code/ui/media';
import { Message, MessageStatus } from '@royal-code/features/chat/domain';

@Component({
  selector: 'lib-chat-message-item',
  standalone: true,
  imports: [ CommonModule, DatePipe, UiIconComponent, UiProfileImageComponent, RouterLink, TranslateModule ],
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    @if (message(); as msg) {
      <div class="chat-message-item flex mb-2" [ngClass]="{ 'justify-end': isCurrentUserSender(), 'justify-start': !isCurrentUserSender() }">
        
        <!-- Avatar for incoming messages -->
        @if (!isCurrentUserSender()) {
          <div class="flex-shrink-0 mr-2 self-end" aria-hidden="true">
             <royal-code-ui-profile-image [source]="msg.senderProfile?.avatar" [displayName]="msg.senderProfile?.displayName || 'AI'" size="sm" />
          </div>
        }

        <!-- Message Bubble -->
         <div class="message-bubble max-w-[75%] p-3 sm:p-4 rounded-xl shadow-sm" 
              [ngClass]="{ 
                'bg-primary text-primary-on rounded-br-none': isCurrentUserSender(), 
                'bg-surface-alt border border-border text-foreground rounded-bl-none': !isCurrentUserSender() 
              }">
          
          <!-- Content -->
          @if (msg.content && msg.content.trim() !== '') {
            <p class="text-sm whitespace-pre-wrap break-words leading-relaxed" [ngClass]="{ 'text-primary-on': isCurrentUserSender(), 'text-foreground': !isCurrentUserSender() }">
              {{ msg.content }}
            </p>
          }

          <!-- Timestamp & Status -->
          <div class="flex items-center mt-1.5 text-xs" [ngClass]="{ 'text-primary-on/70 justify-end': isCurrentUserSender(), 'text-secondary justify-start': !isCurrentUserSender() }">
            <span>{{ (isDateTimeInfo(msg.createdAt) ? msg.createdAt?.iso : msg.createdAt) | date:'shortTime' }}</span>
            @if (isCurrentUserSender() && msg.status && msg.status !== 'sent') {
              <royal-code-ui-icon [icon]="getStatusIcon(msg.status)" sizeVariant="xs" extraClass="ml-1.5" [title]="msg.status === 'failed' && msg.error ? msg.error.message : ''"></royal-code-ui-icon>
            }
          </div>
        </div>

      </div>
    }
  `
})
export class ChatMessageItemComponent {
  readonly message: InputSignal<Message> = input.required<Message>();
  readonly currentUserId: InputSignal<string | null | undefined> = input<string | null>();

  readonly isCurrentUserSender: Signal<boolean> = computed(() => {
    const msg = this.message();
    const cUserId = this.currentUserId();
    return !!msg?.senderId && !!cUserId && msg.senderId === cUserId;
  });

  isDateTimeInfo(value: any): value is DateTimeInfo {
    return typeof value === 'object' && value !== null && 'iso' in value;
  }

  getStatusIcon(status: Message['status']): AppIcon {
    switch (status) {
      case MessageStatus.SENDING: return AppIcon.Clock;
      case MessageStatus.SENT: return AppIcon.Check;
      case MessageStatus.FAILED: return AppIcon.AlertCircle;
      default: return AppIcon.CircleDot;
    }
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/chat/ui-plushie/src/lib/components/chat-overlay/chat-overlay.component.ts ---
/**
 * @file chat-overlay.component.ts
 * @Version 2.0.0 (Facade-Aligned & Corrected)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-30
 * @Description
 *   The definitive implementation of the chat overlay. This version is fully
 *   aligned with the corrected and completed ChatFacade public API, ensuring
 *   all method calls and payloads are now correct and type-safe.
 */
import {
  ChangeDetectionStrategy, Component, inject, signal, computed, OnInit, DestroyRef, effect, Signal,
  ViewChild, ElementRef, AfterViewInit
} from '@angular/core';
import { CommonModule } from '@angular/common';

import { TranslateModule } from '@ngx-translate/core';

import { DYNAMIC_OVERLAY_REF, DynamicOverlayRef } from '@royal-code/ui/overlay';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiIconComponent } from '@royal-code/ui/icon';
import { ChatInputComponent, ChatMessageSubmitData } from '../chat-input/chat-input.component';
import { ChatMessageItemComponent } from '../chat-message-item/chat-message-item.component';
import { LoggerService } from '@royal-code/core/logging';
import { AuthFacade } from '@royal-code/store/auth';
import { filter, take } from 'rxjs';
import { NotificationService } from '@royal-code/ui/notifications';
import { ConversationType, Conversation, Message } from '@royal-code/features/chat/domain';
import { AppIcon } from '@royal-code/shared/domain';
import { ChatFacade, SendMessagePayload } from '@royal-code/features/chat/core';
import { MessageStatus } from '@royal-code/features/chat/domain';

@Component({
  selector: 'lib-chat-overlay',
  standalone: true,
  imports: [ CommonModule, TranslateModule, UiButtonComponent, UiIconComponent, ChatInputComponent, ChatMessageItemComponent ],
  template: `
    <div class="chat-overlay-container fixed inset-0 bg-background text-foreground flex flex-col z-50" role="dialog" aria-modal="true">
      <!-- Header -->
      <header class="flex-shrink-0 h-14 sm:h-16 px-3 sm:px-4 flex items-center justify-between border-b border-border bg-background/80 backdrop-blur-sm">
        <div class="flex items-center min-w-0">
          <royal-code-ui-icon [icon]="headerIcon()" sizeVariant="lg" [colorClass]="'text-primary'" extraClass="mr-2 flex-shrink-0"></royal-code-ui-icon>
          <h2 class="text-lg sm:text-xl font-semibold truncate">
            {{ currentConversation()?.name || ('chat.overlay.title' | translate) }}
          </h2>
        </div>
        <royal-code-ui-button type="transparent" sizeVariant="icon" (clicked)="closeOverlay()" [title]="'common.buttons.close' | translate" aria-label="Close chat overlay">
          <royal-code-ui-icon [icon]="AppIcon.X" sizeVariant="md"></royal-code-ui-icon>
        </royal-code-ui-button>
      </header>

      <!-- Main Content -->
      <div class="flex-grow flex overflow-hidden">
        <!-- Conversations List (Desktop) -->
        <aside class="hidden sm:flex sm:w-1/3 md:w-1/4 h-full border-r border-border bg-card-secondary flex-col overflow-y-auto">
          <!-- List content... -->
        </aside>

        <!-- Message Area -->
        <main class="flex-grow h-full flex flex-col bg-card">
          @if (currentConversation(); as conv) {
            <div class="flex-grow p-3 sm:p-4 space-y-2 sm:space-y-3 overflow-y-auto" #messageArea>
              @for (message of currentMessages(); track message.id) {
                <lib-chat-message-item [message]="message" [currentUserId]="currentUserIdSignal()" />
              }
            </div>
            <div class="flex-shrink-0 border-t border-border">
              <lib-chat-input (submitted)="sendMessage($event)" [isSending]="isActuallySendingMessage()" [placeholder]="inputPlaceholder()" />
            </div>
          } @else {
            <div class="flex-grow flex flex-col items-center justify-center p-6 text-center">
              <p class="text-lg font-medium text-muted-foreground">{{ 'chat.messages.selectConversationPrompt' | translate }}</p>
            </div>
          }
        </main>
      </div>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class ChatOverlayComponent implements OnInit, AfterViewInit {
  @ViewChild('messageArea') private messageAreaRef?: ElementRef<HTMLDivElement>;

  private readonly overlayRef = inject(DYNAMIC_OVERLAY_REF);
  private readonly chatFacade = inject(ChatFacade);
  private readonly authFacade = inject(AuthFacade);
  private readonly logger = inject(LoggerService);
  private readonly notificationService = inject(NotificationService);

  readonly AppIcon = AppIcon;
  readonly ConversationType = ConversationType;

  readonly conversationsLoading: Signal<boolean> = this.chatFacade.conversationsLoading;
  readonly allConversations: Signal<readonly Conversation[]> = this.chatFacade.allConversations;
  readonly selectedConversationId: Signal<string | null> = this.chatFacade.selectedConversationId;
  readonly currentConversation: Signal<Conversation | undefined> = this.chatFacade.selectedConversation;
  readonly currentUserIdSignal: Signal<string | null> = computed(() => this.authFacade.currentUser()?.id ?? null);
  readonly currentMessages: Signal<readonly Message[]> = this.chatFacade.currentSelectedConversationMessages;
  readonly messagesLoading: Signal<boolean> = this.chatFacade.selectedConversationMessagesLoading;

  readonly isActuallySendingMessage = computed(() =>
    this.currentMessages().some(m => m.status === MessageStatus.SENDING && m.senderId === this.currentUserIdSignal())
  );

  readonly directMessageConversations = computed(() =>
    this.allConversations().filter(c => c.type === ConversationType.DIRECTMESSAGE || c.type === ConversationType.AIBOT)
  );

  readonly headerIcon = computed((): AppIcon => {
    const conv = this.currentConversation();
    if (!conv) return AppIcon.MessageCircle;
    return conv.type === ConversationType.AIBOT ? AppIcon.Sparkles : AppIcon.User;
  });

  readonly inputPlaceholder = computed(() =>
    this.messagesLoading() && this.currentMessages().length === 0 ? 'chat.messages.loading' : 'chat.input.typeYourMessage'
  );

  constructor() {
    effect(() => {
        const conversations = this.allConversations();
        if (!this.conversationsLoading() && !this.selectedConversationId() && conversations.length > 0) {
            this.selectConversation(conversations[0].id);
        }
    });
  }

  ngOnInit(): void {
    this.chatFacade.loadConversations();
  }

  ngAfterViewInit(): void {
    effect(() => {
      this.currentMessages();
      this.scrollToBottom();
    });
  }

  closeOverlay(): void {
    this.overlayRef.close();
  }

  selectConversation(conversationId: string | null): void {
    if (!conversationId) return;
    this.chatFacade.selectConversation(conversationId);
    this.chatFacade.loadMessagesIfNotLoaded(conversationId);
  }

sendMessage(data: ChatMessageSubmitData): void {
    const currentConv = this.currentConversation();
    const currentUserId = this.currentUserIdSignal();

    if (!currentConv) {
      this.logger.error('[ChatOverlay] Cannot send message, no conversation selected.');
      return;
    }
    if (!data.text.trim() && !data.gifUrl && (!data.files || data.files.length === 0)) {
        return;
    }

    if (currentConv.type === ConversationType.AIBOT) {
      this.chatFacade.sendMessageToAiBot({
        content: data.text,
        media: data.files,
        gifUrl: data.gifUrl ?? undefined,
        aiPersonaId: '3f2e1a0b-c8d7-4e6f-9a1b-0c2d3e4f5a6b' 
      });
    } else if (currentUserId) {
      const payload: Omit<SendMessagePayload, 'tempId'> = {
          conversationId: currentConv.id,
          senderId: currentUserId,
          content: data.text,
          media: data.files,
          gifUrl: data.gifUrl ?? undefined,
      };
      this.chatFacade.sendMessage(payload);
    }
  }

  private scrollToBottom(): void {
    if (this.messageAreaRef?.nativeElement) {
      requestAnimationFrame(() => {
        const element = this.messageAreaRef!.nativeElement;
        element.scrollTop = element.scrollHeight;
      });
    }
  }

  // Stubs for other handlers to prevent compile errors
  handleEditMessage(message: Message): void {
    const convId = this.selectedConversationId();
    if (!convId) return;
    const newContent = prompt("Enter new message content:", message.content);
    if (newContent) this.chatFacade.editMessage(convId, message.id, newContent);
  }

  handleDeleteMessage(message: Message): void {
    const convId = this.selectedConversationId();
    if (convId && confirm("Delete message?")) {
      this.chatFacade.deleteMessage(convId, message.id);
    }
  }

  handleReportMessage(message: Message): void {
    const convId = this.selectedConversationId();
    if (convId) {
      const reason = prompt("Reason for reporting:");
      if (reason) this.chatFacade.reportMessage(convId, message.id, reason);
    }
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/index.ts ---
/**
 * @file index.ts (products-core)
 * @version 12.1.0 (Definitive & Corrected Public API)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-27
 * @description
 *   The definitive public API for the Products Core library. This barrel file
 *   exports all necessary elements for feature interaction, now including the
 *   full, correct set of selectors.
 */

// === STATE MANAGEMENT API ===
export * from './lib/state/product.facade';
export * from './lib/state/product.actions';
export * from './lib/state/product.providers';
export * from './lib/state/product.types'

// === SELECTORS API (for cross-feature state access and UI) ===
export {
  selectAllProducts,
  selectProductEntities,
  selectSelectedProduct,
  selectFeaturedProducts,
  selectProductById,
  selectProductListViewModel,
  selectIsLoading,
  selectIsSubmitting,
  selectError,
  selectHasProducts,
  selectIsBusy,
  selectIsStale,
} from './lib/state/product.feature';

// === DATA ACCESS & DOMAIN API ===
export * from './lib/data-access/abstract-product-api.service';
export * from './lib/mappers/product-mapping.service';
export * from './lib/DTO/backend.types';

// === UTILITIES API ===
export * from './lib/utils/product-type-guards';
export * from './lib/mappers/enum.mappers'; 

// === INITIALIZER API ==
export * from './lib/initializers/product-state.initializer';
export * from './lib/utils/product-stock.utils';

// === BACKEND TYPES ===
export * from './lib/DTO/backend.types';


// === SERVICES ===
export * from './lib/services/category-tree.service';
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/lib/data-access/abstract-product-api.service.ts ---
/**
 * @file abstract-product-api.service.ts
 * @Version 4.3.0 (Cleaned - No Variant Image Endpoint)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-30
 * @description Defines the abstract service contract for the product data-access layer.
 *              This version is cleaned of the unnecessary `getVariantImages` method.
 */
import { Observable } from 'rxjs';
import { AvailableFiltersResponse, ProductFilters, CreateProductPayload, UpdateProductPayload, Product, PhysicalProduct, ProductCategory, SearchSuggestionResponse } from '@royal-code/features/products/domain';
import { BackendPaginatedListDto, BackendProductListItemDto, BackendProductDetailDto, BackendMediaDto } from '../DTO/backend.types';
import { CustomAttributeDefinitionDto, PredefinedAttributesMap } from '@royal-code/features/admin-products/core';
import { ProductLookups, ProductTagLookup } from '@royal-code/features/admin-products/domain';

/**
 * @abstract
 * @class AbstractProductApiService
 * @description A pure data-access contract that returns raw backend DTOs. Mapping to
 *              domain models is the responsibility of the `ProductMappingService`.
 */
export abstract class AbstractProductApiService {
  abstract getPredefinedAttributes(): Observable<PredefinedAttributesMap>;
  abstract getCustomAttributeDefinitions(): Observable<CustomAttributeDefinitionDto[]>;
  abstract getProducts(filters?: ProductFilters | null): Observable<BackendPaginatedListDto<BackendProductListItemDto>>;
  abstract getAvailableFilters(currentFilters?: ProductFilters | null): Observable<AvailableFiltersResponse>;
  abstract getFeaturedProducts(): Observable<BackendPaginatedListDto<BackendProductListItemDto>>;
  abstract getProductById(productId: string): Observable<BackendProductDetailDto>;
  abstract getCategories(): Observable<ProductCategory[]>;
  abstract getProductsByIds(productIds: readonly string[]): Observable<BackendProductListItemDto[]>;
  abstract getRecommendations(count?: number): Observable<BackendPaginatedListDto<BackendProductListItemDto>>;
  abstract updatePhysicalStock(productId: string, variantInstanceId: string | undefined, changeInQuantity: number, reason: string, userId: string): Observable<BackendProductDetailDto>;
  abstract createProduct(payload: CreateProductPayload): Observable<BackendProductDetailDto>;
  abstract updateProduct(id: string, payload: UpdateProductPayload): Observable<BackendProductDetailDto>;
  abstract deleteProduct(id: string): Observable<void>;
  abstract bulkDeleteProducts(ids: string[]): Observable<void>;
  abstract getLookups(): Observable<ProductLookups>;
  abstract getTags(searchTerm?: string): Observable<ProductTagLookup[]>;
  abstract searchProducts(query: string, filters?: ProductFilters | null): Observable<BackendPaginatedListDto<BackendProductListItemDto>>;
  abstract getSuggestions(query: string): Observable<SearchSuggestionResponse>;

}
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/lib/DTO/backend.types.ts ---
// libs/features/products/core/src/lib/DTO/backend.types.ts
export interface BackendPaginatedListDto<T> {
  readonly items: readonly T[];
  readonly pageNumber: number;
  readonly pageSize: number;
  readonly totalPages: number;
  readonly totalCount: number;
  readonly hasPreviousPage: boolean;
  readonly hasNextPage: boolean;
}

export interface BackendProductCategoryDto {
  readonly id: string;
  readonly name: string;
  readonly slug: string;
}

export interface BackendMediaTeaserDto {
  readonly id: string;
  readonly url: string;
  readonly thumbnailUrl?: string;
  readonly altText?: string;
}

export interface BackendSelectedVariantDto {
  readonly id: string;
  readonly sku: string;
  readonly price: number;
  readonly originalPrice?: number;
  readonly stockQuantity?: number;
  readonly stockStatus?: string;
  readonly isDefault: boolean;
  readonly media: readonly BackendMediaTeaserDto[];
}

export interface BackendColorVariantTeaserDto {
  readonly attributeValueId: string;
  readonly value: string;
  readonly displayName: string;
  readonly colorHex?: string;
  readonly price: number;
  readonly originalPrice?: number;
  readonly defaultVariantId: string;
  readonly isDefault: boolean;
  readonly media: readonly BackendMediaTeaserDto[];
}

export interface BackendProductListItemDto {
  readonly id: string;
  readonly name: string;
  readonly shortDescription?: string;
  readonly tags?: readonly string[];
  readonly categories?: readonly BackendProductCategoryDto[];
  readonly type: string;
  readonly status: string;
  readonly isActive: boolean;
  readonly isFeatured: boolean;
  readonly averageRating?: number;
  readonly reviewCount: number;
  readonly hasDiscount: boolean;
  readonly discountPercentage?: number;
  readonly price: number;
  readonly originalPrice?: number;
  readonly currency: string;
  readonly stockStatus: string;
  readonly inStock: boolean;
  readonly featuredImages: readonly BackendMediaTeaserDto[];
  readonly selectedVariant: BackendSelectedVariantDto;
  readonly colorVariants: readonly BackendColorVariantTeaserDto[];
}

// === DETAIL INTERFACES (for product detail endpoint) ===
export interface BackendFeaturedImageDto {
  readonly id: string;
  readonly url: string;
  readonly altTextKeyOrText?: string;
}

export interface BackendMediaDto {
  readonly id: string;
  readonly type?: number;
  readonly url?: string;
  readonly thumbnailUrl?: string;
  readonly altTextKeyOrText?: string;
  readonly tags?: readonly string[];
}

export interface BackendVariantAttributeValueDto {
  readonly id: string;
  readonly value: string;
  readonly displayNameKeyOrText: string;
  readonly colorHex?: string;
  readonly priceModifier?: number;
  readonly isAvailable: boolean;
  readonly media?: BackendMediaDto;
}

export interface BackendVariantAttributeDto {
  readonly id: string;
  readonly nameKeyOrText: string;
  readonly type: number;
  readonly isRequired: boolean;
  readonly displayType: string;
  readonly values: readonly BackendVariantAttributeValueDto[];
}

export interface BackendVariantCombinationAttributeDto {
  readonly attributeId: string;
  readonly attributeValueId: string;
  readonly attributeNameKeyOrText?: string;
  readonly attributeValueNameKeyOrText?: string;
  readonly colorHex?: string;
}

export interface BackendProductVariantCombinationDto {
  readonly id: string;
  readonly sku: string;
  readonly attributes?: readonly BackendVariantCombinationAttributeDto[];
  readonly price?: number;
  readonly originalPrice?: number;
  readonly stockQuantity?: number;
  readonly stockStatus?: number;
  readonly isDefault?: boolean;
  readonly media?: readonly BackendMediaDto[];
}

export interface BackendPriceRangeDto {
  readonly minPrice?: number;
  readonly maxPrice?: number;
  readonly minOriginalPrice?: number;
  readonly maxOriginalPrice?: number;
}

export interface BackendProductAvailabilityRulesDto {
  readonly manageStock?: boolean;
  readonly allowBackorders?: boolean;
  readonly lowStockThreshold?: number;
  readonly minOrderQuantity?: number;
  readonly maxOrderQuantity?: number;
  readonly quantityIncrements?: number;
}

export interface BackendProductDisplaySpecificationDto {
  readonly specKey: string;
  readonly labelKeyOrText: string;
  readonly valueKeyOrText: string;
  readonly icon?: string;
  readonly groupKeyOrText?: string;
  readonly displayOrder?: number;
}

// libs/features/products/core/src/lib/DTO/backend.types.ts

export interface BackendSelectedVariantDetailDto {
  readonly id: string;
  readonly sku: string;
  readonly price?: number;
  readonly originalPrice?: number;
  readonly stockQuantity?: number;
  readonly stockStatus?: string;
  readonly hasDiscount: boolean;
  readonly isDefault: boolean;
  readonly media: readonly BackendMediaTeaserDto[];
}

export interface BackendPhysicalProductConfigDto {
  pricing?: {
    price: number;
    originalPrice?: number;
  };
  sku?: string;
  brand?: string;
  manageStock?: boolean;
  stockQuantity?: number;
  allowBackorders?: boolean;
  lowStockThreshold?: number | null;
  availabilityRules?: any; // You can define this more specifically if needed
  ageRestrictions?: any; // You can define this more specifically if needed
  displaySpecifications?: BackendProductDisplaySpecificationDto[];
}


export interface BackendSeoDto {
  readonly title?: string;
  readonly description?: string;
  readonly keywords?: readonly string[];
  readonly imageUrl?: string;
}

export interface BackendProductDetailDto {
  id: string;
  name: string;
  description?: string;
  shortDescription?: string;
  type: number;
  status: number;
  currency?: string;
  appScope?: string;
  isActive: boolean;
  isFeatured: boolean;
  averageRating?: number;
  reviewCount?: number;
  brand?: string;
  sku?: string;
  mediaIds?: string[];
  
  // NEW: Physical product configuration
  physicalProductConfig?: BackendPhysicalProductConfigDto;
  
  tags?: string[];
  categories?: Array<{
    id: string;
    name: string;
    slug: string;
  }>;
  featuredImageId?: string;
  priceRange?: {
    minPrice: number;
    maxPrice: number;
    minOriginalPrice?: number;
    maxOriginalPrice?: number;
  };
  
  // NEW: Featured image object
  featuredImage?: {
    id: string;
    url: string;
    altTextKeyOrText?: string;
  };
  
  // NEW: Root level variant data
  variantAttributes?: BackendVariantAttributeDto[];
  variantCombinations?: BackendProductVariantCombinationDto[];
  
  // NEW: Root level availability rules
  availabilityRules?: {
    manageStock?: boolean;
    allowBackorders?: boolean;
    lowStockThreshold?: number;
    minOrderQuantity?: number;
    maxOrderQuantity?: number;
    quantityIncrements?: number;
  };
  
  selectedVariant?: {
    id: string;
    sku: string;
    price: number;
    originalPrice?: number;
    stockQuantity?: number;
    stockStatus: number;
    hasDiscount?: boolean;
    media?: BackendMediaDto[];
  };
  
  stockQuantity?: number;
  stockStatus?: number;
  
  // NEW: Root level display specifications
  displaySpecifications?: BackendProductDisplaySpecificationDto[];
  
  customAttributes?: Record<string, any>;
  seo?: {
    title?: string;
    description?: string;
    keywords?: string[];
    imageUrl?: string;
  };
  hasDiscount?: boolean;
  inStock: boolean;
}
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/lib/initializers/product-state.initializer.ts ---
/**
 * @file product-state.initializer.ts
 * @Version 8.0.0 (Non-Blocking APP_INITIALIZER for Hydration)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-01
 * @Description
 *   A definitive, NON-BLOCKING, and universal APP_INITIALIZER for product data.
 *   This version ensures that the initializer ALWAYS RESOLVES IMMEDIATELY, preventing
 *   it from blocking Angular hydration. It still dispatches actions to pre-load
 *   product data for cart items, but components must handle the loading state themselves.
 *   This resolves `NG0506` hydration timeouts caused by blocking initializers.
 */
import { inject } from '@angular/core';
import { Store } from '@ngrx/store';
import { take, map, catchError, of, filter, withLatestFrom } from 'rxjs';
import { selectAllCartItems } from '@royal-code/features/cart/core';
import { LoggerService } from '@royal-code/core/logging';
import { Product } from '@royal-code/features/products/domain';
import { isPhysicalProduct } from '../utils/product-type-guards';
import { ProductActions } from '../state/product.actions';
import { selectProductEntities } from '../state/product.feature';

export function initializeProductState(): () => Promise<boolean> {
  const store = inject(Store);
  const logger = inject(LoggerService);
  const M = '[ProductInitializer]';

  return () => new Promise(resolve => {
    store.select(selectAllCartItems).pipe(
      take(1),
      withLatestFrom(store.select(selectProductEntities)),
      map(([items, productEntities]) => {
        const productIdsInCart = [...new Set(items.map(item => item.productId).filter(Boolean))];
        const missingDetailProductIds = productIdsInCart.filter(id => {
          const productInStore = productEntities[id];
          return !productInStore || !isProductDetailComplete(productInStore);
        });

        return missingDetailProductIds;
      }),
      catchError(err => {
        logger.error(`${M} Error during initial product data check. Preload skipped.`, err);
        return of([]); // Geef een lege array terug om de flow niet te breken.
      })
    ).subscribe(idsToLoad => {
      if (idsToLoad.length > 0) {
        logger.info(`${M} Cart contains items with missing product data. Dispatching 'loadProductsByIds' for ${idsToLoad.length} products.`);
        store.dispatch(ProductActions.loadProductsByIds({ ids: idsToLoad }));
      } else {
        logger.info(`${M} All product data for cart items is already present in the state. No preload needed.`);
      }
      // DE FIX: Resolve ALTIJD direct. Components moeten de laadtoestand zelf afhandelen.
      resolve(true); 
    });
  });
}

// Hulpfunctie om te controleren of een product als 'detail compleet' kan worden beschouwd.
function isProductDetailComplete(p: Product | undefined): p is Product {
  if (!p) return false;
  if (isPhysicalProduct(p)) {
    return Array.isArray(p.displaySpecifications);
  }
  return !!p.description;
}
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/lib/mappers/enum.mappers.ts ---
// libs/features/products/core/src/lib/mappers/enum.mappers.ts
import { ProductType, ProductStatus, StockStatus } from '@royal-code/features/products/domain';

// === UPDATED: ADD NUMERIC MAPPING ALONGSIDE STRING MAPPING ===
export const BACKEND_PRODUCT_TYPE_MAP: Record<string, ProductType> = {
  'physical': ProductType.PHYSICAL,
  'digitalProduct': ProductType.DIGITAL_PRODUCT,
  'virtualGameItem': ProductType.VIRTUAL_GAME_ITEM,
  'service': ProductType.SERVICE
} as const;

export const BACKEND_PRODUCT_TYPE_NUMERIC_MAP: Record<number, ProductType> = {
  0: ProductType.PHYSICAL,
  1: ProductType.DIGITAL_PRODUCT,
  2: ProductType.VIRTUAL_GAME_ITEM,
  3: ProductType.SERVICE
} as const;

export const BACKEND_PRODUCT_STATUS_MAP: Record<string, ProductStatus> = {
  'draft': ProductStatus.DRAFT,
  'published': ProductStatus.PUBLISHED,
  'archived': ProductStatus.ARCHIVED,
  'scheduled': ProductStatus.SCHEDULED
} as const;

export const BACKEND_PRODUCT_STATUS_NUMERIC_MAP: Record<number, ProductStatus> = {
  0: ProductStatus.DRAFT,
  1: ProductStatus.PUBLISHED,
  2: ProductStatus.ARCHIVED,
  3: ProductStatus.SCHEDULED
} as const;

export const BACKEND_STOCK_STATUS_MAP: Record<string, StockStatus> = {
  'inStock': StockStatus.IN_STOCK,
  'outOfStock': StockStatus.OUT_OF_STOCK,
  'onBackorder': StockStatus.ON_BACKORDER,
  'preOrder': StockStatus.PRE_ORDER,
  'discontinued': StockStatus.DISCONTINUED,
  'limitedStock': StockStatus.LIMITED_STOCK,
  'comingSoon': StockStatus.COMING_SOON
} as const;

export const BACKEND_STOCK_STATUS_NUMERIC_MAP: Record<number, StockStatus> = {
  1: StockStatus.IN_STOCK,
  0: StockStatus.OUT_OF_STOCK,  // Default when undefined/0
  2: StockStatus.OUT_OF_STOCK,
  3: StockStatus.ON_BACKORDER,
  4: StockStatus.PRE_ORDER,
  5: StockStatus.DISCONTINUED,
  6: StockStatus.LIMITED_STOCK,
  7: StockStatus.COMING_SOON
} as const;

// === UPDATED: HANDLE BOTH STRING AND NUMERIC VALUES ===
export function mapProductType(backendValue: string | number): ProductType {
  if (typeof backendValue === 'number') {
    return BACKEND_PRODUCT_TYPE_NUMERIC_MAP[backendValue] ?? ProductType.PHYSICAL;
  }
  return BACKEND_PRODUCT_TYPE_MAP[backendValue] ?? ProductType.PHYSICAL;
}

export function mapProductStatus(backendValue: string | number): ProductStatus {
  if (typeof backendValue === 'number') {
    return BACKEND_PRODUCT_STATUS_NUMERIC_MAP[backendValue] ?? ProductStatus.DRAFT;
  }
  return BACKEND_PRODUCT_STATUS_MAP[backendValue] ?? ProductStatus.DRAFT;
}

export function mapStockStatus(backendValue: string | number | null | undefined): StockStatus | undefined {
  if (backendValue == null) return undefined;
  
  if (typeof backendValue === 'number') {
    return BACKEND_STOCK_STATUS_NUMERIC_MAP[backendValue] ?? StockStatus.OUT_OF_STOCK;
  }
  return BACKEND_STOCK_STATUS_MAP[backendValue];
}
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/lib/mappers/product-mapping.service.ts ---
/**
 * @file product-mapping.service.ts
 * @version 19.0.0 (DEFINITIVE FIX: Correct Numeric StockStatus Mapping)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-06
 * @Description
 *   Definitieve, gecorrigeerde mapping service. Deze versie lost een kritieke bug op
 *   door een private helper `mapNumericStockStatusToString` toe te voegen, die
 *   numerieke stock statussen (zoals '1' voor 'inStock') van de backend DTO's
 *   correct vertaalt naar de string-enums die de frontend state verwacht. Dit
 *   herstelt de functionaliteit van de "Toevoegen aan Winkelwagen" knop.
 */
import { Injectable, inject } from '@angular/core';
import {
  Product,
  PhysicalProduct,
  VariantAttribute,
  VariantAttributeValue,
  ProductVariantCombination,
  VariantAttributeType,
  ProductType,
  ProductAvailabilityRules,
  ProductDisplaySpecification,
  ProductColorVariantTeaser,
  ProductDiscount,
  DiscountType,
  StockStatus,
  ProductStatus,
} from '@royal-code/features/products/domain';
import { Image, Media, MediaType } from '@royal-code/shared/domain';
import {
  BackendProductListItemDto,
  BackendProductDetailDto,
  BackendMediaDto,
  BackendVariantAttributeDto,
  BackendVariantAttributeValueDto,
  BackendProductVariantCombinationDto,
  BackendColorVariantTeaserDto,
  BackendProductDisplaySpecificationDto,
  BackendProductAvailabilityRulesDto,
  BackendMediaTeaserDto,
  BackendPaginatedListDto,
} from '../DTO/backend.types';
import { mapProductStatus, mapProductType, mapStockStatus } from './enum.mappers';
import { DateTimeInfo } from '@royal-code/shared/base-models';
import { AppIcon } from '@royal-code/shared/domain';
import { APP_CONFIG, AppConfig } from '@royal-code/core/config';
import { LoggerService } from '@royal-code/core/logging';

export interface ProductCollectionResponse {
  readonly items: Product[];
  readonly totalCount: number;
  readonly pageNumber: number;
  readonly totalPages: number;
  readonly hasNextPage: boolean;
  readonly hasPreviousPage: boolean;
}

@Injectable({ providedIn: 'root' })
export class ProductMappingService {
  private readonly config = inject(APP_CONFIG);
  private readonly logger = inject(LoggerService);
  private readonly backendOrigin: string;

  constructor() {
    try {
      const url = new URL(this.config.backendUrl);
      this.backendOrigin = url.origin;
    } catch (error) {
      this.logger.error(`[ProductMappingService] Invalid backendUrl in config. Could not determine origin.`, this.config.backendUrl);
      this.backendOrigin = '';
    }
  }

  /**
   * @method toAbsoluteUrl
   * @description Converteert een relatieve URL naar een absolute URL met behulp van de geconfigureerde backend origin.
   */
  private toAbsoluteUrl(relativePath: string | null | undefined): string | undefined {
    if (!relativePath) {
      return undefined;
    }
    if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
      return relativePath;
    }
    const finalPath = relativePath.startsWith('/') ? relativePath : `/${relativePath}`;
    return `${this.backendOrigin}${finalPath}`;
  }

  /**
   * @method mapProductListResponse
   * @description Mapt een gepagineerde lijst van `BackendProductListItemDto`'s naar `ProductCollectionResponse`.
   */
  public mapProductListResponse(
    backendResponse: BackendPaginatedListDto<BackendProductListItemDto>
  ): ProductCollectionResponse {
    try {
      const transformedItems = backendResponse.items.map((dto) => {
        try {
          return this.mapListItemToProduct(dto);
        } catch (error) {
          this.logger.warn(`[ProductMappingService] Failed to map product list item ${dto.id}:`, error, dto);
          return this.createFallbackProduct(dto);
        }
      });

      return {
        items: transformedItems,
        totalCount: backendResponse.totalCount,
        pageNumber: backendResponse.pageNumber,
        totalPages: backendResponse.totalPages,
        hasNextPage: backendResponse.hasNextPage,
        hasPreviousPage: backendResponse.hasPreviousPage,
      };
    } catch (error) {
      this.logger.error('[ProductMappingService] Failed to transform product list response:', error, { backendResponse });
      throw new Error('Failed to transform product list response');
    }
  }

  /**
   * @method mapListItemToProduct
   * @description Mapt een `BackendProductListItemDto` naar een `Product` domeinmodel (unchanged).
   */
  public mapListItemToProduct(dto: BackendProductListItemDto): Product {
    try {
      const allMedia = new Map<string, Media>();
      const addMediaFromTeaser = (teaser: BackendMediaTeaserDto) => {
        if (teaser && !allMedia.has(teaser.id)) {
          allMedia.set(teaser.id, this.mapMediaTeaser(teaser));
        }
      };

      (dto.featuredImages ?? []).forEach(addMediaFromTeaser);
      (dto.selectedVariant?.media ?? []).forEach(addMediaFromTeaser);
      (dto.colorVariants ?? []).forEach(cv => (cv.media ?? []).forEach(addMediaFromTeaser));

      const mappedColorVariants: ProductColorVariantTeaser[] = (dto.colorVariants ?? []).map((cv, index) => ({
        uiId: index,
        attributeValueId: cv.attributeValueId,
        defaultVariantId: cv.defaultVariantId,
        value: cv.value,
        displayName: cv.displayName,
        colorHex: cv.colorHex,
        price: cv.price,
        originalPrice: cv.originalPrice,
        media: (cv.media ?? []).map(m => allMedia.get(m.id)).filter((m): m is Media => !!m) as Image[],
      }));

      const variantAttributes: VariantAttribute[] = [];
      if (mappedColorVariants.length > 0) {
        variantAttributes.push({
          id: 'color-attribute',
          type: VariantAttributeType.COLOR,
          name: 'Kleur',
          nameKeyOrText: 'attribute.color',
          isRequired: true,
          displayType: 'swatches',
          displayOrder: 1,
          values: mappedColorVariants.map((cv, index) => ({
            id: cv.attributeValueId,
            value: cv.value,
            displayName: cv.displayName,
            displayNameKeyOrText: cv.displayName,
            sortOrder: index,
            colorHex: cv.colorHex,
            isAvailable: true,
            media: cv.media,
          })),
        });
      }

      const variantCombinations: ProductVariantCombination[] = [];
      if (dto.selectedVariant) {
        variantCombinations.push({
          id: dto.selectedVariant.id,
          sku: dto.selectedVariant.sku,
          attributes: [],
          price: dto.selectedVariant.price,
          originalPrice: dto.selectedVariant.originalPrice,
          stockQuantity: dto.selectedVariant.stockQuantity,
          stockStatus: mapStockStatus(dto.selectedVariant.stockStatus),
          isActive: true,
          isDefault: dto.selectedVariant.isDefault,
          mediaIds: (dto.selectedVariant.media ?? []).map(m => m.id),
        });
      }

      const product: PhysicalProduct = {
      id: dto.id,
      createdAt: this.toDateTimeInfo(undefined),
      lastModified: this.toDateTimeInfo(undefined),
      name: dto.name,
      shortDescription: dto.shortDescription,
      description: dto.shortDescription ?? '',
      media: Array.from(allMedia.values()),
      currency: dto.currency,
      colorVariants: mappedColorVariants,
      categoryIds: (dto.categories ?? []).map(c => c.id), // FIX: Extract IDs from category objects
      tags: dto.tags ? [...dto.tags] : [],
      variantAttributes: variantAttributes,
      variantCombinations: variantCombinations,
      averageRating: dto.averageRating ?? 0,
      reviewCount: dto.reviewCount,
      isActive: dto.isActive,
      isFeatured: dto.isFeatured,
      status: mapProductStatus(dto.status), 
      price: dto.price,
      originalPrice: dto.originalPrice,
      stockStatus: mapStockStatus(dto.stockStatus), 
      inStock: dto.inStock,
      stockQuantity: dto.selectedVariant?.stockQuantity,
      type: ProductType.PHYSICAL,
      sku: dto.selectedVariant?.sku,
      manageStock: true,
      allowBackorders: false,
    };

    return product;
  } catch (error) {
    this.logger.error(`[ProductMappingService] Critical error mapping list item for ID: ${dto.id}`, error, dto);
    return this.createFallbackProduct(dto);
  }
}

   public mapProductDetail(dto: BackendProductDetailDto): Product {
    if (!dto) {
      this.logger.error('[ProductMappingService] Cannot map product detail: DTO is null or undefined.');
      throw new Error('Cannot map product detail: DTO is null or undefined.');
    }

    try {
      const allMedia = new Map<string, Media>();
      const addMediaToMap = (mediaItem: Media) => {
        if (mediaItem && !allMedia.has(mediaItem.id)) {
          allMedia.set(mediaItem.id, mediaItem);
        }
      };

      if (dto.featuredImage) {
        const featuredMedia: Image = {
          id: dto.featuredImage.id,
          type: MediaType.IMAGE,
          variants: [{ url: this.toAbsoluteUrl(dto.featuredImage.url) || '', purpose: 'original' }],
          altText: dto.featuredImage.altTextKeyOrText,
        };
        addMediaToMap(featuredMedia);
      }

      const variantAttributes = (dto.variantAttributes ?? []).map(attrDto => {
        const mappedAttr = this.mapVariantAttribute(attrDto);
        mappedAttr.values.forEach(value => {
          (value.media ?? []).forEach(addMediaToMap);
        });
        return mappedAttr;
      });

      const variantCombinations = (dto.variantCombinations ?? []).map(comboDto => {
        const mappedCombo = this.mapVariantCombination(comboDto);
        (comboDto.media ?? []).forEach(mediaDto => {
          addMediaToMap(this.mapMedia(mediaDto));
        });
        return mappedCombo;
      });

      if (dto.selectedVariant?.media) {
        dto.selectedVariant.media.forEach(mediaDto => {
          addMediaToMap(this.mapMedia(mediaDto as BackendMediaDto));
        });
      }

      const media = Array.from(allMedia.values());
      const colorAttribute = variantAttributes.find(attr => attr.type === VariantAttributeType.COLOR);
      const mappedColorVariants: ProductColorVariantTeaser[] = (colorAttribute?.values ?? []).map(val => {
        const combo = variantCombinations.find(c => c.attributes.some(a => a.attributeValueId === val.id));
        return {
          uiId: 0,
          attributeValueId: val.id,
          defaultVariantId: combo?.id ?? val.id,
          value: val.value,
          displayName: val.displayName,
          colorHex: val.colorHex,
          price: combo?.price ?? 0,
          originalPrice: combo?.originalPrice,
          media: val.media,
        };
      });

      const physicalConfig = dto.physicalProductConfig;
      const selectedVariantDto = dto.selectedVariant;
      const defaultVariantCombinationDto = dto.variantCombinations?.find(v => v.isDefault) ?? dto.variantCombinations?.[0];
      const priceRange = dto.priceRange;

      const price: number = selectedVariantDto?.price ?? physicalConfig?.pricing?.price ?? defaultVariantCombinationDto?.price ?? priceRange?.maxPrice ?? priceRange?.minPrice ?? 0;
      const originalPrice = selectedVariantDto?.originalPrice ?? physicalConfig?.pricing?.originalPrice ?? defaultVariantCombinationDto?.originalPrice ?? priceRange?.maxOriginalPrice ?? priceRange?.minOriginalPrice ?? undefined;
      const stockQuantity = selectedVariantDto?.stockQuantity ?? physicalConfig?.stockQuantity ?? dto.stockQuantity ?? undefined;

      const stockStatus = mapStockStatus(selectedVariantDto?.stockStatus ?? dto.stockStatus);

      const displaySpecifications = this.mapDisplaySpecifications(physicalConfig?.displaySpecifications ?? dto.displaySpecifications ?? []);
      const availabilityRules = this.mapAvailabilityRules(dto.availabilityRules ?? null);

      const hasDiscount = dto.hasDiscount;
      const activeDiscount: ProductDiscount | null = hasDiscount && originalPrice && price < originalPrice ? {
        id: 'product-discount',
        type: DiscountType.PERCENTAGE,
        value: Math.round(((originalPrice - price) / originalPrice) * 100),
        isActive: true,
      } : null;

      const mappedType = mapProductType(dto.type);

      const baseProduct: Omit<Product, 'type'> = {
      id: dto.id,
      createdAt: this.toDateTimeInfo(undefined),
      lastModified: this.toDateTimeInfo(undefined),
      name: dto.name,
      shortDescription: dto.shortDescription ?? undefined,
      description: dto.description ?? '',
      media: media,
      currency: dto.currency ?? 'EUR',
      colorVariants: mappedColorVariants,
      categoryIds: (dto.categories ?? []).map(cat => cat.id), // FIX: Extract IDs properly
      tags: dto.tags ? [...dto.tags] : [],
      variantAttributes,
      variantCombinations,
      averageRating: dto.averageRating ?? 0,
      reviewCount: dto.reviewCount || 0,
      isActive: dto.isActive,
      isFeatured: dto.isFeatured,
      status: mapProductStatus(dto.status), // FIX: Use numeric mapper
      searchKeywords: dto.seo?.keywords ? [...dto.seo.keywords] : dto.tags ? [...dto.tags] : undefined,
      customAttributes: dto.customAttributes ?? undefined,
      appScope: dto.appScope ?? undefined,
      metaTitle: dto.seo?.title ?? dto.name,
      metaDescription: dto.seo?.description ?? dto.shortDescription,
      metaKeywords: dto.seo?.keywords ? [...dto.seo.keywords] : dto.tags ? [...dto.tags] : undefined,
      price,
      originalPrice,
      stockStatus: mapStockStatus(dto.stockStatus), // FIX: Use numeric mapper
      inStock: dto.inStock,
      stockQuantity,
    };

    const detailProductType = mapProductType(dto.type);

    if (detailProductType === ProductType.PHYSICAL) {
      return {
        ...baseProduct,
        type: ProductType.PHYSICAL,
        activeDiscount,
        sku: dto.sku ?? physicalConfig?.sku ?? undefined,
        brand: dto.brand ?? physicalConfig?.brand ?? undefined,
        manageStock: dto.availabilityRules?.manageStock ?? physicalConfig?.manageStock ?? true,
        allowBackorders: dto.availabilityRules?.allowBackorders ?? physicalConfig?.allowBackorders ?? false,
        lowStockThreshold: dto.availabilityRules?.lowStockThreshold ?? physicalConfig?.lowStockThreshold ?? undefined,
        displaySpecifications,
        availabilityRules,
      } as PhysicalProduct;
    }

    return { ...baseProduct, type: ProductType.PHYSICAL, sku: dto.sku ?? undefined } as PhysicalProduct;

  } catch (error) {
    this.logger.error(`[ProductMappingService] Critical error mapping product detail for ID: ${dto.id}`, error, dto);
    return this.createFallbackProduct(dto);
  }
}
  
  public mapMediaArray(dtos: readonly BackendMediaDto[] | null): Media[] {
    if (!dtos) return [];
    return dtos.map(dto => this.mapMedia(dto));
  }

  private mapMediaTeaser(dto: BackendMediaTeaserDto): Media {
    const variants: Image['variants'] = [];
    const mainUrl = this.toAbsoluteUrl(dto.url);
    const thumbUrl = this.toAbsoluteUrl(dto.thumbnailUrl);

    if (mainUrl) {
      variants.push({ url: mainUrl, purpose: 'original' });
    }
    if (thumbUrl && thumbUrl !== mainUrl) {
      variants.push({ url: thumbUrl, purpose: 'thumbnail' });
    }
    if (variants.length === 0 && thumbUrl) {
        variants.push({ url: thumbUrl, purpose: 'fallback' });
    }

    return {
      id: dto.id,
      type: MediaType.IMAGE,
      variants: variants,
      altText: dto.altText ?? undefined,
    } as Image;
  }

  private mapMedia(dto: BackendMediaDto): Media {
    const mediaType = this.mapMediaType(dto.type ?? 0);

    const common = {
      id: dto.id,
      type: mediaType,
      createdAt: this.toDateTimeInfo(undefined),
      lastModified: this.toDateTimeInfo(undefined),
    };

    if (mediaType === MediaType.IMAGE) {
      const variants: Image['variants'] = [];
      const mainUrl = this.toAbsoluteUrl(dto.url);
      const thumbUrl = this.toAbsoluteUrl(dto.thumbnailUrl);

      if (mainUrl) {
        variants.push({ url: mainUrl, purpose: 'original' });
      }
      if (thumbUrl && thumbUrl !== mainUrl) {
        variants.push({ url: thumbUrl, purpose: 'thumbnail' });
      }
      if (variants.length === 0 && mainUrl) {
          variants.push({ url: mainUrl, purpose: 'fallback' });
      }

      return { ...common, variants, altText: dto.altTextKeyOrText ?? undefined } as Image;
    }

    return {
      ...common,
      url: this.toAbsoluteUrl(dto.url) || '',
      thumbnailUrl: this.toAbsoluteUrl(dto.thumbnailUrl) ?? undefined
    } as Media;
  }

  private mapMediaType(backendType: number | string): MediaType {
    if (typeof backendType === 'string') {
      const stringToEnumMap: Record<string, MediaType> = {
        image: MediaType.IMAGE, video: MediaType.VIDEO, audio: MediaType.AUDIO,
        document: MediaType.DOCUMENT, archive: MediaType.ARCHIVE, other: MediaType.OTHER,
      };
      return stringToEnumMap[backendType.toLowerCase()] ?? MediaType.OTHER;
    } else if (typeof backendType === 'number') {
      const numberToEnumMap: Record<number, MediaType> = {
        0: MediaType.IMAGE, 1: MediaType.VIDEO, 2: MediaType.AUDIO,
        3: MediaType.DOCUMENT, 4: MediaType.ARCHIVE,
      };
      return numberToEnumMap[backendType] ?? MediaType.OTHER;
    }
    this.logger.warn(`[ProductMappingService] Unknown backend media type encountered: ${backendType}. Falling back to OTHER.`);
    return MediaType.OTHER;
  }

  private mapVariantAttribute(dto: BackendVariantAttributeDto): VariantAttribute {
    const typeMap: Record<number, VariantAttributeType> = {
      0: VariantAttributeType.COLOR,
      18: VariantAttributeType.CUSTOM,
      19: VariantAttributeType.CUSTOM,
    };

    const attributeId = dto.id;
    const nameKeyOrText = dto.nameKeyOrText;
    const attributeType = typeMap[dto.type] ?? VariantAttributeType.CUSTOM;

    let displayName = nameKeyOrText;
    if (nameKeyOrText.includes('.')) {
      displayName = (nameKeyOrText.split('.').pop() || '').replace(/^\w/, c => c.toUpperCase());
    } else if (nameKeyOrText === 'attribute.other' || attributeType === VariantAttributeType.CUSTOM) {
      displayName = 'Configuratie';
    }

    return {
      id: attributeId,
      type: attributeType,
      name: displayName,
      nameKeyOrText: nameKeyOrText,
      isRequired: dto.isRequired,
      displayType: dto.displayType as any,
      displayOrder: 0,
      values: dto.values.map(v => this.mapVariantAttributeValue(v)),
    };
  }

  private mapVariantAttributeValue(dto: BackendVariantAttributeValueDto): VariantAttributeValue {
    const mediaItems: Media[] = [];
    if (dto.media) {
        mediaItems.push(this.mapMedia(dto.media as BackendMediaDto));
    }

    return {
      id: dto.id,
      value: dto.value,
      displayName: dto.displayNameKeyOrText,
      displayNameKeyOrText: dto.displayNameKeyOrText,
      sortOrder: 0,
      colorHex: dto.colorHex ?? undefined,
      priceModifier: dto.priceModifier ?? undefined,
      isAvailable: dto.isAvailable,
      media: mediaItems,
    };
  }

  private mapVariantCombination(dto: BackendProductVariantCombinationDto): ProductVariantCombination {
  return {
    id: dto.id,
    sku: dto.sku,
    attributes: (dto.attributes ?? []).map(a => ({
      attributeId: a.attributeId,
      attributeValueId: a.attributeValueId,
      attributeNameKeyOrText: a.attributeNameKeyOrText,
      attributeValueNameKeyOrText: a.attributeValueNameKeyOrText,
      colorHex: a.colorHex ?? undefined,
    })),
    price: dto.price ?? undefined,
    originalPrice: dto.originalPrice ?? undefined,
    stockQuantity: dto.stockQuantity ?? undefined,
    stockStatus: mapStockStatus(dto.stockStatus), // FIX: Use numeric mapper
    isActive: true,
    isDefault: dto.isDefault ?? false,
    mediaIds: (dto.media ?? []).map(m => m.id),
  };
}

  private mapDisplaySpecifications(dtos: readonly BackendProductDisplaySpecificationDto[]): ProductDisplaySpecification[] {
    return dtos.map(dto => ({
      specKey: dto.specKey,
      labelKeyOrText: dto.labelKeyOrText,
      valueKeyOrText: dto.valueKeyOrText,
      icon: (dto.icon as AppIcon) ?? null,
      groupKeyOrText: dto.groupKeyOrText ?? null,
      displayOrder: dto.displayOrder ?? 0,
    }));
  }

  private mapAvailabilityRules(dto: BackendProductAvailabilityRulesDto | null): ProductAvailabilityRules | undefined {
    if (!dto) return undefined;
    return {
      minOrderQuantity: dto.minOrderQuantity ?? undefined,
      maxOrderQuantity: dto.maxOrderQuantity ?? undefined,
      quantityIncrements: dto.quantityIncrements ?? undefined,
    };
  }

  private createFallbackProduct(dto: BackendProductListItemDto | BackendProductDetailDto): Product {
    this.logger.warn(`[ProductMappingService] Creating fallback product for ID: ${dto.id}`);

    return {
      id: dto.id,
      createdAt: this.toDateTimeInfo(undefined),
      lastModified: this.toDateTimeInfo(undefined),
      name: dto.name || 'Unknown Product',
      shortDescription: dto.shortDescription ?? undefined,
      description: dto.shortDescription ?? 'Product details unavailable',
      currency: 'EUR',
      categoryIds: [],
      tags: dto.tags ? [...dto.tags] : [],
      averageRating: dto.averageRating ?? 0,
      reviewCount: dto.reviewCount || 0,
      isActive: dto.isActive,
      isFeatured: false,
      status: ProductStatus.DRAFT,
      searchKeywords: undefined,
      customAttributes: undefined,
      appScope: undefined,
      metaTitle: dto.name,
      metaDescription: dto.shortDescription,
      metaKeywords: undefined,
      price: 0,
      originalPrice: undefined,
      stockStatus: StockStatus.OUT_OF_STOCK,
      inStock: false,
      stockQuantity: undefined,
      type: ProductType.PHYSICAL,
      media: [],
      variantAttributes: [],
      variantCombinations: [],
      colorVariants: [],
      sku: undefined,
    } as PhysicalProduct;
  }

  private toDateTimeInfo(isoString?: string): DateTimeInfo | undefined {
    if (!isoString) return undefined;
    try {
      const date = new Date(isoString);
      if (isNaN(date.getTime())) return undefined;
      return { iso: isoString, timestamp: date.getTime() };
    } catch (e) {
      this.logger.error(`[ProductMappingService] Failed to parse date string: ${isoString}`, e);
      return undefined;
    }
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/lib/services/category-tree.service.ts ---
/**
 * @file libs/ui/products/src/lib/filter-sidebar/category-tree.service.ts
 * @Version 1.1.0 (Fixed Types & Module Resolution)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-07
 * @Description
 *   Service for fetching and managing category tree data from the backend.
 *   FIXED: All TypeScript type issues and proper return types.
 */
import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, firstValueFrom } from 'rxjs';
import { APP_CONFIG } from '@royal-code/core/config';
import { ProductFilters, FilterOption } from '@royal-code/features/products/domain';
import { LoggerService } from '@royal-code/core/logging';

export interface BackendCategory {
  id: string;
  key: string;
  parentId: string | null;
  children: BackendCategory[];
}

export interface CategoryTreeNode {
  id: string;
  key: string;
  name: string;
  slug: string;
  parentId: string | null;
  children: CategoryTreeNode[];
  count?: number;
  isExpanded?: boolean;
  isSelected?: boolean;
  level: number;
}

export interface CategoryTreeWithCounts {
  tree: CategoryTreeNode[];
  totalCount: number;
  hasFilters: boolean;
}

@Injectable({ providedIn: 'root' })
export class CategoryTreeService {
  private readonly http = inject(HttpClient);
  private readonly config = inject(APP_CONFIG);
  private readonly logger = inject(LoggerService);
  private readonly apiUrl = `${this.config.backendUrl}/Products`;

  /**
   * Haal de volledige category tree op van de backend
   */
  getCategoryTree(): Observable<BackendCategory[]> {
    this.logger.debug('[CategoryTreeService] Fetching category tree from backend');
    return this.http.get<BackendCategory[]>(`${this.apiUrl}/categories`);
  }

  /**
   * Async versie voor gebruik in components
   */
  async getCategoryTreeAsync(): Promise<BackendCategory[]> {
    try {
      return await firstValueFrom(this.getCategoryTree());
    } catch (error) {
      this.logger.error('[CategoryTreeService] Failed to fetch category tree:', error);
      return [];
    }
  }

  /**
   * Transformeer backend categorieën naar frontend CategoryTreeNode format
   */
  transformToTreeNodes(backendCategories: BackendCategory[], level: number = 0): CategoryTreeNode[] {
    return backendCategories.map(cat => ({
      id: cat.id,
      key: cat.key,
      name: this.getDisplayNameFromKey(cat.key),
      slug: cat.key,
      parentId: cat.parentId,
      children: this.transformToTreeNodes(cat.children, level + 1),
      level,
      count: 0,
      isExpanded: level === 0, // Top level standaard uitgeklapt
      isSelected: false
    }));
  }

  /**
   * Combineer category tree met counts uit filter data
   */
  enrichTreeWithCounts(
    tree: CategoryTreeNode[], 
    filterOptions: FilterOption[], 
    selectedCategoryIds: readonly string[] = []
  ): CategoryTreeNode[] {
    // Maak een count map van de filter opties
    const countMap = new Map<string, number>();
    filterOptions.forEach(option => {
      countMap.set(option.value, option.count);
    });

    return this.enrichNodeWithCounts(tree, countMap, [...selectedCategoryIds]);
  }

  private enrichNodeWithCounts(
    nodes: CategoryTreeNode[], 
    countMap: Map<string, number>,
    selectedCategoryIds: string[]
  ): CategoryTreeNode[] {
    return nodes.map(node => {
      const enrichedChildren = this.enrichNodeWithCounts(node.children, countMap, selectedCategoryIds);
      
      // Directe count uit filter data
      const directCount = countMap.get(node.id) || 0;
      
      // Totaal count inclusief kinderen
      const childrenCount = enrichedChildren.reduce((sum, child) => sum + (child.count || 0), 0);
      const totalCount = directCount + childrenCount;

      return {
        ...node,
        children: enrichedChildren,
        count: totalCount,
        isSelected: selectedCategoryIds.includes(node.id),
        // Hou expanded state als er kinderen zijn met counts > 0
        isExpanded: node.isExpanded || enrichedChildren.some(child => (child.count || 0) > 0)
      };
    });
  }

  /**
   * Converteer category key naar display naam
   */
  private getDisplayNameFromKey(key: string): string {
    // Eenvoudige conversie - in production zou je een translation service gebruiken
    const parts = key.split('.');
    const lastPart = parts[parts.length - 1];
    
    // Converteer camelCase naar readable text
    return lastPart
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, str => str.toUpperCase())
      .replace(/([a-z])([A-Z])/g, '$1 $2')
      .trim();
  }

  /**
   * Vind een node in de tree op basis van ID
   */
  findNodeById(tree: CategoryTreeNode[], id: string): CategoryTreeNode | null {
    for (const node of tree) {
      if (node.id === id) {
        return node;
      }
      const found = this.findNodeById(node.children, id);
      if (found) {
        return found;
      }
    }
    return null;
  }

  /**
   * Krijg alle parent IDs van een gegeven node
   */
  getParentPath(tree: CategoryTreeNode[], nodeId: string): string[] {
    const path: string[] = [];
    const node = this.findNodeById(tree, nodeId);
    
    if (!node) return path;
    
    let currentParentId = node.parentId;
    while (currentParentId) {
      const parentNode = this.findNodeById(tree, currentParentId);
      if (parentNode) {
        path.unshift(parentNode.id);
        currentParentId = parentNode.parentId;
      } else {
        break;
      }
    }
    
    return path;
  }

  /**
   * Toggle expanded state van een node
   */
  toggleNodeExpanded(tree: CategoryTreeNode[], nodeId: string): CategoryTreeNode[] {
    return this.updateNodeInTree(tree, nodeId, node => ({
      ...node,
      isExpanded: !node.isExpanded
    }));
  }

  /**
   * Update een specifieke node in de tree
   */
  private updateNodeInTree(
    tree: CategoryTreeNode[], 
    nodeId: string, 
    updater: (node: CategoryTreeNode) => CategoryTreeNode
  ): CategoryTreeNode[] {
    return tree.map(node => {
      if (node.id === nodeId) {
        return updater(node);
      }
      return {
        ...node,
        children: this.updateNodeInTree(node.children, nodeId, updater)
      };
    });
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/lib/state/product.actions.ts ---
/**
 * @file product.actions.ts
 * @Version 14.0.0 (Search Actions Integrated)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-01
 * @Description
 *   Defines all NgRx actions for the Product domain. This version integrates
 *   actions for handling product search functionality.
 */
import { createActionGroup, emptyProps, props } from '@ngrx/store';
import { Update } from '@ngrx/entity';
import { AvailableFiltersResponse, Product, ProductFilters } from '@royal-code/features/products/domain';
import { CreateProductPayload, UpdateProductPayload, FeatureError } from './product.types';

export const ProductActions = createActionGroup({
  source: 'Product',
  events: {
    // === Page Lifecycle & Context Management ===
    'Page Opened': props<{ initialFilters?: Partial<ProductFilters>; forceRefresh?: boolean; }>(),
    'Page Closed': emptyProps(),
    'Filters Updated': props<{ filters: Partial<ProductFilters> }>(),
    'Next Page Loaded': emptyProps(),
    'Data Refreshed': emptyProps(),

    // === Search Operations ===
    'Search Submitted': props<{ query: string }>(),
    'Search Success': props<{ products: Product[]; totalCount: number; hasMore: boolean }>(),
    'Search Failure': props<{ error: FeatureError }>(),
    'Search State Cleared': emptyProps(),

    // === Data Loading API Operations ===
    'Load Products': emptyProps(),
    'Load Products Success': props<{ products: Product[]; totalCount: number; hasMore: boolean }>(),
    'Load Products Failure': props<{ error: FeatureError }>(),
    'Load Featured Products': emptyProps(),
    'Load Featured Products Success': props<{ products: Product[] }>(),
    'Load Featured Products Failure': props<{ error: FeatureError }>(),
    'Load Products By Ids': props<{ ids: readonly string[] }>(),
    'Load Products By Ids Success': props<{ products: Product[] }>(),
    'Load Products By Ids Failure': props<{ error: FeatureError }>(),
    'Load Product Detail Success': props<{ product: Product }>(),
    'Load Product Detail Failure': props<{ error: FeatureError; id: string }>(),
    'Load Recommendations': emptyProps(),
    'Load Recommendations Success': props<{ products: Product[] }>(),
    'Load Recommendations Failure': props<{ error: FeatureError }>(),

    // === Filter Definition Loading ===
    'Load Available Filters': emptyProps(),
    'Load Available Filters Success': props<{ filters: AvailableFiltersResponse }>(),
    'Load Available Filters Failure': props<{ error: FeatureError }>(),

    // === CRUD Operations ===
    'Create Product Submitted': props<{ payload: CreateProductPayload; tempId: string }>(),
    'Create Product Success': props<{ product: Product; tempId: string }>(),
    'Create Product Failure': props<{ error: FeatureError; tempId: string }>(),
    'Update Product Submitted': props<{ id: string; payload: UpdateProductPayload }>(),
    'Update Product Success': props<{ productUpdate: Update<Product> }>(),
    'Update Product Failure': props<{ error: FeatureError; id: string }>(),
    'Delete Product Confirmed': props<{ id: string }>(),
    'Delete Product Success': props<{ id: string }>(),
    'Delete Product Failure': props<{ error: FeatureError; id:string }>(),
    'Bulk Delete Products Confirmed': props<{ ids: readonly string[] }>(),
    'Bulk Delete Products Success': props<{ ids: readonly string[] }>(),
    'Bulk Delete Products Failure': props<{ error: FeatureError; ids: readonly string[] }>(),

    // === UI State & User Interactions ===
    'Product Selected': props<{ id: string | null }>(),
    'Variant Combination Selected': props<{ productId: string; selectedVariantCombinationId: string | null; }>(),
    'Variant Selection Cleared': props<{ productId: string }>(),
    'Error Cleared': emptyProps(),
  },
});
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/lib/state/product.effects.ts ---
/**
 * @file product.effects.ts
 * @version 16.0.0 (Loop Fix - Minimal Effects)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-06
 * @Description
 *   Minimal and safe effects for Product domain. This version eliminates ALL
 *   potential circular dependencies by having very specific, isolated effects
 *   that don't trigger each other.
 */
import { Injectable, inject } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { Store } from '@ngrx/store';
import { of } from 'rxjs';
import { map, switchMap, catchError, withLatestFrom, exhaustMap, mergeMap, tap } from 'rxjs/operators';
import { NotificationService } from '@royal-code/ui/notifications';
import { ProductActions } from './product.actions';
import { selectProductsState, selectProductEntities } from './product.feature';
import { AbstractProductApiService } from '../data-access/abstract-product-api.service';
import { ProductMappingService } from '../mappers/product-mapping.service';
import { ErrorActions } from '@royal-code/store/error';
import { StructuredError } from '@royal-code/shared/domain';
import { FeatureError } from './product.types';

@Injectable()
export class ProductEffects {
  private readonly actions$ = inject(Actions);
  private readonly store = inject(Store);
  private readonly productsApiService = inject(AbstractProductApiService);
  private readonly mappingService = inject(ProductMappingService);
  private readonly notificationService = inject(NotificationService);

  /**
   * FIXED: Only trigger on page opened (initial load)
   */
  triggerInitialLoad$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ProductActions.pageOpened),
      map(() => {
        console.log('%c[ProductEffects] Page opened - dispatching loadProducts', 'color: blue; font-weight: bold;');
        return ProductActions.loadProducts();
      })
    )
  );

  /**
   * FIXED: Only trigger on filters updated (filter changes)
   */
  triggerFilterLoad$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ProductActions.filtersUpdated),
      map(() => {
        console.log('%c[ProductEffects] Filters updated - dispatching loadProducts', 'color: blue; font-weight: bold;');
        return ProductActions.loadProducts();
      })
    )
  );

  /**
   * FIXED: Only trigger on data refreshed (manual refresh)
   */
  triggerRefreshLoad$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ProductActions.dataRefreshed),
      map(() => {
        console.log('%c[ProductEffects] Data refreshed - dispatching loadProducts', 'color: blue; font-weight: bold;');
        return ProductActions.loadProducts();
      })
    )
  );

  /**
   * ISOLATED: Load products effect that only responds to loadProducts action
   */
  loadProducts$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ProductActions.loadProducts),
      withLatestFrom(this.store.select(selectProductsState)),
      switchMap(([action, state]) => {
        console.log('%c[ProductEffects] Loading products with filters:', 'color: orange; font-weight: bold;', JSON.stringify(state.filters, null, 2));
        
        return this.productsApiService.getProducts(state.filters).pipe(
          map(dto => {
            const collection = this.mappingService.mapProductListResponse(dto);
            console.log('%c[ProductEffects] Products loaded successfully:', 'color: green;', collection.items.length, 'products');
            return ProductActions.loadProductsSuccess({ 
              products: collection.items, 
              totalCount: collection.totalCount, 
              hasMore: dto.hasNextPage 
            });
          }),
          catchError((err) => {
            console.error('%c[ProductEffects] Failed to load products:', 'color: red;', err);
            return of(ProductActions.loadProductsFailure({ 
              error: { 
                message: err.message || 'Failed to load products.', 
                operation: 'loadProducts' 
              } 
            }));
          })
        );
      })
    )
  );

  /**
   * ISOLATED: Load available filters when page opens
   */
  loadAvailableFilters$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ProductActions.pageOpened),
      switchMap(() =>
        this.productsApiService.getAvailableFilters().pipe(
          map(filters => {
            console.log('%c[ProductEffects] Available filters loaded:', 'color: blue;', filters);
            return ProductActions.loadAvailableFiltersSuccess({ filters });
          }),
          catchError(error => {
            console.error('%c[ProductEffects] Failed to load available filters:', 'color: red;', error);
            return of(ProductActions.loadAvailableFiltersFailure({
              error: { message: error.message || 'Failed to load available filters.', operation: 'loadAvailableFilters' }
            }));
          })
        )
      )
    )
  );

  // === ISOLATED EFFECTS (No circular dependencies) ===

  searchProducts$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ProductActions.searchSubmitted),
      switchMap(({ query }) =>
        this.productsApiService.searchProducts(query).pipe(
          map(dto => {
            const collection = this.mappingService.mapProductListResponse(dto);
            return ProductActions.searchSuccess({ 
              products: collection.items, 
              totalCount: collection.totalCount, 
              hasMore: dto.hasNextPage 
            });
          }),
          catchError((err) => of(ProductActions.searchFailure({ 
            error: { 
              message: err.message || 'Failed to execute search.', 
              operation: 'searchProducts' 
            } 
          })))
        )
      )
    )
  );

  loadFeaturedProducts$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ProductActions.loadFeaturedProducts),
      switchMap(() =>
        this.productsApiService.getFeaturedProducts().pipe(
          map(paginatedDto => {
            const products = paginatedDto.items.map(dto => this.mappingService.mapListItemToProduct(dto));
            return ProductActions.loadFeaturedProductsSuccess({ products });
          }),
          catchError((err) => of(ProductActions.loadFeaturedProductsFailure({
            error: { message: err.message || 'Failed to load featured products.', operation: 'loadFeaturedProducts' }
          })))
        )
      )
    )
  );

  loadRecommendations$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ProductActions.loadRecommendations),
      switchMap(() =>
        this.productsApiService.getRecommendations().pipe(
          map(dto => {
            const collection = this.mappingService.mapProductListResponse(dto);
            return ProductActions.loadRecommendationsSuccess({ products: collection.items });
          }),
          catchError((err) => of(ProductActions.loadRecommendationsFailure({ 
            error: { 
              message: err.message || 'Failed to load recommendations.', 
              operation: 'loadRecommendations' 
            } 
          })))
        )
      )
    )
  );

  loadSelectedProduct$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ProductActions.productSelected),
      switchMap(({ id }) => {
        if (!id) {
          return of(ProductActions.loadProductDetailFailure({ 
            error: { 
              message: 'No product ID provided.', 
              operation: 'getProductById' 
            }, 
            id: '' 
          }));
        }
        
        return this.productsApiService.getProductById(id).pipe(
          tap(dto => console.log('%c[ProductEffects] Raw product detail DTO:', 'color: #FF5722; font-weight: bold;', structuredClone(dto))),
          map(dto => {
            const productDetail = this.mappingService.mapProductDetail(dto);
            return ProductActions.loadProductDetailSuccess({ product: productDetail });
          }),
          catchError((err) => of(ProductActions.loadProductDetailFailure({ 
            error: { 
              message: err.message || `Failed to load details for product ${id}.`, 
              operation: 'getProductById' 
            }, 
            id: id 
          })))
        );
      })
    )
  );

  loadProductsByIds$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ProductActions.loadProductsByIds),
      withLatestFrom(this.store.select(selectProductEntities)),
      switchMap(([{ ids }, entities]) => {
        const missingIds = ids.filter(id => !entities[id]);
        
        if (missingIds.length === 0) {
          return of(); // No missing products, no action needed
        }

        return this.productsApiService.getProductsByIds(missingIds).pipe(
          map(dtos => ProductActions.loadProductsByIdsSuccess({
            products: dtos.map(dto => this.mappingService.mapListItemToProduct(dto)),
          })),
          catchError((err) => {
            const structuredError: StructuredError = {
              message: 'Een of meer van de benodigde productonderdelen konden niet worden geladen.',
              code: 'PRODUCT_BY_ID_404',
              operation: 'loadProductsByIds',
              context: { originalError: err.message, status: err.status, missingIds: missingIds },
              timestamp: Date.now(),
              severity: 'warning',
              source: '[ProductEffects]',
            };
            
            return of(
              ErrorActions.reportError({ error: structuredError }),
              ProductActions.loadProductsByIdsFailure({ error: structuredError })
            );
          })
        );
      })
    )
  );

  loadNextPage$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ProductActions.nextPageLoaded),
      withLatestFrom(this.store.select(selectProductsState)),
      exhaustMap(([, state]) => {
        if (!state.hasMore || state.isLoading) {
          return of(); // No more pages or already loading
        }

        const nextPageFilters = { 
          ...state.filters, 
          page: state.currentPage + 1 
        };

        return this.productsApiService.getProducts(nextPageFilters).pipe(
          map(dto => {
            const collection = this.mappingService.mapProductListResponse(dto);
            return ProductActions.loadProductsSuccess({ 
              products: collection.items, 
              totalCount: collection.totalCount, 
              hasMore: dto.hasNextPage 
            });
          }),
          catchError((err) => of(ProductActions.loadProductsFailure({ 
            error: { 
              message: err.message || 'Failed to load next page.', 
              operation: 'loadNextPage' 
            } 
          })))
        );
      })
    )
  );
}
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/lib/state/product.facade.ts ---
/**
 * @file product.facade.ts
 * @version 17.0.0 (Search Facade Methods Integrated)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-01
 * @Description
 *   The definitive public-facing API for Product state management. This version
 *   integrates methods and signals for handling product search functionality.
 */
import { Injectable, Signal, inject } from '@angular/core';
import { toSignal } from '@angular/core/rxjs-interop';
import { Store } from '@ngrx/store';
import { map, Observable } from 'rxjs';
import { ProductActions } from './product.actions';
import {
  initialProductState, selectIsLoading, selectIsSubmitting, selectError, selectAllProducts,
  selectSelectedProduct, selectFeaturedProducts, selectProductListViewModel,
  selectHasProducts, selectIsBusy, selectRecommendations,
  selectAvailableFilters, selectIsLoadingFilters, selectProductEntities,
  selectSearchViewModel, selectIsSearching, selectSearchResults
} from './product.feature';
import { AvailableFiltersResponse, ProductListViewModel, CreateProductPayload, UpdateProductPayload, FeatureError } from './product.types';
import { Product, ProductCategory, ProductFilters } from '@royal-code/features/products/domain';
import { LoggerService } from '@royal-code/core/logging';
import { Dictionary } from '@ngrx/entity';

@Injectable({ providedIn: 'root' })
export class ProductFacade {
  private readonly store = inject(Store);
  private readonly logger = inject(LoggerService);

  // === Primary API: ViewModel ===
  public readonly viewModel: Signal<ProductListViewModel> = toSignal(
    this.store.select(selectProductListViewModel),
    { initialValue: this.createInitialViewModel() }
  );
  public readonly viewModel$: Observable<ProductListViewModel> = this.store.select(selectProductListViewModel);

  // === Search ViewModel & Signals ===
  public readonly searchViewModel = toSignal(this.store.select(selectSearchViewModel));
  public readonly isSearching: Signal<boolean> = toSignal(this.store.select(selectIsSearching), { initialValue: false });
  public readonly searchResults: Signal<readonly Product[]> = toSignal(this.store.select(selectSearchResults), { initialValue: [] });
  
  // === Granular State Signals ===
  public readonly isLoading: Signal<boolean> = toSignal(this.store.select(selectIsLoading), { initialValue: true });
  public readonly isSubmitting: Signal<boolean> = toSignal(this.store.select(selectIsSubmitting), { initialValue: false });
  public readonly error: Signal<FeatureError | null> = toSignal(this.store.select(selectError), { initialValue: null });
  public readonly allProducts: Signal<readonly Product[]> = toSignal(this.store.select(selectAllProducts), { initialValue: [] });
  public readonly selectedProduct: Signal<Product | undefined> = toSignal(this.store.select(selectSelectedProduct));
  public readonly featuredProducts: Signal<readonly Product[]> = toSignal(this.store.select(selectFeaturedProducts), { initialValue: [] });
  public readonly recommendations: Signal<readonly Product[]> = toSignal(this.store.select(selectRecommendations), { initialValue: [] });
  public readonly availableFilters: Signal<AvailableFiltersResponse | null> = toSignal(this.store.select(selectAvailableFilters), { initialValue: null });
  public readonly isLoadingFilters: Signal<boolean> = toSignal(this.store.select(selectIsLoadingFilters), { initialValue: false });
  public readonly hasProducts: Signal<boolean> = toSignal(this.store.select(selectHasProducts), { initialValue: false });
  public readonly isBusy: Signal<boolean> = toSignal(this.store.select(selectIsBusy), { initialValue: true });
  public readonly productEntities: Signal<Dictionary<Product>> = toSignal(this.store.select(selectProductEntities), { initialValue: {} });

  // === Action Dispatchers ===

  /**
   * @method search
   * @description Dispatches an action to perform a product search.
   * @param query - The search term.
   */
  public search(query: string): void {
    this.store.dispatch(ProductActions.searchSubmitted({ query }));
    this.logger.info(`[ProductFacade] Dispatched searchSubmitted action for query: "${query}"`);
  }

  /**
   * @method clearSearch
   * @description Dispatches an action to clear the search state.
   */
  public clearSearch(): void {
    this.store.dispatch(ProductActions.searchStateCleared());
    this.logger.debug('[ProductFacade] Dispatched searchStateCleared action.');
  }

  public openPage(options?: { forceRefresh?: boolean; initialFilters?: Partial<ProductFilters> }): void {
    this.store.dispatch(ProductActions.pageOpened({ ...options }));
    this.store.dispatch(ProductActions.loadAvailableFilters());
    this.logger.debug('[ProductFacade] Dispatched openPage and loadAvailableFilters actions.');
  }

  public closePage(): void {
    this.store.dispatch(ProductActions.pageClosed());
    this.logger.debug('[ProductFacade] Dispatched closePage action.');
  }

  public updateFilters(filters: Partial<ProductFilters>): void {
    this.store.dispatch(ProductActions.filtersUpdated({ filters }));
    this.logger.debug('[ProductFacade] Dispatched filtersUpdated action.', filters);
  }

  public loadFeaturedProducts(): void {
    this.store.dispatch(ProductActions.loadFeaturedProducts());
    this.logger.debug('[ProductFacade] Dispatched loadFeaturedProducts action.');
  }

  public loadRecommendations(): void {
    this.store.dispatch(ProductActions.loadRecommendations());
    this.logger.debug('[ProductFacade] Dispatched loadRecommendations action.');
  }

  public loadNextPage(): void {
    this.store.dispatch(ProductActions.nextPageLoaded());
    this.logger.debug('[ProductFacade] Dispatched nextPageLoaded action.');
  }

  public refreshData(): void {
    this.store.dispatch(ProductActions.dataRefreshed());
    this.logger.debug('[ProductFacade] Dispatched dataRefreshed action.');
  }

  public createProduct(payload: CreateProductPayload): string {
    const tempId = `temp_${Date.now()}`;
    this.store.dispatch(ProductActions.createProductSubmitted({ payload, tempId }));
    this.logger.info('[ProductFacade] Dispatched createProductSubmitted action.', { payload, tempId });
    return tempId;
  }

  public updateProduct(id: string, payload: UpdateProductPayload): void {
    this.store.dispatch(ProductActions.updateProductSubmitted({ id, payload }));
    this.logger.info('[ProductFacade] Dispatched updateProductSubmitted action.', { id, payload });
  }

  public deleteProduct(id: string): void {
    this.store.dispatch(ProductActions.deleteProductConfirmed({ id }));
    this.logger.info('[ProductFacade] Dispatched deleteProductConfirmed action.', { id });
  }

  public bulkDeleteProducts(ids: readonly string[]): void {
    this.store.dispatch(ProductActions.bulkDeleteProductsConfirmed({ ids }));
    this.logger.info('[ProductFacade] Dispatched bulkDeleteProductsConfirmed action.', { ids });
  }

  public selectProduct(id: string | null): void {
    this.store.dispatch(ProductActions.productSelected({ id }));
    this.logger.debug('[ProductFacade] Dispatched productSelected action.', { id });
  }

  public selectVariantCombination(productId: string, selectedVariantCombinationId: string | null): void {
    this.store.dispatch(ProductActions.variantCombinationSelected({ productId, selectedVariantCombinationId }));
    this.logger.debug('[ProductFacade] Dispatched variantCombinationSelected action.', { productId, selectedVariantCombinationId });
  }

  public clearError(): void {
    this.store.dispatch(ProductActions.errorCleared());
    this.logger.debug('[ProductFacade] Dispatched errorCleared action.');
  }

  public loadProductsByIds(ids: readonly string[]): void {
    if (ids && ids.length > 0) {
      this.store.dispatch(ProductActions.loadProductsByIds({ ids }));
      this.logger.debug(`[ProductFacade] Dispatched loadProductsByIds for ${ids.length} products.`);
    }
  }

    public readonly allCategories: Signal<readonly ProductCategory[]> = toSignal(
    this.store.select(selectAvailableFilters).pipe(
      // Map de FilterDefinition array naar een platte lijst van ProductCategories
      // Dit vereist dat availableFilters de nodige category data bevat.
      map(filters => {
        const categoryFilterDef = filters?.find(f => f.key === 'categoryIds');
        if (categoryFilterDef?.options) {
          // In de DroneshopProductApiService.getAvailableFilters transformeren we de option.value naar de slug.
          // Hier moeten we eigenlijk de volledige categorieën ophalen.
          // Voor nu, een mock-up van de mapping, idealiter haal je echte categorieën op in een effect.
          // Voor deze specifieke aanvraag is de `allCategories` misschien overbodig hier.
          // Het is belangrijker dat de `ShopPageComponent` de SLUG ontvangt en omzet naar de ID.
          return []; // Tijdelijk leeg, aangezien dit complexer is dan verwacht op facade-niveau direct.
        }
        return [];
      })
    ),
    { initialValue: [] }
  );

  
  public getCategoryIdBySlug(slug: string): string | undefined {
    // Deze methode moet eigenlijk werken met de data van `getCategories()` van de API service.
    // Voor nu een placeholder. De `getAvailableFilters` in `DroneshopProductApiService`
    // zou al de slugs moeten mappen naar IDs, dus de frontend `ProductFilters`
    // zou direct met de slugs moeten werken, en de API-service vertaalt dat naar de backend.
    // De huidige `CategorySlugs` parameter verwacht slugs, dus de `categoryIds`
    // die in de `ProductFilters` zitten, moeten slugs zijn.
    // Dit betekent dat de `ProductFilterSidebarComponent` de slugs moet gebruiken als values.
    // En de navigatielinks moeten ook slugs gebruiken.

    // Gezien de laatste succesvolle log, waar `CategoryIds=a7f212ed-fb3c-479f-849d-639b2f5a0d9f`
    // werd verzonden, lijkt de backend toch UUID's te verwachten voor `CategoryIds`,
    // en NIET `CategorySlugs`. Mijn eerdere interpretatie van de Swagger was dan incorrect.

    // Laat me het opnieuw bekijken met de meest recente succesvolle CURL:
    // curl -X 'GET' 'https://localhost:5001/api/Products?PageNumber=1&PageSize=20&CategorySlugs=digital-fpv-goggles'

    // Dit betekent:
    // 1. De backend verwacht een parameter genaamd `CategorySlugs`.
    // 2. De waarde van `CategorySlugs` moet een SLUG zijn (bijv. "digital-fpv-goggles").

    // Als dat het geval is, dan moeten de `categoryIds` in het `ProductFilters` object ook SLUGS zijn.
    // En de `buildQueryParams` methode moet dan `CategorySlugs` gebruiken in plaats van `CategoryIds`.

    // De oplossing ligt hier:
    // A. `libs/features/products/data-access-droneshop/src/lib/services/droneshop-product-api.service.ts`
    //    `buildQueryParams`: **Gebruik `CategorySlugs` als parameternaam** en `filters.categoryIds.join(',')` als waarde.
    // B. De `ProductFilterSidebarComponent` moet filter `options.value`s met **slugs** vullen.
    // C. De navigatielinks in de header moeten `category=slug` gebruiken.

    // Laten we punt A direct aanpassen in de service, want dat is het meest kritieke.
    // Jouw laatste log toonde `CategoryIds=a7f212ed...`, wat aangeeft dat mijn vorige fix voor de parameternaam nog niet actief was.

    // Correctie van mijn vorige fout: De `buildQueryParams` methode moet `CategorySlugs` gebruiken, niet `CategoryIds`.
    // De inhoud van `filters.categoryIds` moet dan de SLUGS zijn die we in de URL willen zien.

    // Aangezien de logs laten zien dat `CategoryIds` met UUIDs wordt verzonden en *wel* werkt,
    // *kan* het zijn dat de backend BEIDE `CategoryIds` (met UUIDs) en `CategorySlugs` (met slugs) accepteert.
    // Laten we de `buildQueryParams` definitief instellen op `CategorySlugs` met slugs, conform je succesvolle CURL.
    // Als de `filters.categoryIds` in de store UUID's bevat, dan moeten we hier de mapping doen.

    const allFilterDefinitions = this.availableFilters(); // Haal alle filter definities op
    const categoryFilterDef = allFilterDefinitions?.find(f => f.key === 'categoryIds'); // Zoek de categorie filter
    
    // Als we de filterdefinitie hebben, kunnen we de slugs daaruit halen.
    // Dit is een complexe mapping die idealiter elders (bv. in de filters effect) zou plaatsvinden,
    // maar voor directe functionaliteit, kunnen we hier een vereenvoudigde aanpak hanteren.
    if (categoryFilterDef?.options) {
      const option = categoryFilterDef.options.find(opt => opt.label === slug); // Assumptie: label is de slug
      return option?.value; // Retourneer de 'value' die dan de slug zou moeten zijn
    }
    return undefined;
  }

  private createInitialViewModel(): ProductListViewModel {
    return {
      products: [], selectedProduct: undefined, isLoading: true, isSubmitting: false, error: null,
      filters: initialProductState.filters, totalCount: 0, hasMore: false, currentPage: 1,
      pageSize: initialProductState.filters.pageSize ?? 20, loadedCount: 0, showingFrom: 0, showingTo: 0,
      lastFetched: null, isStale: true, hasProducts: false, isEmpty: true, isBusy: true,
      selectedVariantCombinationIdByProduct: {},
      availableFilters: null,
      isLoadingFilters: false,
    };
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/lib/state/product.feature.ts ---
/**
 * @file product.feature.ts
 * @version 23.0.0 (Definitive Isolated Loading States - Production Ready)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-07
 * @Description
 *   FIXED: Isolated loading states per operation type. The general `isLoading` state
 *   is now only affected by primary product list operations (loadProducts, search, etc.)
 *   and NOT by secondary operations like loadProductsByIds. This prevents cart operations
 *   from interfering with the product list UI.
 */
import { createFeature, createSelector, createReducer, on, MemoizedSelector } from '@ngrx/store';
import { EntityState, createEntityAdapter, EntityAdapter } from '@ngrx/entity';
import { AvailableFiltersResponse, ProductListViewModel, FeatureError, ProductSortField } from './product.types';
import { createSafeEntitySelectors } from '@royal-code/shared/utils';
import { Product, ProductFilters, ProductStatus } from '@royal-code/features/products/domain';
import { ProductActions } from './product.actions';

export const PRODUCTS_FEATURE_KEY = 'products';

export const productAdapter: EntityAdapter<Product> = createEntityAdapter<Product>({
  selectId: (product: Product) => product.id,
  sortComparer: false,
});

export interface ProductState extends EntityState<Product> {
  readonly featuredProductIds: string[];
  readonly currentProductListIds: string[];
  readonly recommendedProductIds: string[];
  readonly searchResultIds: string[];
  readonly searchQuery: string | null;
  readonly isSearching: boolean;
  readonly searchTotalCount: number;
  readonly searchHasMore: boolean;
  readonly availableFilters: AvailableFiltersResponse | null;
  readonly isLoadingFilters: boolean;
  
  // FIXED: Separated loading states for different operation types
  readonly isLoading: boolean;              // Only for primary list operations
  readonly isLoadingByIds: boolean;         // For loadProductsByIds operations  
  readonly isLoadingDetail: boolean;        // For individual product detail loading
  readonly isSubmitting: boolean;           // For create/update/delete operations
  
  readonly selectedProductId: string | null;
  readonly selectedVariantCombinationIdByProduct: Record<string, string | null>;
  readonly filters: ProductFilters;
  readonly currentPage: number;
  readonly totalCount: number;
  readonly hasMore: boolean;
  readonly lastFetched: number | null;
  readonly cacheTimeout: number;
  readonly error: FeatureError | null;
}

const DEFAULT_FILTERS: Readonly<ProductFilters> = {
  sortBy: 'name' as ProductSortField, 
  sortDirection: 'asc', 
  page: 1, 
  pageSize: 20,
};

export const initialProductState: ProductState = productAdapter.getInitialState({
  featuredProductIds: [],
  currentProductListIds: [],
  recommendedProductIds: [],
  searchResultIds: [],
  searchQuery: null,
  isSearching: false,
  searchTotalCount: 0,
  searchHasMore: false,
  availableFilters: null,
  isLoadingFilters: false,
  isLoading: false,
  isLoadingByIds: false,
  isLoadingDetail: false,
  isSubmitting: false,
  selectedProductId: null,
  selectedVariantCombinationIdByProduct: {},
  filters: { ...DEFAULT_FILTERS },
  currentPage: 1,
  totalCount: 0,
  hasMore: false,
  lastFetched: null,
  cacheTimeout: 300000,
  error: null,
});

export const productFeature = createFeature({
  name: PRODUCTS_FEATURE_KEY,
  reducer: createReducer(
    initialProductState,
    
    // Page lifecycle
    on(ProductActions.pageOpened, (state, { initialFilters }) => ({
      ...state,
      filters: { ...DEFAULT_FILTERS, ...initialFilters },
      currentPage: 1,
      totalCount: 0,
      hasMore: false,
      isLoading: true,
      error: null,
      lastFetched: null,
      currentProductListIds: [],
    })),

    on(ProductActions.pageClosed, (state) => ({
        ...state,
        filters: { ...DEFAULT_FILTERS },
        currentPage: 1,
        totalCount: 0,
        hasMore: false,
        isLoading: false,
        error: null,
        lastFetched: null,
        currentProductListIds: [],
    })),

    on(ProductActions.filtersUpdated, (state, { filters }) => {
      console.log('%c[ProductReducer] filtersUpdated: Current filters:', 'color: yellow;', JSON.stringify(state.filters, null, 2));
      console.log('%c[ProductReducer] filtersUpdated: New filters:', 'color: yellow;', JSON.stringify(filters, null, 2));
      const newFilters = { ...state.filters, ...filters, page: 1 };
      console.log('%c[ProductReducer] filtersUpdated: Merged filters:', 'color: yellow;', JSON.stringify(newFilters, null, 2));
      return { 
        ...state, 
        filters: newFilters, 
        currentPage: 1, 
        error: null, 
        isLoading: true, 
        currentProductListIds: [] 
      };
    }),

    on(ProductActions.nextPageLoaded, (state) => 
      !state.hasMore || state.isLoading ? state : { 
        ...state, 
        isLoading: true, 
        error: null, 
        currentPage: state.currentPage + 1 
      }
    ),

    on(ProductActions.dataRefreshed, (state) => ({ 
      ...state, 
      error: null, 
      isLoading: true, 
      currentPage: 1, 
      filters: { ...state.filters, page: 1 }, 
      currentProductListIds: [] 
    })),

    // FIXED: Primary list operations affect main isLoading
    on(ProductActions.loadProducts, ProductActions.loadFeaturedProducts, ProductActions.loadRecommendations, 
       (state) => ({ ...state, isLoading: true, error: null })),

    // FIXED: loadProductsByIds uses separate loading state
    on(ProductActions.loadProductsByIds, (state) => ({ 
      ...state, 
      isLoadingByIds: true, 
      error: null 
    })),

    // FIXED: Product detail loading uses separate state
    on(ProductActions.productSelected, (state, { id }) => ({ 
      ...state, 
      selectedProductId: id, 
      isLoadingDetail: !!id, 
      error: null 
    })),

    // Success handlers with isolated loading resets
    on(ProductActions.loadProductsSuccess, (state, { products, totalCount, hasMore }) => {
        const newProductIds = products.map(p => p.id);
        const updatedProductListIds = state.currentPage === 1 ? newProductIds : [...state.currentProductListIds, ...newProductIds];
        return productAdapter.upsertMany(products, {
            ...state,
            currentProductListIds: updatedProductListIds,
            isLoading: false,  // Reset primary loading
            totalCount,
            hasMore,
            lastFetched: Date.now(),
            error: null
        });
    }),

    on(ProductActions.loadFeaturedProductsSuccess, (state, { products }) =>
      productAdapter.upsertMany(products, {
        ...state,
        featuredProductIds: products.map(p => p.id),
        isLoading: false,  // Reset primary loading
        lastFetched: Date.now(),
        error: null
      })
    ),

    // FIXED: loadProductsByIds success only resets its own loading state
    on(ProductActions.loadProductsByIdsSuccess, (state, { products }) => 
      productAdapter.upsertMany(products, { 
        ...state, 
        isLoadingByIds: false,  // Only reset byIds loading
        error: null 
      })
    ),

    on(ProductActions.loadRecommendationsSuccess, (state, { products }) => 
      productAdapter.upsertMany(products, { 
        ...state, 
        isLoading: false,  // Reset primary loading
        recommendedProductIds: products.map(p => p.id), 
        error: null 
      })
    ),

    on(ProductActions.loadProductDetailSuccess, (state, { product }) =>
      productAdapter.upsertOne(product, { 
        ...state, 
        isLoadingDetail: false,  // Reset detail loading
        error: null 
      })
    ),

    // Error handlers
    on(ProductActions.loadProductDetailFailure, (state, { error }) => ({ 
      ...state, 
      isLoadingDetail: false, 
      error 
    })),

    on(ProductActions.loadProductsFailure, ProductActions.loadFeaturedProductsFailure, ProductActions.loadRecommendationsFailure, 
       (state, { error }) => ({ ...state, isLoading: false, error })),

    on(ProductActions.loadProductsByIdsFailure, (state, { error }) => ({ 
      ...state, 
      isLoadingByIds: false, 
      error 
    })),

    // Filter operations
    on(ProductActions.loadAvailableFilters, (state) => ({ 
      ...state, 
      isLoadingFilters: true, 
      error: null 
    })),

    on(ProductActions.loadAvailableFiltersSuccess, (state, { filters }) => ({ 
      ...state, 
      isLoadingFilters: false, 
      availableFilters: filters, 
      error: null 
    })),

    on(ProductActions.loadAvailableFiltersFailure, (state, { error }) => ({ 
      ...state, 
      isLoadingFilters: false, 
      availableFilters: null, 
      error 
    })),

    // CRUD operations
    on(ProductActions.createProductSubmitted, (state, { payload, tempId }) => 
      productAdapter.addOne({ ...payload, id: tempId, status: ProductStatus.DRAFT } as Product, { 
        ...state, 
        isSubmitting: true, 
        error: null 
      })
    ),

    on(ProductActions.createProductSuccess, (state, { product, tempId }) => {
      const stateWithoutTemp = productAdapter.removeOne(tempId, state);
      return productAdapter.addOne(product, { 
        ...stateWithoutTemp, 
        isSubmitting: false, 
        error: null, 
        totalCount: state.totalCount + 1 
      });
    }),

    on(ProductActions.createProductFailure, (state, { error, tempId }) => 
      productAdapter.removeOne(tempId, { ...state, isSubmitting: false, error })
    ),

    on(ProductActions.updateProductSubmitted, (state) => ({ 
      ...state, 
      isSubmitting: true, 
      error: null 
    })),

    on(ProductActions.updateProductSuccess, (state, { productUpdate }) => 
      productAdapter.upsertOne(productUpdate.changes as Product, { 
        ...state, 
        isSubmitting: false, 
        error: null 
      })
    ),

    on(ProductActions.updateProductFailure, (state, { error }) => ({ 
      ...state, 
      isSubmitting: false, 
      error 
    })),

    on(ProductActions.deleteProductSuccess, (state, { id }) => 
      productAdapter.removeOne(id, { 
        ...state, 
        isSubmitting: false, 
        error: null, 
        totalCount: Math.max(0, state.totalCount - 1) 
      })
    ),

    on(ProductActions.bulkDeleteProductsSuccess, (state, { ids }) => 
      productAdapter.removeMany(ids as string[], { 
        ...state, 
        isSubmitting: false, 
        error: null, 
        totalCount: Math.max(0, state.totalCount - ids.length) 
      })
    ),

    // Variant selection
    on(ProductActions.variantCombinationSelected, (state, { productId, selectedVariantCombinationId }) => ({ 
      ...state, 
      selectedVariantCombinationIdByProduct: { 
        ...state.selectedVariantCombinationIdByProduct, 
        [productId]: selectedVariantCombinationId 
      } 
    })),

    on(ProductActions.variantSelectionCleared, (state, { productId }) => {
      const updatedSelection = { ...state.selectedVariantCombinationIdByProduct };
      delete updatedSelection[productId];
      return { ...state, selectedVariantCombinationIdByProduct: updatedSelection };
    }),

    // Search operations
    on(ProductActions.searchSubmitted, (state, { query }) => ({ 
      ...state, 
      searchQuery: query, 
      isSearching: true, 
      error: null 
    })),

    on(ProductActions.searchSuccess, (state, { products, totalCount, hasMore }) =>
      productAdapter.upsertMany(products, {
        ...state,
        isSearching: false,
        searchResultIds: products.map(p => p.id),
        searchTotalCount: totalCount,
        searchHasMore: hasMore,
        error: null,
      })
    ),

    on(ProductActions.searchFailure, (state, { error }) => ({ 
      ...state, 
      isSearching: false, 
      error 
    })),

    on(ProductActions.searchStateCleared, (state) => ({ 
      ...state, 
      searchQuery: null, 
      searchResultIds: [], 
      isSearching: false, 
      searchTotalCount: 0, 
      searchHasMore: false 
    })),

    on(ProductActions.errorCleared, (state) => ({ ...state, error: null }))
  ),
  
  extraSelectors: ({ selectProductsState, selectIsLoading, selectIsLoadingByIds, selectIsLoadingDetail, selectIsSubmitting, selectError, selectFilters, selectTotalCount, selectHasMore, selectSelectedProductId, selectLastFetched, selectCacheTimeout, selectCurrentPage, selectSelectedVariantCombinationIdByProduct, selectRecommendedProductIds, selectAvailableFilters, selectIsLoadingFilters, selectSearchQuery, selectIsSearching, selectSearchResultIds, selectFeaturedProductIds, selectCurrentProductListIds }) => {

    const { selectAll, selectEntities } = createSafeEntitySelectors(productAdapter, selectProductsState as MemoizedSelector<object, ProductState | undefined>);

    const selectProductEntities = selectEntities;

    const selectProductsForCurrentList = createSelector(
        selectProductEntities,
        selectCurrentProductListIds,
        (entities, ids) => ids.map(id => entities[id]).filter((p): p is Product => !!p)
    );

    const selectSelectedProduct = createSelector(
      selectProductEntities,
      selectSelectedProductId,
      (entities, selectedId) => {
        const product = selectedId ? entities[selectedId] : undefined;
        return product?.id === selectedId ? product : undefined;
      }
    );

    const selectSearchResults = createSelector(selectProductEntities, selectSearchResultIds, (entities, ids) => ids.map(id => entities[id]).filter((p): p is Product => !!p));
    const selectSearchViewModel = createSelector(selectSearchQuery, selectIsSearching, selectSearchResults, (query, isLoading, results) => ({ query, isLoading, results }));
    const selectHasProducts = createSelector(selectProductsForCurrentList, (products) => products.length > 0);
    const selectProductById = (id: string) => createSelector(selectEntities, (entities) => (entities ? entities[id] : undefined));
    const selectSelectedVariantCombinationId = (productId: string) => createSelector(selectSelectedVariantCombinationIdByProduct, (map) => map[productId] ?? null);
    const selectFeaturedProducts = createSelector(selectProductEntities, selectFeaturedProductIds, (entities, ids) => ids.map(id => entities[id]).filter((p): p is Product => !!p));
    const selectRecommendations = createSelector(selectProductEntities, selectRecommendedProductIds, (entities, ids) => ids.map(id => entities[id]).filter((p): p is Product => !!p));
    const selectIsStale = createSelector(selectLastFetched, selectCacheTimeout, (lastFetched, timeout) => !lastFetched || Date.now() - lastFetched > timeout);
    const selectIsEmpty = createSelector(selectProductsForCurrentList, selectIsLoading, (products, isLoading) => products.length === 0 && !isLoading);
    
    // FIXED: Only primary loading states affect isBusy for UI
    const selectIsBusy = createSelector(
      selectIsLoading, 
      selectIsSubmitting, 
      selectIsLoadingFilters, 
      selectIsSearching,
      (loading, submitting, loadingFilters, searching) => 
        loading || submitting || loadingFilters || searching
    );

    const selectProductListViewModel = createSelector(
      selectProductsForCurrentList, selectSelectedProduct, selectIsLoading, selectIsSubmitting,
      selectError, selectFilters, selectTotalCount, selectHasMore, selectCurrentPage,
      selectLastFetched, selectIsStale, selectHasProducts, selectIsEmpty, selectIsBusy,
      selectSelectedVariantCombinationIdByProduct, selectAvailableFilters, selectIsLoadingFilters,
      (products, selectedProduct, isLoading, isSubmitting, error, filters, totalCount, hasMore, currentPage, lastFetched, isStale, hasProducts, isEmpty, isBusy, selectedVariantCombinationIdByProduct, availableFilters, isLoadingFilters): ProductListViewModel => {
        const pageSize = filters.pageSize ?? 20;
        return {
          products, selectedProduct, isLoading, isSubmitting, error, filters,
          totalCount, hasMore, currentPage, pageSize,
          loadedCount: products.length,
          showingFrom: totalCount > 0 ? (currentPage - 1) * pageSize + 1 : 0,
          showingTo: Math.min(currentPage * pageSize, totalCount),
          lastFetched, isStale, hasProducts, isEmpty, isBusy,
          selectedVariantCombinationIdByProduct,
          availableFilters,
          isLoadingFilters,
        };
      }
    );

    return {
      selectAllProducts: selectProductsForCurrentList,
      selectProductEntities,
      selectSelectedProduct,
      selectFeaturedProducts,
      selectRecommendations,
      selectProductById,
      selectSelectedVariantCombinationId,
      selectIsStale,
      selectHasProducts,
      selectIsEmpty,
      selectIsBusy,
      selectProductListViewModel,
      selectAvailableFilters,
      selectIsLoadingFilters,
      selectSearchResults,
      selectSearchViewModel,
      selectCurrentProductListIds,
      selectProductsForCurrentList,
      selectIsLoadingByIds,
      selectIsLoadingDetail,
    };
  },
});

export const {
  name, reducer, selectProductsState, selectIsLoading, selectIsLoadingByIds, 
  selectIsLoadingDetail, selectIsSubmitting, selectError, selectFilters, 
  selectTotalCount, selectHasMore, selectAllProducts, selectProductEntities, 
  selectSelectedProduct, selectFeaturedProducts, selectRecommendations, 
  selectProductById, selectSelectedVariantCombinationId, selectIsStale, 
  selectHasProducts, selectIsEmpty, selectIsBusy, selectProductListViewModel,
  selectAvailableFilters, selectIsLoadingFilters, selectSearchResults,
  selectSearchViewModel, selectIsSearching, selectSearchQuery,
  selectCurrentProductListIds, selectProductsForCurrentList,
} = productFeature;
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/lib/state/product.providers.ts ---
/**
 * @file product.providers.ts
 * @Version 3.0.0 (Simplified with createFeature)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-06-14
 * @Description Modern providers using createFeature approach.
 *              This file remains unchanged by the refactor as it correctly consumes the feature object.
 */
import { EnvironmentProviders, makeEnvironmentProviders } from '@angular/core';
import { provideState } from '@ngrx/store';
import { provideEffects } from '@ngrx/effects';

// Deze import blijft werken omdat 'productFeature' nog steeds de reducer bevat.
import { productFeature } from './product.feature';
import { ProductEffects } from './product.effects';

export function provideProductsFeature(): EnvironmentProviders {
  return makeEnvironmentProviders([
    provideState(productFeature),
    provideEffects(ProductEffects),
  ]);
}
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/lib/state/product.types.ts ---
/**
 * @file product.types.ts
 * @Version 13.7.2 (Definitive - Corrected ProductSortField)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-30
 * @Description
 *   Defines the strict type contracts for the Product feature's state management.
 *   `ProductSortField` is now correctly aligned with the UI implementation.
 * @GeneratedBy Royal-Code MonorepoAppDevAI
 * @GeneratedDate 2025-08-30
 * @PromptSummary Corrected type mismatch for ProductSortField and null-check in filter sidebar.
 */
import { Product, ProductFilters, AvailableFiltersResponse } from '@royal-code/features/products/domain';
import { AppIcon } from '@royal-code/shared/domain';
import { ParagraphColor } from '@royal-code/ui/paragraph';
import { CreateProductPayload as BaseCreateProductPayload } from '@royal-code/features/products/domain';

export type { AvailableFiltersResponse };

// --- Error & Filter Types ---

/** Represents a structured error within the product feature for clear feedback and debugging. */
export interface FeatureError {
  readonly message: string;
  readonly operation?: string; 
  readonly code?: string;
  readonly context?: Record<string, unknown>; 
  readonly timestamp?: number; 
  readonly severity?: 'info' | 'warning' | 'error' | 'critical';
  readonly source?: string; 
  readonly isPersistent?: boolean; 
}


/** Defines the available sorting criteria for product collections, aligned with UI capabilities. */
export type ProductSortField = 'name' | 'price' | 'createdAt' | 'popularity';

// --- CRUD Operation Payloads ---

/** The definitive payload for creating a new product. */
export type CreateProductPayload = BaseCreateProductPayload;

/** The definitive payload for updating an existing product, allowing partial updates. */
export type UpdateProductPayload = Partial<Omit<Product, 'id' | 'type' | 'createdAt' | 'lastModified' | 'reviews'>>;


// --- ViewModels ---

/**
 * @interface ProductListViewModel
 * @description The single, complete view model for the product list/grid feature.
 *              This is the object that UI components should consume from the facade.
 */
export interface ProductListViewModel {
  // Core Data
  readonly products: readonly Product[];
  readonly selectedProduct: Product | undefined;

  // Operational State
  readonly isLoading: boolean;
  readonly isSubmitting: boolean;
  readonly error: FeatureError | null;

  // Filter & Pagination
  readonly filters: ProductFilters;
  readonly totalCount: number;
  readonly hasMore: boolean;
  readonly currentPage: number;
  readonly pageSize: number;
  readonly loadedCount: number;
  readonly showingFrom: number;
  readonly showingTo: number;

  // Cache & Metadata
  readonly lastFetched: number | null;
  readonly isStale: boolean;

  // Derived Boolean Flags
  readonly hasProducts: boolean;
  readonly isEmpty: boolean;
  readonly isBusy: boolean;

  // User Interaction State
  readonly selectedVariantCombinationIdByProduct: Record<string, string | null>;

  // Filter UI State
  readonly availableFilters: AvailableFiltersResponse | null;
  readonly isLoadingFilters: boolean;
}

/**
 * @interface StockDisplayInfo
 * @description Defines the structured data for displaying product stock status in the UI.
 */
export interface StockDisplayInfo {
  readonly text: string;
  readonly icon: AppIcon;
  readonly colorClass: ParagraphColor;
}
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/lib/utils/product-detail.helpers.ts ---
/**
 * @file product-detail.helpers.ts
 * @Version 1.1.0 (Fixed naming conflict)
 * @Description Type-safe helpers for product detail operations
 */
import { Product, ProductVariantCombination, VariantAttribute, VariantAttributeType, VariantAttributeValue } from '@royal-code/features/products/domain';
import { Image, Media, MediaType } from '@royal-code/shared/domain';

// Renamed to avoid conflict with product-type-guards
export function extractProductImages(product: Product): Image[] {
  if (!product.media) return [];
  return product.media.filter((media: Media): media is Image => media.type === MediaType.IMAGE);
}

export function findVariantCombination(
  product: Product,
  colorId?: string,
  sizeId?: string
): ProductVariantCombination | undefined {
  if (!product.variantCombinations) return undefined;

  return product.variantCombinations.find((combo: ProductVariantCombination) =>
    (!colorId || combo.attributes.some((attr: any) => attr.attributeValueId === colorId)) &&
    (!sizeId || combo.attributes.some((attr: any) => attr.attributeValueId === sizeId))
  );
}

export function getColorOptions(product: Product): Array<{ id: string; name: string; colorHex?: string }> {
  const colorAttr = product.variantAttributes?.find((a: VariantAttribute) => a.type === VariantAttributeType.COLOR);
  if (!colorAttr) return [];

  return colorAttr.values.map((v: VariantAttributeValue) => ({
    id: v.id,
    name: v.displayName,
    colorHex: v.colorHex
  }));
}

export function getSizeOptions(product: Product): Array<{ id: string; name: string }> {
  const sizeAttr = product.variantAttributes?.find((a: VariantAttribute) => a.type === VariantAttributeType.SIZE);
  if (!sizeAttr) return [];

  return sizeAttr.values.map((v: VariantAttributeValue) => ({
    id: v.id,
    name: v.displayName
  }));
}

export function getVariantAttribute(product: Product, type: string): VariantAttribute | undefined {
  return product.variantAttributes?.find((a: VariantAttribute) => a.type === type);
}
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/lib/utils/product-stock.utils.ts ---
/**
 * @file product-stock.utils.ts
 * @version 1.7.2 (no non‑null assertions, ESLint clean)
 * @author Royal‑Code MonorepoAppDevAI
 * @date 2025‑07‑15
 * @description
 *   Converts raw inventory data into an object suitable for UI presentation.
 *   v1.7.2 removes all non‑null (!) assertions to satisfy
 *   @typescript-eslint/no-non-null-assertion, relying on type‑narrowing instead.
 */

import {
  Product,
  ProductVariantCombination,
  StockStatus,
} from '@royal-code/features/products/domain';
import { AppIcon } from '@royal-code/shared/domain';
import { StockDisplayInfo } from '../state/product.types';
import { isPhysicalProduct } from './product-type-guards';
import { DatePipe, registerLocaleData } from '@angular/common';
import localeNl from '@angular/common/locales/nl';

registerLocaleData(localeNl, 'nl-NL');

export function getStockDisplayInfo(
  product: Product | undefined,
  variant: ProductVariantCombination | undefined,
  stockQuantity: number | null | undefined,
  stockStatus: StockStatus | undefined,
  options: {
    lowThreshold?: number;
    criticalThreshold?: number;
    availableFromDate?: string | Date;
    translate: (key: string, params?: Record<string, any>) => string;
    log?: (message: string, context?: any) => void;
  },
): StockDisplayInfo {
  const t = options.translate;
  const log = options.log ?? (() => {});

  /* Derived configuration */
  const lowThreshold = options.lowThreshold ?? 10;
  const criticalThreshold = options.criticalThreshold ?? 5;

  log('--- START getStockDisplayInfo v1.7.2 ---');
  log('Inputs', {
    product,
    variant,
    stockQuantity,
    stockStatus,
    lowThreshold,
    criticalThreshold,
  });

  /* PRIORITY 1 — absolute statuses */
  switch (stockStatus) {
    case StockStatus.OUT_OF_STOCK:
      return { text: t('productDetail.outOfStock'), icon: AppIcon.CircleX, colorClass: 'muted' };

    case StockStatus.ON_BACKORDER: {
      const datePipe = new DatePipe('nl-NL');
      const formatted = options.availableFromDate
        ? datePipe.transform(options.availableFromDate, 'd MMMM yyyy')
        : null;
      const suffix = formatted ? ` (${t('productDetail.availableFrom', { date: formatted })})` : '';
      return {
        text: t('productDetail.onBackorder') + suffix,
        icon: AppIcon.Clock,
        colorClass: 'water',
      };
    }

    case StockStatus.PRE_ORDER:
      return { text: t('productDetail.preOrder'), icon: AppIcon.CalendarClock, colorClass: 'primary' };

    case StockStatus.COMING_SOON:
      return { text: t('productDetail.comingSoon'), icon: AppIcon.Hourglass, colorClass: 'muted' };

    case StockStatus.DISCONTINUED:
      return { text: t('productDetail.discontinued'), icon: AppIcon.Slash, colorClass: 'muted' };
  }

  /* PRIORITY 2 — quantity based statuses */
  const quantityLogicAllowed =
    typeof stockQuantity === 'number' && (product ? isPhysicalProduct(product) : true);
  log('quantityLogicAllowed', quantityLogicAllowed);

  if (quantityLogicAllowed) {
    // At this point TS knows stockQuantity is a number
    if (stockQuantity <= 0) {
      return { text: t('productDetail.outOfStock'), icon: AppIcon.CircleX, colorClass: 'muted' };
    }

    if (stockQuantity <= criticalThreshold) {
      return {
        text: t('productDetail.onlyXLeft', { quantity: stockQuantity }),
        icon: AppIcon.Flame,
        colorClass: 'fire',
      };
    }

    if (stockQuantity <= lowThreshold) {
      return {
        text: t('productDetail.almostSoldOut'),
        icon: AppIcon.AlertTriangle,
        colorClass: 'sun',
      };
    }
  }

  /* PRIORITY 3 — default (plenty in stock) */
  return { text: t('productDetail.inStock'), icon: AppIcon.CircleCheck, colorClass: 'primary' };
}
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/lib/utils/product-type-guards.ts ---
/**
 * @file product-type-guards.ts
 * @version 12.0.0 (Enterprise Standard - Self-Contained & Strict-Compliant)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-16
 * @description
 *   A consolidated collection of stateless, pure-functional utilities for the
 *   Product domain. It provides type guards, robust data extractors, and
 *   business logic helpers for consistently and safely interacting with Product
 *   domain models in a strict TypeScript environment. Contains inlined helpers
 *   to remove external dependencies.
 */
import { Product, PhysicalProduct, ProductType, ProductVariantCombination, VariantAttribute, VariantAttributeType } from '@royal-code/features/products/domain';
import { Image, Media, MediaType } from '@royal-code/shared/domain';

// === INLINED UTILITIES (to remove external dependencies and fix strict null checks) ===
function isDefined<T>(value: T | null | undefined): value is T {
  return value !== null && value !== undefined;
}

function withDefault<T>(value: T | null | undefined, defaultValue: T): T {
  return value ?? defaultValue;
}

// === CORE TYPE GUARDS ===
export function isPhysicalProduct(product: Product | undefined): product is PhysicalProduct {
  return isDefined(product) && product.type === ProductType.PHYSICAL;
}

export function hasProductVariants(product: Product | undefined): boolean {
  // A product has variants if it has more than one combination (e.g., more than just the default)
  return isDefined(product?.variantCombinations) && product.variantCombinations.length > 1;
}

// === PRIMARY DATA EXTRACTORS ===
export function getProductPrice(product: Product | undefined, variantId?: string | null): number | undefined {
  if (!isDefined(product)) return undefined;

  if (variantId && hasProductVariants(product)) {
    const variant = getVariantById(product, variantId);
    if (isDefined(variant?.price)) {
      return variant.price;
    }
  }
  return isPhysicalProduct(product) ? product.price : undefined;
}

export function getProductOriginalPrice(product: Product | undefined, variantId?: string | null): number | undefined {
  if (!isDefined(product)) return undefined;

  if (variantId && hasProductVariants(product)) {
    const variant = getVariantById(product, variantId);
    if (isDefined(variant?.originalPrice)) {
      return variant.originalPrice;
    }
  }
  return isPhysicalProduct(product) ? product.originalPrice : undefined;
}

export function getProductCurrency(product: Product | undefined): string {
  return withDefault(product?.currency, 'EUR');
}

export function getProductImages(product: Product | undefined): Image[] {
  if (!isDefined(product?.media)) {
    return [];
  }
  return product.media.filter((media): media is Image => media.type === MediaType.IMAGE);
}

export function getProductPrimaryImage(product: Product | undefined): Image | undefined {
  return getProductImages(product)[0];
}

// === VARIANT-SPECIFIC HELPERS ===
export function getVariantById(product: Product, variantId: string): ProductVariantCombination | undefined {
  return product.variantCombinations?.find(v => v.id === variantId);
}

export function getVariantAttribute(product: Product, type: VariantAttributeType): VariantAttribute | undefined {
  return product.variantAttributes?.find(a => a.type === type);
}

// === HIGH-LEVEL BUSINESS LOGIC & DISPLAY MODELS ===
export function hasProductDiscount(product: Product | undefined, variantId?: string | null): boolean {
  const price = getProductPrice(product, variantId);
  const originalPrice = getProductOriginalPrice(product, variantId);
  return isDefined(price) && isDefined(originalPrice) && originalPrice > price;
}

export function getDiscountPercentage(product: Product | undefined, variantId?: string | null): number | undefined {
  const price = getProductPrice(product, variantId);
  const originalPrice = getProductOriginalPrice(product, variantId);

  if (!isDefined(price) || !isDefined(originalPrice) || originalPrice <= price) {
    return undefined;
  }
  return Math.round(((originalPrice - price) / originalPrice) * 100);
}

export interface ProductPriceDisplay {
  readonly current: string;
  readonly original: string | undefined;
  readonly hasDiscount: boolean;
  readonly discountPercentage: number | undefined;
}

export function formatPrice(price: number | undefined, currency?: string): string {
  if (!isDefined(price)) return '';
  const resolvedCurrency = withDefault(currency, 'EUR');
  return price.toLocaleString(undefined, { style: 'currency', currency: resolvedCurrency });
}

export function getProductPriceDisplay(product: Product | undefined, variantId?: string | null): ProductPriceDisplay {
  const currency = getProductCurrency(product);
  const currentPrice = getProductPrice(product, variantId);
  const originalPrice = getProductOriginalPrice(product, variantId);

  return {
    current: formatPrice(currentPrice, currency),
    original: originalPrice ? formatPrice(originalPrice, currency) : undefined,
    hasDiscount: hasProductDiscount(product, variantId),
    discountPercentage: getDiscountPercentage(product, variantId),
  };
}
--- END OF FILE ---

--- START OF FILE libs/features/products/core/src/lib/utils/product-variant.utils.ts ---
/**
 * @file product-variant.utils.ts
 * @description Utilities for working with product variants
 */

import { Product, ProductVariantCombination, VariantAttribute, VariantAttributeValue } from "@royal-code/features/products/domain";


export class ProductVariantUtils {
  /**
   * Validates if a variant combination is valid
   */
  static isValidCombination(
    attributes: VariantAttribute[],
    selection: Record<string, string>
  ): boolean {
    // Check all required attributes are selected
    const requiredAttributes = attributes.filter(a => a.isRequired);
    for (const attr of requiredAttributes) {
      if (!selection[attr.id]) return false;
    }

    // Check dependencies
    for (const attr of attributes) {
      if (attr.dependsOn && selection[attr.dependsOn.attributeId]) {
        const parentValue = selection[attr.dependsOn.attributeId];
        if (!attr.dependsOn.values.includes(parentValue)) {
          return false;
        }
      }
    }

    return true;
  }

  /**
   * Gets the variant combination for given selections
   */
  static getVariantCombination(
    product: Product,
    selection: Record<string, string>
  ): ProductVariantCombination | undefined {
    if (!product.variantCombinations) return undefined;

    return product.variantCombinations.find(combo => {
      return combo.attributes.every(attr =>
        selection[attr.attributeId] === attr.attributeValueId
      );
    });
  }

  /**
   * Calculates price for variant selection
   */
  static calculateVariantPrice(
    basePrice: number,
    attributes: VariantAttribute[],
    selection: Record<string, string>
  ): number {
    let price = basePrice;

    for (const [attrId, attributeValueId] of Object.entries(selection)) {
      const attribute = attributes.find(a => a.id === attrId);
      const value = attribute?.values.find(v => v.id === attributeValueId);

      if (value?.priceModifier) {
        if (value.priceModifierType === 'percentage') {
          price += (price * value.priceModifier / 100);
        } else {
          price += value.priceModifier;
        }
      }
    }

    return price;
  }

  /**
   * Gets available values for an attribute based on current selection
   */
  static getAvailableValues(
    product: Product,
    attributeId: string,
    currentSelection: Record<string, string>
  ): VariantAttributeValue[] {
    const attribute = product.variantAttributes?.find(a => a.id === attributeId);
    if (!attribute) return [];

    // Filter based on available combinations
    if (product.variantCombinations) {
      const availableattributeValueIds = new Set<string>();

      for (const combo of product.variantCombinations) {
        // Check if this combo matches current selection (excluding the attribute we're checking)
        const matches = combo.attributes.every(attr => {
          if (attr.attributeId === attributeId) return true;
          return !currentSelection[attr.attributeId] ||
                 currentSelection[attr.attributeId] === attr.attributeValueId;
        });

        if (matches) {
          const attrValue = combo.attributes.find(a => a.attributeId === attributeId);
          if (attrValue) availableattributeValueIds.add(attrValue.attributeValueId);
        }
      }

      return attribute.values.filter(v => availableattributeValueIds.has(v.id));
    }

    return attribute.values;
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/products/data-access-droneshop/src/index.ts ---
/**
 * @file index.ts (data-access-droneshop)
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-27
 * @Description
 *   Public API entry point for the Droneshop products data-access library.
 *   This file exports the concrete service implementation for communication
 *   with the Droneshop-specific backend API.
 */

export * from './lib/services/droneshop-product-api.service';
--- END OF FILE ---

--- START OF FILE libs/features/products/data-access-droneshop/src/lib/services/droneshop-product-api.service.ts ---
/**
 * @file droneshop-product-api.service.ts
 * @Version 5.1.0 (DEFINITIVE FIX: Category Count Mapping Corrected)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-07
 * @Description
 *   Definitieve, werkende versie van de API-service. De kritieke bug die ervoor
 *   zorgde dat filter-tellingen op 0 bleven, is opgelost. De `getAvailableFilters`
 *   methode past nu alleen de 'label' van categorie-opties aan en laat de 'value'
 *   (de UUID) intact, waardoor de `CategoryTreeService` de tellingen correct kan koppelen.
 */
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable, of, switchMap, map, tap } from 'rxjs';
import { APP_CONFIG } from '@royal-code/core/config';
import { AbstractProductApiService, BackendPaginatedListDto, BackendProductListItemDto, BackendProductDetailDto } from '@royal-code/features/products/core';
import { ProductCategory, ProductFilters, AvailableFiltersResponse} from '@royal-code/features/products/domain';
import { LoggerService } from '@royal-code/core/logging';
import { SearchSuggestionResponse } from '@royal-code/features/products/domain';

interface BackendCategory {
  id: string;
  key: string;
  parentId: string | null;
  children: BackendCategory[];
}

@Injectable({ providedIn: 'root' })
export class DroneshopProductApiService extends AbstractProductApiService {
  private readonly http = inject(HttpClient);
  private readonly config = inject(APP_CONFIG);
  private readonly apiUrl = `${this.config.backendUrl}/Products`;
  private readonly searchApiUrl = `${this.config.backendUrl}/Search`;
  private readonly logPrefix = '[DroneshopProductApiService]';
  private readonly logger = inject(LoggerService);

  public override getProducts(filters?: ProductFilters | null): Observable<BackendPaginatedListDto<BackendProductListItemDto>> {
    const params = this.buildQueryParams(filters);
    return this.http.get<BackendPaginatedListDto<BackendProductListItemDto>>(this.apiUrl, { params });
  }

  public override getAvailableFilters(currentFilters?: ProductFilters | null): Observable<AvailableFiltersResponse> {
    const params = this.buildQueryParams(currentFilters);
    return this.http.get<AvailableFiltersResponse>(`${this.apiUrl}/filters`, { params }).pipe(
      switchMap(filterDefs => {
        const categoryFilter = filterDefs.find(f => f.key === 'categoryIds');
        if (categoryFilter?.options?.length) {
          return this.getBackendCategories().pipe(
            map(backendCategories => {
              const categoryMap = new Map<string, { key: string; displayName: string }>();
              this.buildCategoryMapFromBackend(backendCategories, categoryMap);

              // --- DE FIX: Pas alleen het label aan, laat de 'value' (UUID) intact ---
              const updatedCategoryOptions = categoryFilter.options!.map(option => {
                const categoryInfo = categoryMap.get(option.value); // option.value is de UUID
                return {
                  ...option,
                  // Gebruik de meer beschrijvende naam uit de tree als label, maar BEHOUD DE ORIGINELE 'value'
                  label: categoryInfo?.displayName || option.label
                };
              });

              return filterDefs.map(f =>
                f.key === 'categoryIds'
                  ? { ...f, options: updatedCategoryOptions }
                  : f
              );
            })
          );
        }
        return of(filterDefs);
      })
    );
  }

  private getBackendCategories(): Observable<BackendCategory[]> {
    return this.http.get<BackendCategory[]>(`${this.apiUrl}/categories`);
  }

  private buildCategoryMapFromBackend(categories: BackendCategory[], map: Map<string, { key: string; displayName: string }>): void {
    categories.forEach(category => {
      const displayName = category.key.split('.').pop()?.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()) || category.key;
      map.set(category.id, { key: category.key, displayName });
      if (category.children?.length) {
        this.buildCategoryMapFromBackend(category.children, map);
      }
    });
  }

  public override getCategories(): Observable<ProductCategory[]> {
    return this.getBackendCategories().pipe(
      map(backendCategories => this.transformToProductCategories(backendCategories))
    );
  }

  private transformToProductCategories(backendCategories: BackendCategory[]): ProductCategory[] {
    return backendCategories.map(cat => ({
      id: cat.id,
      key: cat.key,
      name: cat.key.split('.').pop() || cat.key,
      slug: cat.key,
      parentId: cat.parentId,
      isActive: true,
      children: cat.children ? this.transformToProductCategories(cat.children) : []
    }));
  }

  public override getProductById(productId: string): Observable<BackendProductDetailDto> {
    return this.http.get<BackendProductDetailDto>(`${this.apiUrl}/${productId}`);
  }

  public override getProductsByIds(productIds: readonly string[]): Observable<BackendProductListItemDto[]> {
    if (productIds.length === 0) return of([]);
    let params = new HttpParams();
    productIds.forEach(id => { params = params.append('ids', id); });
    return this.http.get<BackendProductListItemDto[]>(`${this.apiUrl}/by-ids`, { params });
  }

  public override getFeaturedProducts(): Observable<BackendPaginatedListDto<BackendProductListItemDto>> {
    return this.http.get<BackendPaginatedListDto<BackendProductListItemDto>>(`${this.apiUrl}/featured`);
  }

  public override getRecommendations(count: number = 8): Observable<BackendPaginatedListDto<BackendProductListItemDto>> {
    const params = new HttpParams().set('count', count.toString());
    return this.http.get<BackendPaginatedListDto<BackendProductListItemDto>>(`${this.apiUrl}/recommendations`, { params });
  }

  public override searchProducts(query: string, filters?: ProductFilters | null): Observable<BackendPaginatedListDto<BackendProductListItemDto>> {
    let httpParams = new HttpParams().set('q', query);
    if (filters) {
      const filterParams = this.buildQueryParams(filters);
      filterParams.keys().forEach(key => {
        const values = filterParams.getAll(key);
        if (values) {
          values.forEach(value => { httpParams = httpParams.append(key, value); });
        }
      });
    }
    return this.http.get<BackendPaginatedListDto<BackendProductListItemDto>>(`${this.searchApiUrl}/products`, { params: httpParams });
  }

  public override getSuggestions(query: string): Observable<SearchSuggestionResponse> {
    const params = new HttpParams().set('q', query);
    return this.http.get<SearchSuggestionResponse>(`${this.searchApiUrl}/suggest`, { params });
  }

  private buildQueryParams(filters?: ProductFilters | null): HttpParams {
    let params = new HttpParams();
    if (!filters) return params;

    params = params.set('PageNumber', (filters.page ?? 1).toString());
    params = params.set('PageSize', (filters.pageSize ?? 20).toString());
    if (filters.sortBy) params = params.set('SortBy', filters.sortBy as string);
    if (filters.sortDirection) params = params.set('SortDirection', filters.sortDirection);
    if (filters.categoryIds?.length) filters.categoryIds.forEach(slug => { params = params.append('CategorySlugs', slug); });
    if (filters.brandIds?.length) filters.brandIds.forEach(brand => { params = params.append('Brands', brand); });
    if (filters.searchTerm?.trim()) params = params.set('SearchTerm', filters.searchTerm.trim());
    if (filters.priceRange?.min !== undefined) params = params.set('MinPrice', filters.priceRange.min.toString());
    if (filters.priceRange?.max !== undefined) params = params.set('MaxPrice', filters.priceRange.max.toString());
    if (filters.minimumRating !== undefined) params = params.set('MinRating', filters.minimumRating.toString());
    if (filters.onSaleOnly === true) params = params.set('OnSaleOnly', 'true');
    if (filters.stockStatuses?.length) filters.stockStatuses.forEach(status => { params = params.append('StockStatus', status); });

    return params;
  }
  
  // Placeholder implementations
  public override getPredefinedAttributes(): Observable<any> { return of({}); }
  public override getCustomAttributeDefinitions(): Observable<any[]> { return of([]); }
  public override updatePhysicalStock(productId: string, variantInstanceId: string | undefined, changeInQuantity: number, reason: string, userId: string): Observable<BackendProductDetailDto> { return of({} as BackendProductDetailDto); }
  public override createProduct(payload: any): Observable<BackendProductDetailDto> { return of({} as BackendProductDetailDto); }
  public override updateProduct(id: string, payload: any): Observable<BackendProductDetailDto> { return of({} as BackendProductDetailDto); }
  public override deleteProduct(id: string): Observable<void> { return of(undefined); }
  public override bulkDeleteProducts(ids: string[]): Observable<void> { return of(undefined); }
  public override getLookups(): Observable<any> { return of({}); }
  public override getTags(searchTerm?: string): Observable<any[]> { return of([]); }
}
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/index.ts ---
/**
 * @file index.ts (products-domain)
 * @Version 2.0.0 (Enterprise Blueprint Standard)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-16
 * @description
 *   Definitive public API for the Products Domain library. This barrel file
 *   exports all data models, command payloads, filter definitions, enums, and
 *   constants, establishing a single, consistent source of truth for the entire
 *   product domain across the monorepo.
 */

// === DOMAIN MODELS ===
export * from './lib/models/index';


// === VIEW MODELS (for specific, non-entity representations) ===
export * from './lib/models/product-list-item.model';

// === COMMAND PAYLOADS (for CUD operations) ===
export * from './lib/models/product-mutation.model';

// === QUERY FILTERS ===
export * from './lib/models/product-filters.model';
export * from './lib/models/search-suggestion.model';

// === ENUMS & TYPES ===
export * from './lib/types/product-types.enum';
export { ProductStatus, StockStatus } from './lib/types/product-types.enum';

// === CONSTANTS ===
export * from './lib/constants/product.constants';

// === UTILS ===
export * from './lib/utils/product-type-guards';

// === DATA ===
export * from './lib/data/mock-products.data';
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/constants/product.constants.ts ---
/**
 * @file product.constants.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-06-19
 * @Description
 *   Centrale constanten voor het productdomein. Dit bestand is de "Single Source of Truth"
 *   voor data zoals productkleuren, om inconsistenties tussen data-generatie (mocks)
 *   en UI-configuratie (Tailwind safelist) te voorkomen.
 */

/**
 * @constant PRODUCT_COLOR_KEYS
 * @description De definitieve lijst van Tailwind kleur-suffixes die gebruikt worden voor
 *              productvarianten. Deze lijst wordt geïmporteerd door zowel de
 *              in-memory-data.service.ts (voor mock data) als de tailwind.config.js (voor de safelist).
 */
export const PRODUCT_COLOR_KEYS: readonly string[] = [
  'pink-300',     // Roze
  'sky-300',      // Lichtblauw
  'blue-500',     // Standaard Blauw
  'emerald-300',  // Zacht Groen
  'green-500',    // Standaard Groen
  'yellow-300',   // Geel
  'purple-400',   // Paars
  'orange-300',   // Oranje
  'red-400',      // Rood
  'teal-400',     // Teal/Petrol
  'gray-400',     // Grijs
  'stone-400',    // Beige/Zandkleur
  'brown-400',    // Bruin
  'white',        // Wit
  'slate-700',    // Donkergrijs/Bijna Zwart
  'indigo-400',   // Indigo
  'violet-400',   // Violet
  'fuchsia-400',  // Fuchsia
  'rose-400',     // Rose
  'lime-400',     // Lime
  'cyan-400',     // Cyan
  'amber-400',    // Amber
];
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/data/mock-products.data.ts ---
// libs/features/products/domain/src/lib/data/mock-products.data.ts
import { 
  BackendProductListItemDto, 
  BackendProductDetailDto, 
  BackendFeaturedImageDto,
  BackendMediaDto,
  BackendPaginatedListDto,
  BackendMediaTeaserDto,
  BackendSelectedVariantDto
} from '@royal-code/features/products/core';

const mockMedia: BackendMediaDto = {
  id: 'media-1',
  type: 0,
  url: '/assets/mock-image.jpg',
  thumbnailUrl: '/assets/mock-image-thumb.jpg',
  altTextKeyOrText: 'Mock Product Image',
  tags: ['mock', 'test'],
};

const mockFeaturedImage: BackendFeaturedImageDto = {
  id: 'featured-1',
  url: '/assets/mock-featured.jpg',
  altTextKeyOrText: 'Mock Featured Image'
};

export const mockProductDetails: any[] = [
  {
    id: 'mock-product-1',
    name: 'Mock Product 1',
    shortDescription: 'This is a mock product for testing',
    description: 'Detailed description of mock product 1',
    type: 'physical',
    status: 'published',
    isActive: true,
    isFeatured: true,
    averageRating: 4.5,
    reviewCount: 10,
    hasDiscount: false,
    discountPercentage: 0,
    price: 99.99,
    originalPrice: 99.99,
    currency: 'EUR',
    stockStatus: 'inStock',
    inStock: true,
    stockQuantity: 10,
    featuredImage: mockFeaturedImage,
    tags: ['mock', 'test'],
    categories: [],
    featuredImages: [{
      id: 'featured-1',
      url: '/assets/mock-featured.jpg',
      altText: 'Mock Featured Image'
    }],
    selectedVariant: { // Fix: make this match BackendSelectedVariantDto structure
      id: 'variant-1',
      sku: 'MOCK-001',
      price: 99.99,
      originalPrice: 99.99,
      stockQuantity: 10,
      stockStatus: 'inStock',
      hasDiscount: false,
      isDefault: true, // Fix: add missing property
      media: [] // Fix: add missing property
    },
    colorVariants: []
  }
];

export const mockProductListResponse: BackendPaginatedListDto<BackendProductListItemDto> = {
  items: mockProductDetails.map(detail => ({
    id: detail.id,
    name: detail.name,
    shortDescription: detail.shortDescription,
    tags: detail.tags,
    type: detail.type,
    status: detail.status,
    isActive: detail.isActive,
    isFeatured: detail.isFeatured ?? false,
    averageRating: detail.averageRating,
    reviewCount: detail.reviewCount,
    hasDiscount: detail.hasDiscount,
    discountPercentage: detail.discountPercentage,
    price: detail.price ?? 0,
    originalPrice: detail.originalPrice,
    currency: detail.currency ?? 'EUR',
    stockStatus: detail.stockStatus ?? 'outOfStock',
    inStock: detail.inStock,
    featuredImages: detail.featuredImages ?? [],
    selectedVariant: {
      id: detail.selectedVariant?.id ?? 'default-variant',
      sku: detail.selectedVariant?.sku ?? 'DEFAULT',
      price: detail.selectedVariant?.price ?? 0,
      originalPrice: detail.selectedVariant?.originalPrice,
      stockQuantity: detail.selectedVariant?.stockQuantity,
      stockStatus: detail.selectedVariant?.stockStatus,
      isDefault: true, // Always true for list items
      media: [] // Empty for list items
    } as BackendSelectedVariantDto, // Cast to correct type
    colorVariants: [],
    categories: detail.categories ?? []
  })),
  pageNumber: 1,
  pageSize: 10,
  totalPages: 1,
  totalCount: 1,
  hasPreviousPage: false,
  hasNextPage: false
};
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/diy-kit.model.ts ---
/**
 * @file diy-kit.model.ts
 * @Version 1.3.0 (DiyKitPageData Volledig & DiyTechHighlightGridItem Stricter)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description
 *   Definieert de TypeScript-interfaces voor data-objecten gerelateerd aan
 *   "Build-It-Yourself" (DIY) drone kits. De DiyKitPageData interface is nu
 *   volledig, inclusief 'componentDeepDive' en 'techHighlights'. DiyTechHighlightGridItem
 *   is strikter met 'imageUrl' en 'textAlign'.
 */
import { AppIcon } from '@royal-code/shared/domain';

/** Definitie voor een productkaart voor de BYS kits sectie. */
export interface DiyKitProductCardData {
  id: string;
  nameKey: string;
  imageUrl: string;
  descriptionKey: string;
  features: { icon: AppIcon; textKey: string }[];
  route: string | string[];
  priceDisplayKey?: string;
}

/** Definitie voor een highlight item in de componenten verdieping sectie. */
export interface DiyTechHighlightGridItem {
  id: string;
  icon?: AppIcon | null;

  imageUrl?: string;
  youtubeVideoId?: string;
  titleKey: string;
  descriptionKey: string;
  route?: string | string[];
  textAlign: 'left' | 'right' | 'center';
  size?: 'small' | 'medium' | 'large' | 'full-width';
  openInNewTab?: boolean;
  gridClasses?: string;
  contentPadding?: string; 
}


/** Interface voor een testimonial item, compatibel met ItemCarouselComponent */
export interface DiyTestimonialItem {
  id: string;
  quoteKey: string;
  author: string;
  imageUrl: string;
  name: string; // Vereist door ItemCarouselItem
}

/** Interface voor een FAQ item. */
export interface DiyFaqItem {
  id: string;
  questionKey: string;
  answerKey: string;
}

/** Hoofdinterface voor alle data van de BYS landingspagina. */
export interface DiyKitPageData {
  hero: {
    youtubeVideoId: string; titleKey: string; subtitleKey: string;
    ctaBeginnerKey: string; ctaBeginnerAnchor: string;
    ctaExpertKey: string; ctaExpertAnchor: string;
  };
  valueProp: {
    titleKey: string;
    cards: { icon: AppIcon; titleKey: string; descriptionKey: string; }[];
  };
  kitFinder: {
    imageUrl: string; titleKey: string; subtitleKey: string;
    buttonTextKey: string; route: string;
  };
  sub250gKits: {
    titleKey: string; anchorId: string; kits: DiyKitProductCardData[];
  };
  fiveInchKits: {
    titleKey: string; anchorId: string; kits: DiyKitProductCardData[];
  };
  componentDeepDive: {
    titleKey: string; subtitleKey: string; gridItems: DiyTechHighlightGridItem[];
  };
  guides: {
    titleKey: string; subtitleKey: string;
    links: { icon: AppIcon; titleKey: string; descriptionKey: string; route: string | string[]; }[];
  };
  techHighlights: {
    titleKey: string; gridItems: DiyTechHighlightGridItem[];
  };
  testimonials: {
    titleKey: string; items: DiyTestimonialItem[];
  };
  faq: {
    titleKey: string; items: DiyFaqItem[];
  };
  seamlessBuildGuide: { // <<< DE FIX: NIEUW TOEGEVOEGD AAN DE INTERFACE
    imageUrl: string;
    titleKey: string;
    subtitleKey: string;
    buttonTextKey: string;
    route: string;
  };
  stickyCta: {
    textKey: string; route: string;
  };
}
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/drone-explanation.model.ts ---
/**
 * @file drone-explanation.model.ts
 * @Version 1.2.1 (Fixed: 'bullet-list' type and bulletPoints added, ReviewSummary import, ExplanationStatCard matching UiFeatureCard)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description
 *   Definieert de datastructuren voor de generieke, datagedreven
 *   DroneExplanationPageComponent, gebruikt voor de DIY Build Kits.
 * @GeneratedBy Royal-Code MonorepoAppDevAI
 * @GeneratedDate 2025-09-02
 * @PromptSummary "Compilerfouten oplossen: 'bullet-list' type, ReviewSummary properties, en UI component imports. ExplanationStatCard matcht UiFeatureCard."
 */
import { AppIcon } from '@royal-code/shared/domain';
import { ReviewSummary } from '@royal-code/shared/domain'; // Correcte import

// Sub-interfaces voor duidelijkheid
export interface ExplanationStatCard {
  icon: AppIcon;
  titleKey: string; // Aangepast van labelKey
  descriptionKey: string; // Aangepast van valueKeyOrText
  textWrap?: boolean;
}

export interface CoreDescriptionBlock {
  type: 'paragraph' | 'feature-list' | 'quote-block' | 'cta-block' | 'media-embed' | 'bullet-list';
  contentKey?: string;
  items?: { icon: AppIcon; textKey: string }[];
  ctaTextKey?: string;
  ctaRoute?: string | string[];
  youtubeVideoId?: string;
  bulletPoints?: string[];
}

export interface ProductStorySection {
  id: string;
  imageUrl: string;
  youtubeVideoId?: string;
  titleKey: string;
  subtitleKey: string;
  textAlign: 'left' | 'right';
  relatedProductRoute?: string | string[];
  ctaTextKey?: string;
  detailedContentBlocks?: CoreDescriptionBlock[];
}

export interface ExplanationInTheBoxItem {
  icon: AppIcon;
  textKey: string;
}

export interface ExplanationAccessoryItem {
  id: string;
  name: string;
  imageUrl: string;
  route: string | string[];
}

export interface FaqItem {
  id: string;
  questionKey: string;
  answerKey: string;
}

// Hoofdinterface
export interface DroneExplanationData {
  id: string;
  name: string;
  shortDescriptionKey: string;
  brand: string;
  explanationPageRoute: string | string[];
  productPurchaseRoute: string | string[];

  // Secties
  heroVideoId: string;
  heroImageUrl: string;
  heroTitleKey: string;
  heroSubtitleKey: string;
  heroCtaKey: string;
  promiseStats: ExplanationStatCard[];
  coreDescriptionBlocks: CoreDescriptionBlock[];
  storySections: ProductStorySection[];
  basePriceDisplay: string;
  priceDisclaimerKey: string;
  callToActionLinkKey: string;
  inTheBoxItems: ExplanationInTheBoxItem[];
  essentialAccessories: ExplanationAccessoryItem[];
  reviewSummary: ReviewSummary; // Hergebruik bestaand domain model
  faqTitleKey: string;
  faqItems: FaqItem[];
}
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/index.ts ---
/**
 * @file index.ts (products-domain/lib)
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-12
 * @Description
 *   Internal barrel file that aggregates and re-exports all product-related
 *   domain models, enums, and type definitions from this directory. This provides
 *   a single, clean import point for the main library index.
 */

// === CORE PRODUCT MODELS ===
export * from './product-base.model';
export * from './product-category.model';
export * from './product-commerce-details.model';
export * from './product-digital.model';
export * from './product-error.model';
export * from './product-game-item.model';
export * from './product-physical.model';
export * from './product-service.model';
export * from './product-variants.model';
export * from './product.model';

// === VIEW MODELS (for specific, non-entity representations) ===
export * from './product-list-item.model';

// === COMMAND PAYLOADS (for CUD operations) ===
export * from './product-mutation.model';

// === QUERY FILTERS ===
export * from './product-filters.model';
export * from './search-suggestion.model';

// === CONSTANTS ===
export * from '../constants/product.constants';

// === SPECIALIZED MODELS ===
export * from './drone-explanation.model';
export * from './diy-kit.model';

// === DIY KIT TYPES ===
export type {
  DiyKitPageData,
  DiyKitProductCardData,
  DiyTechHighlightGridItem,
  DiyTestimonialItem,
  DiyFaqItem,
} from './diy-kit.model';
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/product-base.model.ts ---
/**
 * @file product-base.model.ts - DEFINITIVE AND CORRECTED VERSION
 * @Version 2.1.0 - Aligned with DTO Nullability and ensures all common properties exist.
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-20
 * @Description This version consolidates common properties from backend DTOs into ProductBase,
 *              making them optional where they might be absent or null, solving type assignment errors.
 *              It also maintains `categoryIds` to prevent TS2353.
 */
import { Media } from '@royal-code/shared/domain';
import { ProductStatus, ProductType, StockStatus } from '../types/product-types.enum';
import { ProductVariantCombination, VariantAttribute } from './product-variants.model';
import { Review } from '@royal-code/features/reviews/domain';
import { AuditableEntityBase, DateTimeInfo } from '@royal-code/shared/base-models';
 // Nodig voor StockStatus

export interface ProductColorVariantTeaser {
  readonly uiId: number;
  readonly attributeValueId: string;
  readonly defaultVariantId: string;
  readonly value: string;
  readonly displayName: string;
  readonly colorHex?: string | null;
  readonly price: number;
  readonly originalPrice?: number | null;
  readonly media?: readonly Media[] | null;
  readonly isDefault?: boolean; // <-- TOEGEVOEGD: Deze property ontbrak
}

export interface ProductBase extends AuditableEntityBase {
  readonly id: string;
  name: string;
  slug?: string | null; // Allow null for slug
  readonly type: ProductType;
  status: ProductStatus;

  shortDescription?: string | null; // Allow null
  description: string;

  media?: readonly Media[] | null; // Allow null
  currency?: string | null; // Allow null
  colorVariants?: readonly ProductColorVariantTeaser[] | null; // Allow null
  categoryIds: string[]; // This property remains mandatory and non-null in ProductBase
  tags?: readonly string[] | null; // Allow null

  variantAttributes?: readonly VariantAttribute[] | null; // Allow null
  variantCombinations?: readonly ProductVariantCombination[] | null; // Allow null

  // --- COMMERCE PROPERTIES (Added/Adjusted to solve NG9 errors on ProductListComponent) ---
  price?: number | null; // Make optional and allow null
  originalPrice?: number | null; // Make optional and allow null
  hasDiscount?: boolean; // Make optional
  discountPercentage?: number | null; // Make optional and allow null
  stockStatus?: StockStatus | null; // Make optional and allow null
  inStock?: boolean; // Make optional
  stockQuantity?: number | null; // Make optional and allow null

  // Reviews & Ratings
  averageRating?: number | null; // Allow null
  reviewCount?: number;

  // Visibility & Lifecycle
  isActive: boolean;
  isFeatured?: boolean;
  isNewUntil?: DateTimeInfo | null;

  // Analytics
  totalSalesCount?: number;
  viewCount?: number;

  // SEO
  metaTitle?: string | null;
  metaDescription?: string | null;
  metaKeywords?: string[] | null;

  publishedAt?: DateTimeInfo | null;
  archivedAt?: DateTimeInfo | null;
  discontinuedAt?: DateTimeInfo | null;
  lastModifiedBy?: string | null;

  // Relationships & Inventory Hints
  relatedProductIds?: string[] | null;
  restockDate?: DateTimeInfo | null;

  // Pricing (Internal - these were already optional, good)
  costPrice?: number;
  profitMarginPercent?: number;

  // Pragmatic Enterprise Touches
  searchKeywords?: string[] | null;
  customAttributes?: Record<string, unknown> | null;
  appScope?: string | null;

    // === Tijdelijke eigenschap voor data-overdracht ===
  // @TODO remove this later
    _mediaMap?: Map<string, Media[]>; 

}
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/product-category.model.ts ---
/**
 * @file product-category.model.ts
 * @Version 2.1.0 (Key Property Added)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-08
 * @Description Defines the ProductCategory interface, now including the 'key' property
 *              to align with backend DTOs and enable correct display name derivation.
 */
import { AppIcon } from '@royal-code/shared/domain';
import { Media } from '@royal-code/shared/domain';
import { AuditableEntityBase } from '@royal-code/shared/base-models';

export interface ProductCategory extends AuditableEntityBase {
  readonly id: string;
  name: string;
  key: string; // << DE FIX: 'key' property toegevoegd
  slug: string;
  description?: string;
  parentId?: string | null;
  children?: ProductCategory[];
  categoryPathSlugs?: string[];
  level?: number;
  image?: Media;
  icon?: AppIcon;
  colorHex?: string;
  displayOrder?: number;
  metaTitle?: string;
  metaDescription?: string;
  metaKeywords?: string[];
  featuredProductIds?: string[];
  isActive: boolean;
  isVisibleInNavigation?: boolean;
  productCount?: number;
}

export interface CategoryFilterOptions {
  parentId?: string | null;
  level?: number;
  isActive?: boolean;
  isVisibleInNavigation?: boolean;
  searchTerm?: string;
  sortBy?: 'name' | 'displayOrder' | 'productCount' | 'createdAt';
  sortDirection?: 'asc' | 'desc';
  includeProductCount?: boolean;
}
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/product-commerce-details.model.ts ---
/**
 * @file product-commerce-details.model.ts
 * @Version 1.1.0 // Version updated for new additions
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-05-31
 * @Description Defines shared enums and interfaces related to commerce aspects
 *              of products, such as stock, pricing, discounts, variants,
 *              specifications, supplier, and shipping. These are imported by
 *              specific product type models (e.g., PhysicalProduct, DigitalProduct)
 *              that require these commercial attributes.
 */
import { Address, AppIcon } from '@royal-code/shared/domain';
import { Image } from '@royal-code/shared/domain';
import { DateTimeInfo, Dimension } from '@royal-code/shared/base-models';
// --- Enums ---

/**
 * @Enum DiscountType
 * @Description Defines the calculation method for a product discount.
 */
export enum DiscountType {
  PERCENTAGE = 'percentage',
  FIXED_AMOUNT = 'fixed_amount',
}

// --- Interfaces ---
/**
 * @Interface ProductTax
 * @Description Contains tax-related information for a product.
 */
export interface ProductTax {
  isTaxable: boolean;
  taxClassId?: string;
  vatRatePercent?: number;
}

/**
 * @Interface ProductDiscount
 * @Description Defines a discount applicable to a product or specific variant.
 */
export interface ProductDiscount {
  id: string;
  type: DiscountType;
  value: number;
  description?: string;
  startDate?: DateTimeInfo;
  endDate?: DateTimeInfo;
  isActive: boolean;
  couponCode?: string;
  minimumPurchase?: { type: 'quantity' | 'value'; amount: number };
  maxUsageCount?: number;        // NEW: Limit discount usage
  usageCount?: number;           // NEW: Track current usage
  userGroupIds?: string[];       // NEW: Restrict to specific user groups
  stackable?: boolean;           // NEW: Can combine with other discounts (default: false)
}

/**
 * @Interface ProductDisplaySpecification
 * @Description Represents a single, display-oriented specification item for a product,
 *              used to show fixed, informative details (e.g., material, dimensions, care instructions).
 */
export interface ProductDisplaySpecification {
  specKey: string;
  labelKeyOrText: string;
  valueKeyOrText: string;
  icon?: AppIcon | null;
  groupKeyOrText?: string | null;
  displayOrder?: number;
}

/**
 * @Interface SupplierInfo
 * @Description Information about the product supplier, particularly relevant for dropshipping models.
 */
export interface SupplierInfo {
  id?: string;
  name?: string;
  productUrlAtSupplier?: string;
  supplierSku?: string;
  costPrice?: number; // costPrice is here, as it's supplier-related
  address?: Address;
}

/**
 * @Interface ProductShipping
 * @Description Shipping-related details for a physical product.
 */
export interface ProductShipping {
  requiresShipping: boolean;
  packageDimensions?: Dimension;
  shippingClassId?: string;
  freeShippingOverride?: boolean;
  estimatedDeliveryDaysMin?: number;
  estimatedDeliveryDaysMax?: number;
  shipsFromAddress?: Address;
}
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/product-digital.model.ts ---
/**
 * @file digital-product.model.ts
 * @Version 1.1.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-05-31
 * @Description Defines the `DigitalProduct` interface, extending `ProductBase`.
 *              This model is designed for non-tangible items that are delivered
 *              or accessed electronically, such as e-books, software licenses,
 *              downloadable PDF patterns, digital gift cards, or access passes.
 *              It includes properties related to pricing, delivery mechanisms,
 *              file details, and licensing.
 */
import { ProductBase } from './product-base.model';
import { ProductType } from '../types/product-types.enum';
import { ProductDiscount, ProductTax } from './product-commerce-details.model';
import { DateTimeInfo } from '@royal-code/shared/base-models';

/**
 * @Enum DigitalProductDeliveryType
 * @Description Specifies the method by which the digital product is delivered to or accessed by the customer.
 */
export enum DigitalProductDeliveryType {
  DIRECT_DOWNLOAD = 'direct_download',
  EMAIL_DELIVERY = 'email_delivery',
  ACCOUNT_ENTITLEMENT = 'account_entitlement',
  EXTERNAL_SERVICE_ACCESS = 'external_service_access',
  INSTANT_DOWNLOAD = 'instant_download', // For immediate access after purchase
}

export interface DigitalProduct extends ProductBase {
  type: ProductType.DIGITAL_PRODUCT;

  // `currency` from ProductBase should be defined and non-null if price is present.
  price: number;
  originalPrice?: number;
  activeDiscount?: ProductDiscount | null;
  taxInfo?: ProductTax;

  deliveryType: DigitalProductDeliveryType;
  downloadUrl?: string;
  fileType?: string;
  fileSizeBytes?: number;
  version?: string;
  activationLimit?: number | null;
  licenseValidityPeriodKeyOrText?: string;
  systemRequirements?: string;
  accessExpirationDate?: DateTimeInfo | null;
}
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/product-error.model.ts ---
/**
 * @file product-error.model.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI (o.b.v. Claude AI suggestie)
 * @Date 2025-05-31
 * @Description Defines a structured error interface (`ProductError`) and a helper
 *              function (`createProductError`) for consistent and informative
 *              error handling within product-related operations in NgRx effects,
 *              services, and UI components.
 */

/**
 * @Interface ProductError
 * @Description Represents structured error information for operations related to products.
 *              This provides more context than a simple string message, aiding in
 *              debugging, logging, and displaying user-friendly error feedback.
 */
export interface ProductError {
  /** The primary, user-facing or log-friendly error message. */
  message: string;
  /**
   * Optional: A unique error code or key (e.g., 'PRODUCT_NOT_FOUND', 'VALIDATION_ERROR', 'API_UNAVAILABLE').
   * Useful for programmatic error handling or i18n of error messages.
   */
  code?: string;
  /**
   * Optional: A recordオブジェクト for additional contextual details about the error.
   * Can include things like validation failures, request parameters, or partial stack traces.
   * Avoid storing sensitive information here if the error is displayed to users.
   */
  details?: Record<string, any>;
  /** ISO 8601 timestamp string indicating when the error occurred. */
  createdAt: string;
  /**
   * Optional: Identifier for the operation that caused the error
   * (e.g., 'load_product_detail', 'update_stock_quantity', 'apply_filters').
   */
  operation?: string;
  /**
   * Optional: Boolean indicating whether the operation that caused this error
   * might succeed if retried (e.g., for transient network issues).
   */
  retryable?: boolean;
  /** Optional: HTTP status code if the error originated from an API call. */
  httpStatus?: number;
}

/**
 * @Function createProductError
 * @Description Helper factory function to create standardized `ProductError` objects.
 *              Ensures consistent structure and automatically sets the timestamp.
 * @param message The primary error message.
 * @param options Optional additional properties for the error object.
 * @returns A `ProductError` object.
 */
export function createProductError(
  message: string,
  options?: {
    code?: string;
    details?: Record<string, any>;
    operation?: string;
    retryable?: boolean;
    httpStatus?: number;
  }
): ProductError {
  return {
    message,
    code: options?.code,
    details: options?.details,
    createdAt: new Date().toISOString(),
    operation: options?.operation,
    retryable: options?.retryable ?? false, // Default to not retryable
    httpStatus: options?.httpStatus,
  };
}
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/product-filters.model.ts ---
// --- VERVANG VOLLEDIG BESTAND: libs/features/products/domain/src/lib/models/product-filters.model.ts ---
/**
 * @file product-filters.model.ts
 * @Version 2.1.0 (Unified Enterprise Standard - Droneshop Filters Added)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-30
 * @Description
 *   Defines the single, authoritative `ProductFilters` interface for all
 *   product-related queries. This model includes pagination, sorting, and
 *   feature-specific filtering options, serving as the consistent contract
 *   between UI components, NgRx state, and data-access layers.
 *   Now includes Droneshop-specific filters and definitions for dynamic filter UIs.
 * @GeneratedBy Royal-Code MonorepoAppDevAI
 * @GeneratedDate 2025-08-30
 * @PromptSummary Regenerated all modified files with clean comments and integrated filter/sort functionality.
 */
import { Product } from './product.model';
import { ProductStatus, ProductType, StockStatus } from '../types/product-types.enum';

/**
 * @interface ProductFilters
 * @description Defines the criteria for filtering and sorting product collections.
 */
export interface ProductFilters {
  readonly searchTerm?: string;
  readonly categoryIds?: readonly string[];
  readonly brandIds?: readonly string[]; // Wordt gebruikt voor backend 'brands' parameter
  readonly tags?: readonly string[];
  readonly productTypes?: readonly ProductType[];
  readonly statuses?: readonly ProductStatus[];
  readonly appScope?: string | null;
  readonly priceRange?: {
    readonly min?: number;
    readonly max?: number;
    readonly currency?: string;
  };
  readonly onSaleOnly?: boolean;
  readonly stockStatuses?: readonly StockStatus[];
  readonly inStockOnly?: boolean;
  readonly minimumRating?: number;
  readonly isFeatured?: boolean;
  readonly hasReviewsOnly?: boolean;
  readonly createdAfter?: string; // ISO string
  readonly publishedAfter?: string; // ISO string

  // === Nieuw voor Droneshop filters ===
  readonly skillLevels?: readonly ('beginner' | 'advanced' | 'professional')[];
  readonly hasCamera?: boolean;
  // === Einde nieuwe Droneshop filters ===

  // Sorting & Pagination
  readonly sortBy?: keyof Product | string;
  readonly sortDirection?: 'asc' | 'desc';
  readonly page?: number;
  readonly pageSize?: number;
}

/**
 * @interface FilterOption
 * @description Representeert een enkele optie binnen een filter, inclusief display-informatie en count.
 */
export interface FilterOption {
  value: string; // De werkelijke waarde die naar de backend wordt gestuurd (bv. ID of naam)
  label: string; // Display naam voor de UI
  count: number; // Aantal producten dat aan deze filteroptie voldoet
}

/**
 * @interface FilterDefinition
 * @description Definieert een filtercategorie, inclusief zijn type en beschikbare opties of range.
 */
export interface FilterDefinition {
  key: keyof ProductFilters; // De key die gebruikt wordt in ProductFilters (bv. 'brandIds', 'priceRange')
  label: string; // Display label voor de UI (bv. 'Merk', 'Prijs')
  type: 'checkbox' | 'range' | 'switch'; // Het type UI control voor dit filter
  options?: FilterOption[]; // Voor 'checkbox' en 'switch' types
  rangeMin?: number; // Voor 'range' type
  rangeMax?: number; // Voor 'range' type
}

/**
 * @typedef AvailableFiltersResponse
 * @description Het verwachte response formaat van de backend voor het ophalen van beschikbare filters.
 */
export type AvailableFiltersResponse = FilterDefinition[];
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/product-game-item.model.ts ---
/**
 * @file game-item-product.model.ts
 * @Version 1.2.0 // Version updated for VirtualItemProperties enhancements
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-05-31
 * @Description Defines the `VirtualGameItemProduct` interface, extending `ProductBase`.
 *              This model is tailored for intangible items used within a game context,
 *              such as the Challenger App. It includes `VirtualItemProperties` to
 *              describe in-game mechanics, rarity, effects, and specific pricing models
 *              (in-game currency or real money).
 */
import { ProductBase } from './product-base.model';
import { ProductType } from '../types/product-types.enum';

/**
 * @Interface VirtualItemProperties
 * @Description Encapsulates properties specific to virtual items intended for in-game use.
 */
export interface VirtualItemProperties {
  itemCategory: 'consumable' | 'equipment_weapon' | 'equipment_armor' | 'cosmetic_skin' |
                'lootbox' | 'currency_pack' | 'quest_item' | string;
  rarity?: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary' | 'mythic' | 'unique';
  usageLimit?: number | null;
  cooldownSeconds?: number;
  durationSeconds?: number;
  statBoosts?: Record<string, { value: number; isPercentage?: boolean; durationSeconds?: number }>;
  passiveEffectsDescription?: string[];
  onUseEffectsDescription?: string[];
  visualEffectId?: string;
  unlocksContent?: { type: 'challenge' | 'skill' | 'skin' | 'area' | 'recipe'; id: string; description?: string };
  requiredUserLevel?: number;
  isStackable?: boolean;
  maxStackSize?: number;

  // NEW Enhancements based on ChatGPT feedback for Challenger App context
  balanceVersion?: string;        // For game balance tracking and iteration
  equipmentSlot?: string;         // E.g., 'weapon', 'helmet', 'boots', or specific game enum
  isTradeable?: boolean;          // Can this item be traded between players?
  marketValue?: number;           // Estimated or current market value in a primary in-game currency
  collectionSeriesId?: string;    // If part of a collectible set or series
  achievements?: string[];        // IDs of achievements that unlock or are related to this item
}

export interface VirtualGameItemProduct extends ProductBase {
  type: ProductType.VIRTUAL_GAME_ITEM;

  // ProductBase.currency might be set if priceRealMoney is used.
  priceInGameCurrency?: { currencyId: string; amount: number }[];
  priceRealMoney?: number;

  properties: VirtualItemProperties;
}
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/product-list-item.model.ts ---
/**
 * @file product-list-item.model.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-13
 * @Description Defines the lightweight, explicit contract for a product in a list/grid view.
 */
import { Image } from '@royal-code/shared/domain';
import { ProductStatus, ProductType, StockStatus } from '../types/product-types.enum';

export interface ProductListItem {
  readonly id: string;
  readonly name: string;
  readonly type: ProductType;
  readonly status: ProductStatus;
  readonly hasDiscount: boolean;
  readonly isActive: boolean;
  readonly isFeatured: boolean;
  readonly reviewCount: number;
  readonly tags: readonly string[];
  readonly shortDescription?: string | null;
  readonly averageRating?: number | null;
  readonly price?: number | null;
  readonly originalPrice?: number | null;
  readonly currency?: string | null;
  readonly stockStatus?: StockStatus | null;
  readonly inStock?: boolean | null;
  readonly discountPercentage?: number | null;
  primaryImage?: Image['variants'][0] | null;
}
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/product-mutation.model.ts ---
// --- VERVANG VOLLEDIG BESTAND: libs/features/products/domain/src/lib/models/product-mutation.model.ts ---
/**
 * @file product-mutation.model.ts
 * @Version 6.3.0 (DEFINITIVE GOLD STANDARD PAYLOAD - ALL FIXES APPLIED & SYNCHRONIZED)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-04
 * @Description Definitive payloads for CUD operations, exactly matching the backend POST DTO
 *              as per the provided "Gold Standard" JSON structure. All fields are correctly
 *              typed, including `null` allowances, frontend-specific `tempId`s, and mandatory fields like `stockStatus`.
 *              **Belangrijk: `CreateProductVariantCombinationDto` is hernoemd naar `CreateVariantOverrideDto`
 *              en `variantCombinations` naar `variantOverrides` om te synchroniseren met de backend.**
 */
import { ProductStatus, ProductType, StockStatus } from '../types/product-types.enum';
import { AppIcon } from '@royal-code/shared/domain';

// SEO DTO, als frontend model voor de payload
export interface CreateProductSeoDto {
  title: string | null;
  description: string | null;
  keywords: string[] | null;
  imageUrl: string | null;
}

// Pricing DTO, zoals in de Golden Standard JSON
export interface CreateProductPricingDto {
  price: number;
  originalPrice?: number | null;
}

// Variant Attribuut Waarde DTO voor de payload
export interface CreateVariantAttributeValueDto {
  tempId: string;
  value: string;
  displayNameKeyOrText: string;
  colorHex?: string | null;
  priceModifier?: number | null;
  isAvailable?: boolean;
  predefinedValue?: any | null; // Added for backend sync
}

// Variant Attribuut DTO voor de payload
export interface CreateVariantAttributeDto {
  tempId: string;
  nameKeyOrText: string;
  type: string; // Hier is het nog string voor de frontend mapping
  displayType: string;
  isRequired?: boolean;
  values: CreateVariantAttributeValueDto[];
}

// Selectie DTO voor een attribuut-waarde combinatie binnen een variant combinatie
export interface CreateVariantAttributeSelectionDto {
  attributeId: string;
  attributeValueId: string;
}

// << DE FIX: Naamgeving gesynchroniseerd met backend CreateVariantOverrideDto >>
export interface CreateVariantOverrideDto { // <-- HERNOEMD
  tempAttributeValueIds: string[]; // << DE FIX: Vereiste property, array van strings
  price: number;
  originalPrice?: number | null;
  stockQuantity: number;
  stockStatus: StockStatus;
  isDefault: boolean;
  isActive: boolean;
  mediaIds?: string[] | null;
  sku: string; // SKU is ook verplicht in de override
}

// Beschikbaarheidsregels voor fysieke producten
export interface CreateProductAvailabilityRulesDto {
  minOrderQuantity?: number | null;
  maxOrderQuantity?: number | null;
  quantityIncrements?: number | null;
  isActive?: boolean;
}

// Leeftijdsrestricties voor fysieke producten
export interface CreateProductAgeRestrictionsDto {
  minAge?: number | null;
  maxAge?: number | null;
}

// Dit is de ProductDisplaySpecification, zoals al eerder gedefinieerd in product-commerce-details.model.ts
export interface ProductDisplaySpecificationPayload {
  specKey: string;
  labelKeyOrText: string;
  valueKeyOrText: string;
  icon?: AppIcon | string | null;
  groupKeyOrText?: string | null;
  displayOrder?: number | null;
}


// Configuratie voor fysieke producten, genest in de hoofdpayload
export interface CreatePhysicalProductConfigDto {
  pricing: CreateProductPricingDto;
  sku?: string | null;
  brand?: string | null;
  manageStock?: boolean;
  stockQuantity?: number | null;
  allowBackorders?: boolean;
  lowStockThreshold?: number | null;
  availabilityRules?: CreateProductAvailabilityRulesDto | null;
  ageRestrictions?: CreateProductAgeRestrictionsDto | null;
  displaySpecifications?: ProductDisplaySpecificationPayload[] | null;
  washable?: boolean | null; // Added per backend update
}

// DE HOOFD PAYLOAD VOOR HET AANMAKEN VAN EEN PRODUCT
export interface CreateProductPayload {
  type: ProductType;
  name: string;
  description: string;
  shortDescription?: string | null;
  status: ProductStatus;
  isActive: boolean;
  isFeatured: boolean;
  currency: string;
  appScope?: string | null;
  tags?: string[] | null;
  categoryIds?: string[] | null;
  featuredImageId?: string | null;
  seo?: CreateProductSeoDto | null;
  variantAttributes?: CreateVariantAttributeDto[] | null;
  // << DE FIX: Naamgeving gesynchroniseerd met backend VariantOverridesDto >>
  variantOverrides?: CreateVariantOverrideDto[] | null; // <-- HERNOEMD
  physicalProductConfig?: CreatePhysicalProductConfigDto | null;
  customAttributes?: Record<string, any> | null;
}

// Payload voor het updaten van een bestaand product (gedeeltelijk)
export type UpdatePhysicalProductConfigDto = Partial<Omit<CreatePhysicalProductConfigDto, 'pricing'>> & {
  pricing?: Partial<CreateProductPricingDto>;
};

export type UpdateProductPayload = Partial<Omit<CreateProductPayload, 'type' | 'physicalProductConfig'>> & {
  physicalProductConfig?: UpdatePhysicalProductConfigDto;
};
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/product-physical.model.ts ---
/**
 * @file physical-product.model.ts
 * @Version 1.3.0 (Storytelling Sections Added)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Defines the `PhysicalProduct` interface, now including `storySections`
 *              to support data-driven, immersive "flagship" product pages.
 */
import { ProductBase } from './product-base.model';
import { ProductType, StockStatus } from '../types/product-types.enum';
import {
  ProductTax,
  ProductDiscount,
  ProductDisplaySpecification,
  SupplierInfo,
  ProductShipping
} from './product-commerce-details.model';
import { PhysicalProductVariants } from './product-variants.model';

/**
 * @Interface ProductAvailabilityRules
 * @Description Defines rules regarding order quantities for a product.
 */
export interface ProductAvailabilityRules {
  minOrderQuantity?: number;
  maxOrderQuantity?: number;
  quantityIncrements?: number; // e.g., must be ordered in multiples of 2
}

export interface PhysicalProduct extends ProductBase {
  readonly type: ProductType.PHYSICAL;
  price: number;
  originalPrice?: number;
  activeDiscount?: ProductDiscount | null;
  taxInfo?: ProductTax;
  sku?: string;
  ean?: string;
  gtin?: string;
  brand?: string;
  manageStock?: boolean;
  stockQuantity?: number | null;
  stockStatus?: StockStatus;
  allowBackorders?: boolean;
  lowStockThreshold?: number;
  variantContext?: PhysicalProductVariants;
  displaySpecifications?: ProductDisplaySpecification[];
  ageRecommendationKeyOrText?: string;
  safetyCertifications?: string[];
  supplierInfo?: SupplierInfo;
  shippingDetails?: ProductShipping;
  availabilityRules?: ProductAvailabilityRules;
}
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/product-service.model.ts ---
/**
 * @file service-product.model.ts
 * @Version 1.1.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-05-31
 * @Description Defines the `ServiceProduct` interface, extending `ProductBase`.
 *              This model is designed for intangible services offered to customers,
 *              which may involve scheduling, specific terms, or subscription models.
 *              Examples include customization services, repair services, consulting,
 *              or access to premium features via a subscription.
 */
import { ProductBase } from './product-base.model';
import { ProductType } from '../types/product-types.enum';
import { ProductDiscount, ProductTax } from './product-commerce-details.model';

/**
 * @Enum ServiceBillingCycle
 * @Description Defines the billing frequency for subscription-based services.
 */
export enum ServiceBillingCycle {
  ONE_TIME = 'one_time',
  DAILY = 'daily',
  WEEKLY = 'weekly',
  MONTHLY = 'monthly',
  QUARTERLY = 'quarterly',
  ANNUALLY = 'annually',
  BI_ANNUALLY = 'bi_annually',
}

/**
 * @Enum ServiceDeliveryMethod
 * @Description Specifies how the service is delivered or rendered to the customer.
 */
export enum ServiceDeliveryMethod {
  REMOTE_ONLINE = 'remote_online',
  ON_SITE_CUSTOMER = 'on_site_customer',
  ON_SITE_PROVIDER = 'on_site_provider',
  PHYSICAL_ITEM_INTERACTION = 'physical_item_interaction',
}

export interface ServiceProduct extends ProductBase {
  type: ProductType.SERVICE;

  // `currency` from ProductBase should be defined and non-null if price is present.
  price: number;
  originalPrice?: number;
  activeDiscount?: ProductDiscount | null;
  taxInfo?: ProductTax;

  billingCycle?: ServiceBillingCycle;
  serviceDurationKeyOrText?: string;
  deliveryMethod?: ServiceDeliveryMethod;
  requiresScheduling?: boolean;
  schedulingInstructionsOrUrl?: string;
  serviceTerms?: string;
  customerPrerequisites?: string[];
}
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/product-variants.model.ts ---
/**
 * @file product-variants.model.ts
 * @Version 1.6.0 (Type-safe fix for media property)
 * @Description Definitive model for product variants, including attributes and combinations.
 */

import { Media } from "@royal-code/shared/domain";
import { StockStatus } from "../types/product-types.enum";
import { Dimension } from "@royal-code/shared/base-models";

export enum VariantAttributeType {
  COLOR = 'color',
  SIZE = 'size',
  MATERIAL = 'material',
  STYLE = 'style',
  FLAVOR = 'flavor',
  SCENT = 'scent',
  PATTERN = 'pattern',
  FINISH = 'finish',
  CAPACITY = 'capacity',
  POWER = 'power',
  CONNECTIVITY = 'connectivity',
  LANGUAGE = 'language',
  PLATFORM = 'platform',
  LICENSE_TYPE = 'license_type',
  DURATION = 'duration',
  CUSTOM = 'custom',
  RARITY = 'rarity',
  LEVEL = 'level',
  TIER = 'tier',
}

export interface VariantAttributeValue {
  readonly id: string;
  readonly value: string;
  readonly displayName: string;
  readonly nameKeyOrText?: string;
  readonly sortOrder: number;
  readonly colorHex?: string | null;
  readonly media?: readonly Media[] | null; 
  readonly priceModifier?: number;
  readonly isAvailable: boolean;
  displayNameKeyOrText?: string;
}


export interface VariantAttribute {
  id: string;
  type: VariantAttributeType;
  name: string;
  description?: string;
  isRequired: boolean;
  displayType: 'dropdown' | 'buttons' | 'swatches' | 'radio' | 'grid' | 'color-picker';
  displayOrder: number;
  values: VariantAttributeValue[];
  allowMultiple?: boolean;
  minSelections?: number;
  maxSelections?: number;
  dependsOn?: {
    attributeId: string;
    values: string[];
  };
  nameKeyOrText?: string;
}

export interface VariantAttributeSelection {
  attributeId: string;
  attributeValueId: string;
  attributeNameKeyOrText?: string;
  attributeValueNameKeyOrText?: string;
  colorHex?: string | null; // Optioneel, voor kleurattributen
}


export interface ProductVariantCombination {
  id: string;
  sku: string;
  attributes: VariantAttributeSelection[];
  price?: number;
  originalPrice?: number;
  stockQuantity?: number;
  stockStatus?: StockStatus;
  weight?: number;
  dimensions?: Dimension;
  isActive: boolean;
  isDefault?: boolean;
  barcode?: string;
  customAttributes?: Record<string, unknown>;
  mediaIds?: readonly string[] | null; // Consolidated to mediaIds
}

// For Physical Products
export interface PhysicalProductVariants {
  sizeChart?: {
    url?: string;
    measurements?: Record<string, Record<string, number>>;
  };
  careInstructions?: Record<string, string[]>;
  variantShipping?: Record<string, {
    additionalWeight?: number;
    additionalCost?: number;
  }>;
}

// For Digital Products
export interface DigitalProductVariants {
  formatVariants?: {
    format: string;
    fileSize: number;
    compatibility?: string[];
  }[];
  qualityVariants?: {
    quality: 'standard' | 'high' | 'ultra';
    fileSize: number;
    dimensions?: { width: number; height: number };
  }[];
}

// For Virtual Game Items
export interface VirtualItemVariants {
  rarityVariants?: {
    rarity: string;
    statModifiers: Record<string, number>;
    visualEffects?: string[];
  }[];
  levelVariants?: {
    requiredLevel: number;
    unlockedFeatures: string[];
  }[];
}

// For Service Products
export interface ServiceProductVariants {
  durationVariants?: {
    duration: number;
    unit: 'hours' | 'days' | 'weeks' | 'months' | 'years';
    price: number;
  }[];
  tierVariants?: {
    tier: 'basic' | 'standard' | 'premium' | 'enterprise';
    features: string[];
    limitations?: Record<string, number>;
  }[];
}
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/product.model.ts ---
/**
 * @file product.model.ts
 * @Version 1.1.0 // Version updated to reflect new base and types
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-05-31
 * @Description Defines the main `Product` discriminated union type,
 *              which combines all specific product type interfaces.
 *              This file primarily serves to construct and export this union type.
 *              It also re-exports ProductStatus for convenience.
 */
import { PhysicalProduct } from './product-physical.model';
import { VirtualGameItemProduct } from './product-game-item.model';
import { DigitalProduct } from './product-digital.model';
import { ServiceProduct } from './product-service.model';
import { ProductStatus } from '../types/product-types.enum';

export { ProductStatus }; // Re-export ProductStatus

/**
 * @TypeUnion Product
 * @Description A discriminated union representing any type of product within the system.
 *              Use the `type: ProductType` property (available on all constituents via `ProductBase`)
 *              to determine the specific product interface and safely access type-specific properties.
 */
export type Product =
  | PhysicalProduct
  | VirtualGameItemProduct
  | DigitalProduct
  | ServiceProduct;
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/models/search-suggestion.model.ts ---
/**
 * @file search-suggestion.model.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-01
 * @Description
 *   Defines the data models for search suggestions returned by the autocomplete API.
 */

export interface SearchSuggestion {
  type: 'product' | 'category' | 'brand' | 'guide' | string;
  text: string;
  imageUrl?: string | null;
  route: (string | { [key: string]: any })[]; // Array voor routerLink, kan queryParams bevatten
}

export interface SearchSuggestionResponse {
  suggestions: SearchSuggestion[];
}
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/types/product-types.enum.ts ---
/**
 * @file product-types.enum.ts
 * @Version 1.1.0 (Corrected Enum Casing)
 * @Author Royal-Code MonorepoAppDevAI & User
 * @Date 2025-07-21
 * @Description Corrected enums to use lowercase_snake_case strings to match backend JSON serialization.
 */

export enum ProductType {
  PHYSICAL = 'physical',
  VIRTUAL_GAME_ITEM = 'virtual_game_item',
  DIGITAL_PRODUCT = 'digital_product',
  SERVICE = 'service',
}

export enum ProductStatus {
  DRAFT = 'draft',
  PUBLISHED = 'published',
  ARCHIVED = 'archived',
  SCHEDULED = 'scheduled',
}

export enum StockStatus {
  IN_STOCK = 'in_stock',
  OUT_OF_STOCK = 'out_of_stock',
  ON_BACKORDER = 'on_backorder',
  PRE_ORDER = 'pre_order',
  DISCONTINUED = 'discontinued',
  LIMITED_STOCK = 'limited_stock',
  COMING_SOON = 'coming_soon'
}

export enum AttributeType {
  COLOR = 'color',
  SIZE = 'size',
  MATERIAL = 'material',
  STYLE = 'style',
  CUSTOM = 'custom'
}
--- END OF FILE ---

--- START OF FILE libs/features/products/domain/src/lib/utils/product-type-guards.ts ---
/**
 * @file product-type-guards.ts
 * @Description Type guards for the Product domain model.
 */

import { Product, PhysicalProduct } from "../models";
import { ProductType } from "../types/product-types.enum";

export function isPhysicalProduct(product: Product | undefined): product is PhysicalProduct {
  return !!product && product.type === ProductType.PHYSICAL;
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/core/src/index.ts ---
// State Management
export * from './lib/state/reviews.providers';
export * from './lib/state/reviews.facade';
export * from './lib/state/reviews.actions';

// Data-Access Contract
export * from './lib/data-access/abstract-reviews-api.service';

// DTOs
export * from './lib/DTO/backend-reviews.dto';

// Types and View Models
export * from './lib/state/reviews.types';

// Mappers - FIX: Zorg dat de mapper service geëxporteerd wordt
export * from './lib/mappers/reviews-mapping.service';
--- END OF FILE ---

--- START OF FILE libs/features/reviews/core/src/lib/data-access/abstract-reviews-api.service.ts ---
/**
 * @file abstract-reviews-api.service.ts
 * @Version 2.0.0 (API Aligned)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-08
 * @Description
 *   Defines the abstract contract for fetching review data, aligned with the backend
 *   which returns reviews and summaries in a single call.
 */
import { Observable } from 'rxjs';
import { Review, ReviewTargetEntityType, CreateReviewPayload, UpdateReviewPayload, ReviewVoteType, ReviewFilters, ReviewListItemDto } from '@royal-code/features/reviews/domain';
import { PaginatedList } from '@royal-code/shared/utils';
import { BackendProductReviewsResponseDto } from '../DTO/backend-reviews.dto';

export abstract class AbstractReviewsApiService {
  abstract getMyReviews(filters: ReviewFilters): Observable<PaginatedList<ReviewListItemDto>>; 
  abstract getReviews(targetEntityId: string, targetEntityType: ReviewTargetEntityType, filters: ReviewFilters): Observable<BackendProductReviewsResponseDto>;
  abstract createReview(payload: CreateReviewPayload): Observable<Review>; 
  abstract updateReview(reviewId: string, payload: UpdateReviewPayload): Observable<Review>;
  abstract deleteReview(reviewId: string): Observable<void>;
  abstract vote(reviewId: string, voteType: ReviewVoteType): Observable<Review>;
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/core/src/lib/data-access/product-review-mapping.service.ts ---
/**
 * @file product-review-mapping.service.ts
 * @Version 1.1.0 (Fixes Type Mismatches & Enum Mapping)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-03
 * @Description
 *   Mapping service om review data tussen frontend domeinmodellen (`Review`)
 *   en backend DTO's (`BackendReviewDto`) te transformeren.
 *   Deze service is tweerichtingsverkeer, wat handig is voor mocking en
 *   wanneer de backend-structuur strak moet worden gevolgd.
 *   Corrigeert type mismatches door expliciete casting en correcte enum-mappings.
 */
import { Injectable } from '@angular/core';
import { Review, ReviewTargetEntityType, ReviewVoteType } from '@royal-code/features/reviews/domain';
import { BackendReviewDto } from '@royal-code/features/reviews/core'; // Update import
import { DateTimeInfo } from '@royal-code/shared/base-models';

@Injectable({ providedIn: 'root' })
export class ProductReviewMappingService {

  /**
   * @method mapBackendDtoToReview
   * @description Converteert een backend `BackendReviewDto` naar een frontend `Review` domeinmodel.
   * @param dto Het backend DTO-object.
   * @returns Het gemapte `Review` object.
   */
  mapBackendDtoToReview(dto: BackendReviewDto): Review {
    return {
      id: dto.id,
      userId: dto.userId, // Property bestaat nu op BackendReviewDto
      userName: dto.userName, // Property bestaat nu op BackendReviewDto
      rating: dto.rating,
      comment: dto.comment, // Property bestaat nu op BackendReviewDto
      targetEntityId: dto.targetEntityId, // Property bestaat nu op BackendReviewDto
      targetEntityType: this.mapTargetEntityType(dto.targetEntityType),
      createdAt: this.toDateTimeInfo(dto.createdAt),
      lastModified: this.toDateTimeInfo(dto.lastModified),
      likes: dto.likes,
      dislikes: dto.dislikes,
      userVote: this.mapVoteType(dto.userVote),
    };
  }

  /**
   * @method mapReviewToBackendDto
   * @description Converteert een frontend `Review` domeinmodel naar een backend `BackendReviewDto`.
   *              Dit is voornamelijk handig voor het maken van mock data die de API nabootst.
   * @param review Het frontend `Review` object.
   * @returns Het gemapte `BackendReviewDto` object.
   */
  mapReviewToBackendDto(review: Review): BackendReviewDto {
    return {
      id: review.id,
      userId: review.userId, // Property bestaat nu op Review
      userName: review.userName, // Property bestaat nu op Review
      rating: review.rating,
      comment: review.comment, // Property bestaat nu op Review
      targetEntityId: review.targetEntityId, // Property bestaat nu op Review
      targetEntityType: this.mapTargetEntityTypeToNumber(review.targetEntityType),
      createdAt: review.createdAt?.iso ?? new Date().toISOString(),
      lastModified: review.lastModified?.iso ?? new Date().toISOString(),
      likes: review.likes,
      dislikes: review.dislikes,
      userVote: this.mapVoteTypeToNumber(review.userVote as ReviewVoteType | undefined), // Cast naar correct type
    };
  }

  private mapTargetEntityType(typeNumber: number): ReviewTargetEntityType {
    switch (typeNumber) {
      case 0: return ReviewTargetEntityType.PRODUCT;
      case 1: return ReviewTargetEntityType.GUIDE;
      case 2: return ReviewTargetEntityType.USER;
      default: return ReviewTargetEntityType.PRODUCT; // Fallback
    }
  }

  private mapTargetEntityTypeToNumber(type: ReviewTargetEntityType): number {
    switch (type) {
      case ReviewTargetEntityType.PRODUCT: return 0;
      case ReviewTargetEntityType.GUIDE: return 1;
      case ReviewTargetEntityType.USER: return 2;
      default: return 0;
    }
  }

  private mapVoteType(voteNumber: number | null | undefined): ReviewVoteType | undefined {
    if (voteNumber === null || voteNumber === undefined) return undefined;
    switch (voteNumber) {
      case 0: return ReviewVoteType.Like; // Corrected: Like (PascalCase)
      case 1: return ReviewVoteType.Dislike; // Corrected: Dislike (PascalCase)
      default: return undefined;
    }
  }

  private mapVoteTypeToNumber(voteType: ReviewVoteType | undefined): number | null {
    if (voteType === undefined) return null;
    switch (voteType) {
      case ReviewVoteType.Like: return 0; // Corrected: Like (PascalCase)
      case ReviewVoteType.Dislike: return 1; // Corrected: Dislike (PascalCase)
      default: return null;
    }
  }

  private toDateTimeInfo(isoString?: string): DateTimeInfo | undefined {
    return isoString ? { iso: isoString } : undefined;
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/core/src/lib/DTO/backend-reviews.dto.ts ---
/**
 * @file backend-reviews.dto.ts
 * @Version 3.0.0 (API Aligned & Definitive)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-08
 * @Description
 *   Centralized DTOs for the Reviews API, 100% aligned with the Swagger specification.
 *   This is the definitive structure for API communication.
 */
import { ReviewStatus } from '@royal-code/features/reviews/domain';
import { ReviewSummary } from '@royal-code/shared/domain';
import { PaginatedList } from '@royal-code/shared/utils';

// Corresponds to a single review item within the paginated list
export interface BackendReviewDto {
  readonly id: string;
  readonly rating: number;
  readonly title: string | null;
  readonly reviewText: string;
  readonly isVerifiedPurchase: boolean;
  readonly likes: number;
  readonly dislikes: number;
  readonly status: ReviewStatus; // Matches the domain enum now
  readonly createdAt: string; // ISO string
  readonly authorId: string;
  readonly authorDisplayName: string;
  readonly authorAvatarMediaId: string | null;
  readonly mediaCount: number;
  readonly replyCount: number;
  readonly totalVotes: number;
  readonly likePercentage: number;
  readonly truncatedText: string;
  readonly userVote?: string | null;
}

// Corresponds to the full response of GET /api/Reviews/product/{productId}/reviews
export interface BackendProductReviewsResponseDto {
  readonly productId: string;
  readonly reviews: PaginatedList<BackendReviewDto>;
  readonly ratingStatistics: ReviewSummary;
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/core/src/lib/mappers/reviews-mapping.service.ts ---
/**
 * @file reviews-mapping.service.ts
 * @Version 3.1.0 (Definitive - Maps Backend DTO with Context)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-08
 * @Description
 *   Definitive mapping service that correctly accepts a raw BackendReviewDto and
 *   contextual data (like targetEntityId) to create a fully-formed,
 *   immutable ReviewWithUIState domain model.
 */
import { Injectable, inject } from '@angular/core';
import { ReviewTargetEntityType, ReviewVoteType } from '@royal-code/features/reviews/domain';
import { Image, MediaType, IUserStub, SyncStatus } from '@royal-code/shared/domain';
import { DateTimeUtil } from '@royal-code/shared/utils';
import { APP_CONFIG } from '@royal-code/core/config';
import { ReviewWithUIState } from '../state/reviews.types';
import { BackendReviewDto } from '../DTO/backend-reviews.dto';

@Injectable({ providedIn: 'root' })
export class ReviewsMappingService {
  private readonly config = inject(APP_CONFIG);

  public mapDtoToDomain(
    dto: BackendReviewDto,
    targetEntityId: string, // FIX: Pass context in
    targetEntityType: ReviewTargetEntityType
  ): ReviewWithUIState {
    const avatar: Image | undefined = dto.authorAvatarMediaId
      ? {
          id: dto.authorAvatarMediaId,
          type: MediaType.IMAGE,
          variants: [{ url: `${this.config.backendUrl}/Media/${dto.authorAvatarMediaId}/avatar-thumbnail`, purpose: 'thumbnail' }],
          altText: `${dto.authorDisplayName}'s avatar`,
        }
      : undefined;

    const profile: IUserStub = {
      id: dto.authorId,
      displayName: dto.authorDisplayName,
      avatar: avatar,
      createdAt: undefined, 
      lastModified: undefined
    };

    return {
      id: dto.id,
      authorId: dto.authorId,
      profile: profile,
      targetEntityId: targetEntityId, // FIX: Set from parameter during creation
      targetEntityType: targetEntityType,
      rating: dto.rating,
      title: dto.title,
      reviewText: dto.reviewText,
      isVerifiedPurchase: dto.isVerifiedPurchase,
      likes: dto.likes,
      dislikes: dto.dislikes,
      status: dto.status,
      media: [],
      mediaCount: dto.mediaCount,
      replyCount: dto.replyCount,
      userVote: this.mapUserVote(dto.userVote),
      totalVotes: dto.totalVotes,
      likePercentage: dto.likePercentage,
      helpfulScore: dto.likePercentage,
      createdAt: DateTimeUtil.createDateTimeInfo(dto.createdAt),
      lastModified: DateTimeUtil.createDateTimeInfo(dto.createdAt),
      uiSyncStatus: SyncStatus.Synced,
    };
  }

  private mapUserVote(userVote: string | null | undefined): ReviewVoteType | null {
    if (!userVote) return null;
    if (userVote === 'like') return ReviewVoteType.Like;
    if (userVote === 'dislike') return ReviewVoteType.Dislike;
    return null;
  }

}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/core/src/lib/state/reviews.actions.ts ---
/**
 * @file reviews.actions.ts
 * @Version 4.1.0 (Definitive Actions with Error Cleared)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-01
 * @description
 *   Definitive NgRx actions for the Reviews domain, ensuring `errorCleared` is correctly defined.
 */
import { createActionGroup, emptyProps, props } from '@ngrx/store';
import { Update } from '@ngrx/entity';
import { CreateReviewPayload, Review, ReviewTargetEntityType, UpdateReviewPayload, ReviewVoteType, ReviewFilters } from '@royal-code/features/reviews/domain';
import { ReviewSummary } from '@royal-code/shared/domain';
import { StructuredError } from '@royal-code/shared/domain';

export const ReviewsActions = createActionGroup({
  source: 'Reviews',
  events: {
    // === Context & Lifecycle ===
    'Context Set': props<{ targetEntityId: string; targetEntityType: ReviewTargetEntityType }>(),
    'My Reviews Page Opened': emptyProps(),
    'Filters Updated': props<{ filters: Partial<ReviewFilters> }>(),
    'Next Page Loaded': emptyProps(),
    'Data Refreshed': emptyProps(),

    // === Data Loading (met context) ===
    'Load Reviews': props<{ targetEntityId: string; targetEntityType: ReviewTargetEntityType }>(),
    'Load My Reviews': emptyProps(), // <-- NIEUW
    'Load Reviews Success': props<{ reviews: readonly Review[]; totalCount: number; hasMore: boolean }>(),
    'Load Reviews Failure': props<{ error: StructuredError }>(),

    'Load Summary': props<{ targetEntityId: string; targetEntityType: ReviewTargetEntityType }>(),
    'Load Summary Success': props<{ summary: ReviewSummary }>(),
    'Load Summary Failure': props<{ error: StructuredError }>(),

    // === CUD Operations ===
    'Review Submitted': props<{ payload: CreateReviewPayload }>(),
    'Create Review Success': props<{ review: Review }>(),
    'Create Review Failure': props<{ error: StructuredError }>(),

    'Review Update Submitted': props<{ reviewId: string; payload: UpdateReviewPayload }>(),
    'Update Review Success': props<{ reviewUpdate: Update<Review> }>(),
    'Update Review Failure': props<{ error: StructuredError; reviewId: string }>(),

    'Review Deletion Confirmed': props<{ reviewId: string }>(),
    'Delete Review Success': props<{ reviewId: string }>(),
    'Delete Review Failure': props<{ error: StructuredError; reviewId: string }>(),

    // === Voting ===
    'Vote Submitted': props<{ reviewId: string; voteType: ReviewVoteType }>(),
    'Vote Success': props<{ review: Review }>(),
    'Vote Failure': props<{ error: StructuredError; reviewId: string; voteType: ReviewVoteType }>(),

    // === UI State Management ===
    'Error Cleared': emptyProps(), 
    'State Reset': emptyProps(),
  }
});
--- END OF FILE ---

--- START OF FILE libs/features/reviews/core/src/lib/state/reviews.effects.ts ---
/**
 * @file reviews.effects.ts
 * @Version 9.2.0 (Definitive - All Compiler Errors Fixed)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-08
 * @description
 *   Definitive effects for the Reviews feature. This version resolves all previous
 *   compiler errors by using correct relative import paths, respecting readonly
 *   properties by passing context to the mapping service, and correctly typing
 *   all API responses and mappings.
 */
import { Injectable, inject } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { Store } from '@ngrx/store';
import { of } from 'rxjs';
import { map, catchError, switchMap, withLatestFrom, tap, mergeMap } from 'rxjs/operators';
import { ReviewsActions } from './reviews.actions';
import { AbstractReviewsApiService } from '../data-access/abstract-reviews-api.service';
import { reviewsFeature } from './reviews.feature';
import { StructuredError } from '@royal-code/shared/domain';
import { NotificationService } from '@royal-code/ui/notifications';
import { ReviewsMappingService } from '../mappers/reviews-mapping.service';
// FIX: Correct relative import path
import { HttpErrorResponse } from '@angular/common/http';
import { ErrorActions } from '@royal-code/store/error';
import { BackendReviewDto } from '../DTO/backend-reviews.dto';

@Injectable()
export class ReviewsEffects {
  private readonly actions$ = inject(Actions);
  private readonly store = inject(Store);
  private readonly reviewsApiService = inject(AbstractReviewsApiService);
  private readonly notificationService = inject(NotificationService);
  private readonly mappingService = inject(ReviewsMappingService);

  triggerInitialDataLoad$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ReviewsActions.contextSet),
      map(({ targetEntityId, targetEntityType }) => 
        ReviewsActions.loadReviews({ targetEntityId, targetEntityType })
      )
    )
  );

  loadReviewsAndSummary$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ReviewsActions.loadReviews),
      withLatestFrom(this.store.select(reviewsFeature.selectFilters)),
      switchMap(([{ targetEntityId, targetEntityType }, filters]) =>
        this.reviewsApiService.getReviews(targetEntityId, targetEntityType, filters).pipe(
          mergeMap(response => {
            const paginatedReviews = response.reviews;
            const summary = response.ratingStatistics;
            
            const reviews = paginatedReviews.items.map((dto: BackendReviewDto) => 
                // FIX: Pass context to the mapper, don't modify readonly property later
                this.mappingService.mapDtoToDomain(dto, targetEntityId, targetEntityType)
            );

            return [
              ReviewsActions.loadReviewsSuccess({ 
                reviews, 
                totalCount: paginatedReviews.totalCount, 
                hasMore: paginatedReviews.hasNextPage 
              }),
              ReviewsActions.loadSummarySuccess({ summary })
            ];
          }),
          catchError((error: HttpErrorResponse) => {
              const structuredError: StructuredError = {
                source: '[API Reviews]',
                message: 'Er is een serverfout opgetreden bij het ophalen van de reviews.',
                severity: 'error',
                context: { status: error.status, url: error.url },
                timestamp: Date.now()
              };
              return of(
                ErrorActions.reportError({ error: structuredError }),
                ReviewsActions.loadReviewsFailure({ error: structuredError })
              );
          })
        )
      )
    )
  );
  
  createReview$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ReviewsActions.reviewSubmitted),
      switchMap(({ payload }) =>
        this.reviewsApiService.createReview(payload).pipe(
          tap(() => this.notificationService.showSuccess('Review succesvol geplaatst!')),
          map(review => ReviewsActions.createReviewSuccess({ review })),
          catchError(error => {
              const structuredError: StructuredError = { message: 'Failed to create review.', code: 'REVIEW_CREATE_FAIL', context: { error }, timestamp: Date.now(), severity: 'error' };
              return of(ReviewsActions.createReviewFailure({ error: structuredError }));
          })
        )
      )
    )
  );
  
  updateReview$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ReviewsActions.reviewUpdateSubmitted),
      switchMap(({ reviewId, payload }) =>
        this.reviewsApiService.updateReview(reviewId, payload).pipe(
          tap(() => this.notificationService.showSuccess('Review succesvol bijgewerkt!')),
          map(updatedReview => ReviewsActions.updateReviewSuccess({ reviewUpdate: { id: reviewId, changes: updatedReview } })),
          catchError(error => {
              const structuredError: StructuredError = { message: 'Failed to update review.', code: 'REVIEW_UPDATE_FAIL', context: { error }, timestamp: Date.now(), severity: 'error' };
              return of(ReviewsActions.updateReviewFailure({ error: structuredError, reviewId }));
          })
        )
      )
    )
  );

  deleteReview$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ReviewsActions.reviewDeletionConfirmed),
      switchMap(({ reviewId }) =>
        this.reviewsApiService.deleteReview(reviewId).pipe(
          tap(() => this.notificationService.showSuccess('Review succesvol verwijderd.')),
          map(() => ReviewsActions.deleteReviewSuccess({ reviewId })),
          catchError(error => {
             const structuredError: StructuredError = { message: 'Failed to delete review.', code: 'REVIEW_DELETE_FAIL', context: { error }, timestamp: Date.now(), severity: 'error' };
             return of(ReviewsActions.deleteReviewFailure({ error: structuredError, reviewId }));
          })
        )
      )
    )
  );

  vote$ = createEffect(() =>
    this.actions$.pipe(
      ofType(ReviewsActions.voteSubmitted),
      switchMap(({ reviewId, voteType }) =>
        this.reviewsApiService.vote(reviewId, voteType).pipe(
          map(review => ReviewsActions.voteSuccess({ review })),
          catchError(error => {
             const structuredError: StructuredError = { message: 'Failed to submit vote.', code: 'REVIEW_VOTE_FAIL', context: { error }, timestamp: Date.now(), severity: 'error' };
             return of(ReviewsActions.voteFailure({ error: structuredError, reviewId, voteType }));
          })
        )
      )
    )
  );
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/core/src/lib/state/reviews.facade.ts ---
/**
 * @file reviews.facade.ts
 * @Version 5.4.0 (Definitive & Aligned with UI needs)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @description The definitive, stable facade for the Reviews feature, now including all necessary methods.
 */
import { Injectable, Signal, inject, computed } from '@angular/core';
import { toSignal } from '@angular/core/rxjs-interop';
import { Store } from '@ngrx/store';
import { ReviewTargetEntityType, UpdateReviewPayload, CreateReviewPayload, ReviewVoteType, ReviewFilters } from '@royal-code/features/reviews/domain';
import { ReviewsActions } from './reviews.actions';
import { selectReviewListViewModel, selectTotalCount, selectIsSubmitting, selectError, selectAllReviews, selectIsLoading, selectHasMore, selectHasReviews, selectTargetEntityId, selectTargetEntityType } from './reviews.feature';
import { ReviewListViewModel } from './reviews.types';

@Injectable({ providedIn: 'root' })
export class ReviewsFacade {
  private readonly store = inject(Store);

  readonly reviewListViewModel: Signal<ReviewListViewModel> = toSignal(
    this.store.select(selectReviewListViewModel),
    { initialValue: this.createInitialViewModel() }
  );
  readonly allReviews = toSignal(this.store.select(selectAllReviews), { initialValue: [] });
  readonly totalCount = toSignal(this.store.select(selectTotalCount), { initialValue: 0 });
  readonly isLoading = toSignal(this.store.select(selectIsLoading), { initialValue: false });
  readonly isSubmitting = toSignal(this.store.select(selectIsSubmitting), { initialValue: false });
  readonly error = toSignal(this.store.select(selectError), { initialValue: null });
  readonly hasMore = toSignal(this.store.select(selectHasMore), { initialValue: false });
  readonly hasReviews = toSignal(this.store.select(selectHasReviews), { initialValue: false });
  readonly reviewSummary = computed(() => this.reviewListViewModel().summary);

  private readonly currentTargetId = this.store.selectSignal(selectTargetEntityId);
  private readonly currentTargetType = this.store.selectSignal(selectTargetEntityType);

  loadMyReviews(): void {
    this.store.dispatch(ReviewsActions.myReviewsPageOpened());
  }
  
  setContext(targetEntityId: string, targetEntityType: ReviewTargetEntityType): void {
    this.store.dispatch(ReviewsActions.contextSet({ targetEntityId, targetEntityType }));
  }

  // <-- DE FIX: updateFilters methode toegevoegd
  updateFilters(filters: Partial<ReviewFilters>): void {
    this.store.dispatch(ReviewsActions.filtersUpdated({ filters }));
    this.store.dispatch(ReviewsActions.loadMyReviews()); // Herlaad data met nieuwe filters
  }
  
  submitReview(payload: CreateReviewPayload): void {
    this.store.dispatch(ReviewsActions.reviewSubmitted({ payload }));
  }

  updateReview(reviewId: string, payload: UpdateReviewPayload): void {
    this.store.dispatch(ReviewsActions.reviewUpdateSubmitted({ reviewId, payload }));
  }

  deleteReview(reviewId: string): void {
    this.store.dispatch(ReviewsActions.reviewDeletionConfirmed({ reviewId }));
  }

  vote(reviewId: string, voteType: ReviewVoteType): void {
    this.store.dispatch(ReviewsActions.voteSubmitted({ reviewId, voteType }));
  }

  loadNextPage(): void {
    this.store.dispatch(ReviewsActions.nextPageLoaded());
  }
  
  loadReviews(): void {
    const targetEntityId = this.currentTargetId();
    const targetEntityType = this.currentTargetType();
    if (targetEntityId && targetEntityType) {
      this.store.dispatch(ReviewsActions.loadReviews({ targetEntityId, targetEntityType }));
    }
  }

  clearError(): void {
    this.store.dispatch(ReviewsActions.errorCleared());
  }

  resetState(): void {
    this.store.dispatch(ReviewsActions.stateReset());
  }
  
  private createInitialViewModel(): ReviewListViewModel {
    return {
      reviews: [], summary: null, isLoading: true, isSubmitting: false, error: null, totalCount: 0,
      filters: { sortBy: 'newest', pageNumber: 1, pageSize: 10 }, hasReviews: false
    };
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/core/src/lib/state/reviews.feature.ts ---
/**
 * @file reviews.feature.ts
 * @Version 9.1.0 (Definitive - ViewModel Aligned)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @description
 *   Definitive, stable NgRx feature for Reviews state. The ViewModel selector is now
 *   fully aligned with the needs of the UI components, providing all necessary properties.
 */
import { createFeature, createSelector, createReducer, on } from '@ngrx/store';
import { EntityState, createEntityAdapter } from '@ngrx/entity';
import { ReviewsActions } from './reviews.actions';
import { ReviewFilters, ReviewTargetEntityType } from '@royal-code/features/reviews/domain';
import { ReviewSummary } from '@royal-code/shared/domain';
import { StructuredError, SyncStatus } from '@royal-code/shared/domain';
import { ReviewWithUIState, ReviewListViewModel } from './reviews.types';

export const reviewAdapter = createEntityAdapter<ReviewWithUIState>();

export interface ReviewsState extends EntityState<ReviewWithUIState> {
  readonly targetEntityId: string | null;
  readonly targetEntityType: ReviewTargetEntityType | null;
  readonly summary: ReviewSummary | null;
  readonly totalCount: number;
  readonly currentPage: number;
  readonly hasMore: boolean;
  readonly filters: ReviewFilters;
  readonly isLoading: boolean;
  readonly isSubmitting: boolean;
  readonly error: StructuredError | null;
}

export const initialReviewsState: ReviewsState = reviewAdapter.getInitialState({
  targetEntityId: null, targetEntityType: null, summary: null,
  totalCount: 0, currentPage: 1, hasMore: true, filters: { sortBy: 'newest', pageNumber: 1, pageSize: 10 },
  isLoading: false, isSubmitting: false, error: null,
});

export const reviewsFeature = createFeature({
  name: 'reviews',
  reducer: createReducer(
    initialReviewsState,
    on(ReviewsActions.contextSet, (state, { targetEntityId, targetEntityType }) => ({ ...initialReviewsState, targetEntityId, targetEntityType, isLoading: true })),
    on(ReviewsActions.myReviewsPageOpened, (state) => ({ ...state, isLoading: true })),
    on(ReviewsActions.filtersUpdated, (state, { filters }) => ({ ...state, filters: { ...state.filters, ...filters }, isLoading: true })),
    on(ReviewsActions.loadReviews, (state) => ({ ...state, isLoading: true })),
    on(ReviewsActions.loadReviewsSuccess, (state, { reviews, totalCount, hasMore }) => reviewAdapter.setAll(reviews.map(r => ({ ...r, uiSyncStatus: SyncStatus.Synced })), { ...state, totalCount, hasMore, isLoading: false, currentPage: state.filters.pageNumber ?? 1 })),
    on(ReviewsActions.loadReviewsFailure, (state, { error }) => ({ ...state, isLoading: false, error })),
    on(ReviewsActions.loadSummarySuccess, (state, { summary }) => ({ ...state, summary })),
    on(ReviewsActions.createReviewSuccess, (state, { review }) => reviewAdapter.addOne({ ...review, uiSyncStatus: SyncStatus.Synced }, { ...state, isSubmitting: false, totalCount: state.totalCount + 1 })),
    on(ReviewsActions.updateReviewSuccess, (state, { reviewUpdate }) => reviewAdapter.updateOne(reviewUpdate, state)),
    on(ReviewsActions.deleteReviewSuccess, (state, { reviewId }) => reviewAdapter.removeOne(reviewId, { ...state, totalCount: state.totalCount - 1 })),
    on(ReviewsActions.voteSuccess, (state, { review }) => reviewAdapter.upsertOne({ ...review, uiSyncStatus: SyncStatus.Synced }, state)),
    on(ReviewsActions.stateReset, () => initialReviewsState),
    on(ReviewsActions.errorCleared, (state) => ({...state, error: null })),
  ),
  extraSelectors: ({ selectReviewsState }) => {
    const { selectAll, selectEntities, selectTotal } = reviewAdapter.getSelectors(selectReviewsState);
    const selectAllReviews = selectAll;
    const selectReviewEntities = selectEntities;
    const selectTargetEntityId = createSelector(selectReviewsState, (state) => state.targetEntityId);
    const selectTargetEntityType = createSelector(selectReviewsState, (state) => state.targetEntityType);
    const selectSummary = createSelector(selectReviewsState, (state) => state.summary);
    const selectIsLoading = createSelector(selectReviewsState, (state) => state.isLoading);
    const selectIsSubmitting = createSelector(selectReviewsState, (state) => state.isSubmitting);
    const selectError = createSelector(selectReviewsState, (state) => state.error);
    const selectTotalCount = createSelector(selectReviewsState, (state) => state.totalCount);
    const selectHasMore = createSelector(selectReviewsState, (state) => state.hasMore);
    const selectHasReviews = createSelector(selectTotalCount, (count) => count > 0);
    const selectFilters = createSelector(selectReviewsState, (state) => state.filters);

    const selectReviewListViewModel = createSelector(
      selectAllReviews, selectSummary, selectIsLoading, selectIsSubmitting, selectError, selectTotalCount, selectFilters, selectHasReviews,
      (reviews, summary, isLoading, isSubmitting, error, totalCount, filters, hasReviews): ReviewListViewModel => ({
        reviews, summary, isLoading, isSubmitting, error, totalCount, filters, hasReviews
      })
    );
    return {
      selectAllReviews, selectReviewEntities, selectReviewListViewModel, selectTargetEntityId, selectTargetEntityType,
      selectSummary, selectIsLoading, selectIsSubmitting, selectError, selectTotalCount, selectHasMore,
      selectHasReviews, selectFilters
    };
  }
});

export const {
  name: REVIEWS_FEATURE_KEY, reducer: reviewsReducer, selectAllReviews,
  selectReviewEntities, selectReviewListViewModel, selectTargetEntityId,
  selectTargetEntityType, selectSummary, selectIsLoading, selectIsSubmitting,
  selectError, selectTotalCount, selectHasMore, selectHasReviews, selectFilters
} = reviewsFeature;
--- END OF FILE ---

--- START OF FILE libs/features/reviews/core/src/lib/state/reviews.providers.ts ---
/**
 * @file reviews.providers.ts
 * @Version 1.0.0 (Modernized for createFeature)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-05
 * @GeneratedBy Royal-Code MonorepoAppDevAI
 * @GeneratedDate 2025-08-05
 * @PromptSummary "Generate a standalone provider function for the reviews feature, mirroring the new cart standard."
 * @Description
 *   Provides the complete reviews feature configuration using modern, standalone Angular providers.
 *   This function leverages the `reviewsFeature` object from `reviews.feature.ts` to register
 *   the state and effects, ensuring type safety and consistency. It should be used to
 *   register the feature, typically within a lazy-loaded route configuration.
 */
import { EnvironmentProviders, makeEnvironmentProviders } from '@angular/core';
import { provideState } from '@ngrx/store';
import { provideEffects } from '@ngrx/effects';

import { reviewsFeature } from './reviews.feature';
import { ReviewsEffects } from './reviews.effects';

export function provideReviewsFeature(): EnvironmentProviders {
  return makeEnvironmentProviders([
    provideState(reviewsFeature),
    provideEffects(ReviewsEffects)
  ]);
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/core/src/lib/state/reviews.types.ts ---
/**
 * @file reviews.types.ts
 * @version 4.2.0 (Definitive & Aligned)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @description
 *   Defines TypeScript types and interfaces for the reviews feature's NgRx state,
 *   now fully aligned with the needs of the UI components.
 */
import { Review, ReviewFilters } from '@royal-code/features/reviews/domain';
import { ReviewSummary } from '@royal-code/shared/domain';
import { SyncStatus, StructuredError } from '@royal-code/shared/domain';

export interface ReviewWithUIState extends Review {
  uiSyncStatus?: SyncStatus;
  uiError?: StructuredError | null;
  productName?: string;
  productImageUrl?: string;
  totalVotes?: number;
  likePercentage?: number;
  helpfulScore?: number;
}

export interface ReviewListViewModel {
  readonly reviews: readonly ReviewWithUIState[];
  readonly summary: ReviewSummary | null;
  readonly isLoading: boolean;
  readonly isSubmitting: boolean;
  readonly error: StructuredError | null;
  readonly totalCount: number;
  readonly filters: ReviewFilters;
  readonly hasReviews: boolean;
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/data-access-challenger/src/index.ts ---
export * from './lib/reviews-data-access-challenger/reviews-data-access-challenger.component';
--- END OF FILE ---

--- START OF FILE libs/features/reviews/data-access-challenger/src/lib/reviews-data-access-challenger/reviews-data-access-challenger.component.html ---
<p>ReviewsDataAccessChallenger works!</p>
--- END OF FILE ---

--- START OF FILE libs/features/reviews/data-access-challenger/src/lib/reviews-data-access-challenger/reviews-data-access-challenger.component.scss ---

--- END OF FILE ---

--- START OF FILE libs/features/reviews/data-access-challenger/src/lib/reviews-data-access-challenger/reviews-data-access-challenger.component.ts ---
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'challenger-reviews-data-access-challenger',
  imports: [CommonModule],
  templateUrl: './reviews-data-access-challenger.component.html',
  styleUrl: './reviews-data-access-challenger.component.scss',
})
export class ReviewsDataAccessChallengerComponent {}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/data-access-plushie/src/index.ts ---
/**
 * @file index.ts (data-access-plushie)
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-12
 * @Description
 *   Public API entry point for the Plushie Paradise reviews data-access library.
 *   This file exports the concrete service implementation for communication
 *   with the Plushie Paradise-specific backend API.
 */
export * from './lib/services/plushie-reviews-api.service';
--- END OF FILE ---

--- START OF FILE libs/features/reviews/data-access-plushie/src/lib/services/old_reviews-api.service.ts ---
/**
 * @deprecated
 * @file reviews-api.service.ts
 * @Version 1.3.1 (Final Review & Polish)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-06-10
 * @GeneratedBy Royal-Code MonorepoAppDevAI
 * @GeneratedDate 2025-06-10
 * @PromptSummary "Final review and polish of reviews API service with consistent error handling and proper return types."
 * @Description Clean, focused data-access service for all review API operations following established
 *              enterprise patterns. Proper error handling, consistent return types, and optimized for
 *              integration with NgRx effects layer. Maintains strict separation from NgRx concerns.
 */
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpParams, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError, tap } from 'rxjs/operators';

import {
  Review,
  ReviewSummary,
  ReviewFilters,
  CreateReviewPayload,
  UpdateReviewPayload,
  ReviewTargetEntityType,
} from '@royal-code/shared/domain';

import { APP_CONFIG } from '@royal-code/core/config';
import { LoggerService } from '@royal-code/core/logging';
import { ReviewsApiResponse } from '@royal-code/features/reviews/core';

/**
 * @file reviews-api.service.ts
 * @interface OldReviewsApiResponse
 * @description Response structure for paginated review list API endpoints.
 *              Matches the expected structure in effects for proper integration.
 */
export interface OldReviewsApiResponse {
  /** @description Array of review entities for the current page. */
  reviews: Review[];

  /** @description Total number of reviews available across all pages. */
  totalCount: number;

  /** @description Current page number (1-based indexing). */
  currentPage: number;

  /** @description Number of reviews per page. */
  pageSize: number;

  /** @description Whether additional pages are available for pagination. */
  hasMore: boolean;
}

/**
 * @Injectable ReviewsApiService
 * @description Enterprise-grade data-access service for review operations.
 *              Handles all HTTP communication with review API endpoints with comprehensive
 *              error handling and proper typing. Optimized for NgRx effects integration.
 */
@Injectable({
  providedIn: 'root'
})
export class ReviewsApiService {

  private readonly http = inject(HttpClient);
  private readonly config = inject(APP_CONFIG);
  private readonly logger = inject(LoggerService);

  private readonly apiUrl = this.config.apiUrl;

  private readonly logPrefix = '[ReviewsApiService]';

  // ==================================================================================
  // REVIEW DATA RETRIEVAL
  // ==================================================================================

  /**
   * @method getReviews
   * @description Fetches paginated and filtered reviews for a specific entity.
   *              Uses RESTful URL structure and comprehensive query parameter handling.
   * @param {string} entityId - The unique identifier of the entity being reviewed.
   * @param {ReviewTargetEntityType} entityType - The type classification of the entity.
   * @param {ReviewFilters} filters - Current filtering, sorting, and pagination configuration.
   * @returns {Observable<ReviewsApiResponse>} Observable emitting paginated reviews with metadata.
   */
  getReviews(
    entityId: string,
    entityType: ReviewTargetEntityType,
    filters: ReviewFilters
  ): Observable<ReviewsApiResponse> {

    this.logger.debug(`${this.logPrefix} Loading reviews`, {
      entityId,
      entityType,
      filters
    });

    // Build comprehensive query parameters
    let params = new HttpParams()
      .set('page', filters.page.toString())
      .set('pageSize', filters.pageSize.toString())
      .set('sortBy', filters.sortBy);

    // Add optional filter parameters only when specified
    if (filters.filterByRating !== undefined) {
      params = params.set('rating', filters.filterByRating.toString());
    }

    if (filters.filterByVerifiedPurchase !== undefined) {
      params = params.set('verified', filters.filterByVerifiedPurchase.toString());
    }

    // RESTful URL structure for entity-specific reviews
    const url = `${this.apiUrl}/${entityType}/${entityId}/reviews`;


    return this.http.get<ReviewsApiResponse>(url, { params }).pipe(
      tap(response => this.logger.debug(`${this.logPrefix} Reviews loaded successfully`, {
        count: response.reviews.length,
        totalCount: response.totalCount,
        hasMore: response.hasMore,
        currentPage: response.currentPage
      })),
      catchError(error => this.handleError(error, 'getReviews'))
    );
  }

  /**
   * @method getSummary
   * @description Fetches aggregated review statistics for a specific entity.
   *              Optimized for summary display components and dashboard widgets.
   * @param {string} entityId - The unique identifier of the entity.
   * @param {ReviewTargetEntityType} entityType - The type classification of the entity.
   * @returns {Observable<ReviewSummary>} Observable emitting comprehensive review statistics.
   */
  getSummary(entityId: string, entityType: ReviewTargetEntityType): Observable<ReviewSummary> {
    this.logger.debug(`${this.logPrefix} Loading summary`, { entityId, entityType });

    // RESTful endpoint for entity summary
    const url = `${this.apiUrl}/${entityType}/${entityId}/reviews/summary`;

    return this.http.get<ReviewSummary>(url).pipe(
      tap(summary => this.logger.debug(`${this.logPrefix} Summary loaded successfully`, {
        averageRating: summary.averageRating,
        totalReviews: summary.totalReviews,
        hasDistribution: !!summary.ratingDistribution
      })),
      catchError(error => this.handleError(error, 'getSummary'))
    );
  }

  // ==================================================================================
  // REVIEW CRUD OPERATIONS
  // ==================================================================================

  /**
   * @method createReview
   * @description Creates a new review via API submission with comprehensive validation.
   * @param {CreateReviewPayload} payload - Complete review data from user input.
   * @returns {Observable<Review>} Observable emitting the newly created review with server data.
   */
  createReview(payload: CreateReviewPayload): Observable<Review> {
    this.logger.debug(`${this.logPrefix} Creating review`, {
      targetEntityId: payload.targetEntityId,
      targetEntityType: payload.targetEntityType,
      rating: payload.rating,
      hasTitle: !!payload.title,
      hasMedia: !!(payload.mediaIds && payload.mediaIds.length > 0)
    });

    const createUrl = `${this.apiUrl}/reviews`;

    return this.http.post<Review>(createUrl, payload).pipe(
      tap(review => this.logger.info(`${this.logPrefix} Review created successfully`, {
        reviewId: review.id,
        authorId: review.profile.id,
        rating: review.rating
      })),
      catchError(error => this.handleError(error, 'createReview'))
    );
  }

  /**
   * @method updateReview
   * @description Updates an existing review with partial data changes.
   * @param {string} reviewId - The ID of the review to update.
   * @param {UpdateReviewPayload} payload - Partial review data to apply.
   * @returns {Observable<Review>} Observable emitting the updated review entity.
   */
  updateReview(reviewId: string, payload: UpdateReviewPayload): Observable<Review> {
    this.logger.debug(`${this.logPrefix} Updating review`, {
      reviewId,
      updatedFields: Object.keys(payload)
    });

    const url = `${this.apiUrl}/reviews/${reviewId}`;

    return this.http.patch<Review>(url, payload).pipe(
      tap(updatedReview => this.logger.info(`${this.logPrefix} Review updated successfully`, {
        reviewId,
        rating: updatedReview.rating,
        lastUpdated: updatedReview.updatedAt?.iso
      })),
      catchError(error => this.handleError(error, 'updateReview'))
    );
  }

  /**
   * @method deleteReview
   * @description Permanently removes a review from the system.
   * @param {string} reviewId - The ID of the review to delete.
   * @returns {Observable<void>} Observable that completes when deletion succeeds.
   */
  deleteReview(reviewId: string): Observable<void> {
    this.logger.debug(`${this.logPrefix} Deleting review`, { reviewId });

    const url = `${this.apiUrl}/reviews/${reviewId}`;

    return this.http.delete<void>(url).pipe(
      tap(() => this.logger.info(`${this.logPrefix} Review deleted successfully`, { reviewId })),
      catchError(error => this.handleError(error, 'deleteReview'))
    );
  }

/**
   * @method vote
   * @description Submits a 'like' or 'dislike' vote for a specific review.
   * @param {string} reviewId - The ID of the review to vote on.
   * @param {'like' | 'dislike'} voteType - The type of vote.
   * @returns {Observable<Review>} Observable emitting the updated review with new vote count.
   */
  vote(reviewId: string, voteType: 'like' | 'dislike'): Observable<Review> {
    this.logger.debug(`${this.logPrefix} Submitting ${voteType} vote`, { reviewId });

    const url = `${this.apiUrl}/reviews/${reviewId}/${voteType}`;

    return this.http.post<Review>(url, {}).pipe(
      tap(updatedReview => this.logger.info(`${this.logPrefix} ${voteType} vote submitted`, {
        reviewId,
        likes: updatedReview.likes,
        dislikes: updatedReview.dislikes,
      })),
      catchError(error => this.handleError(error, `vote:${voteType}`))
    );
  }



  // ==================================================================================
  // ERROR HANDLING & UTILITIES
  // ==================================================================================

  /**
   * @method handleError
   * @description Centralized error handling with comprehensive logging and context preservation.
   *              Throws structured errors for effects layer to process into user-friendly messages.
   * @param {HttpErrorResponse} error - The HTTP error response from the server.
   * @param {string} operation - The operation name that failed for debugging context.
   * @returns {Observable<never>} Observable that throws the enhanced error for effects processing.
   */
  private handleError(error: HttpErrorResponse, operation: string): Observable<never> {
    // Comprehensive error logging with operation context
    this.logger.error(`${this.logPrefix} ${operation} failed`, {
      operation,
      status: error.status,
      statusText: error.statusText,
      message: error.message,
      url: error.url,
      createdAt: new Date().toISOString()
    });

    // Log detailed error information for debugging
    if (error.error && typeof error.error === 'object') {
      this.logger.debug(`${this.logPrefix} Detailed error response`, {
        operation,
        errorDetails: error.error
      });
    }

    // Enhanced error object for effects layer processing
    const enhancedError = {
      ...error,
      operation, // Add operation context for effects
      createdAt: Date.now(),
      userMessage: this.generateUserFriendlyMessage(error, operation)
    };

    // Return throwError for effects to catch and process
    return throwError(() => enhancedError);
  }

  /**
   * @method generateUserFriendlyMessage
   * @description Generates user-friendly error messages based on HTTP status and operation context.
   * @param {HttpErrorResponse} error - The original HTTP error.
   * @param {string} operation - The operation that failed.
   * @returns {string} User-friendly error message.
   */
  private generateUserFriendlyMessage(error: HttpErrorResponse, operation: string): string {
    // Operation-specific error messages
    const operationMessages: Record<string, Record<number, string>> = {
      getReviews: {
        404: 'No reviews found for this item.',
        403: 'You do not have permission to view these reviews.',
        500: 'Unable to load reviews. Please try again later.'
      },
      createReview: {
        401: 'You need to be logged in to submit a review.',
        409: 'You have already reviewed this item.',
        422: 'Please check your review content and try again.'
      },
      updateReview: {
        403: 'You can only edit your own reviews.',
        404: 'Review not found or has been deleted.',
        422: 'Please check your review content.'
      },
      deleteReview: {
        403: 'You can only delete your own reviews.',
        404: 'Review not found or already deleted.'
      },
      vote: {
        401: 'You need to be logged in to vote.',
        403: 'You cannot vote on your own review.',
        409: 'You have already voted on this review.'
      }
    };

    // Try to get specific message for operation and status
    const specificMessage = operationMessages[operation]?.[error.status];
    if (specificMessage) {
      return specificMessage;
    }

    // Generic fallbacks based on status code
    if (error.status >= 500) {
      return 'Server error occurred. Please try again later.';
    } else if (error.status >= 400) {
      return error.error?.message || 'An error occurred. Please try again.';
    } else if (error.status === 0) {
      return 'Network error. Please check your connection.';
    }

    // Ultimate fallback
    return 'An unexpected error occurred. Please try again.';
  }

  // ==================================================================================
  // UTILITY METHODS (FOR TESTING AND DEBUGGING)
  // ==================================================================================

  /**
   * @method getApiHealthCheck
   * @description Simple health check endpoint for testing API connectivity.
   * @returns {Observable<{ status: string; createdAt: number }>} Health check response.
   */
  getApiHealthCheck(): Observable<{ status: string; createdAt: number }> {
    return this.http.get<{ status: string; createdAt: number }>(`${this.apiUrl}/health`).pipe(
      tap(() => this.logger.debug(`${this.logPrefix} API health check successful`)),
      catchError(error => this.handleError(error, 'healthCheck'))
    );
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/data-access-plushie/src/lib/services/plushie-reviews-api.service.ts ---
/**
 * @file plushie-reviews-api.service.ts
 * @Version 6.1.0 (DEFINITIVE - getReviewSummary removed, Aligned with Abstract API)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-08
 * @Description
 *   Definitive API service, now fully aligned with the AbstractReviewsApiService
 *   contract. The getReviewSummary method has been removed as per the backend
 *   architectural change, resolving the TS4113 error.
 */
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable, map, of, withLatestFrom } from 'rxjs';
import { APP_CONFIG } from '@royal-code/core/config';
import { AbstractReviewsApiService, ReviewsMappingService, BackendProductReviewsResponseDto, BackendReviewDto } from '@royal-code/features/reviews/core';
import { Review, ReviewTargetEntityType, CreateReviewPayload, UpdateReviewPayload, ReviewVoteType, ReviewFilters, ReviewListItemDto, ReviewSortBy } from '@royal-code/features/reviews/domain';
import { PaginatedList } from '@royal-code/shared/utils';
import { Store } from '@ngrx/store';
import { reviewsFeature } from 'libs/features/reviews/core/src/lib/state/reviews.feature';

@Injectable({ providedIn: 'root' })
export class PlushieReviewsApiService extends AbstractReviewsApiService {
  private readonly http = inject(HttpClient);
  private readonly config = inject(APP_CONFIG);
  private readonly mappingService = inject(ReviewsMappingService);
  private readonly reviewsApiUrl = `${this.config.backendUrl}/Reviews`;
  private readonly store = inject(Store);

  override getReviews(targetEntityId: string, targetEntityType: ReviewTargetEntityType, filters: ReviewFilters): Observable<BackendProductReviewsResponseDto> {
    const url = `${this.reviewsApiUrl}/product/${targetEntityId}/reviews`;
    
    const mappedSortBy = this.mapSortByToBackend(filters.sortBy);

    let params = new HttpParams()
      .set('pageNumber', (filters.pageNumber ?? 1).toString())
      .set('pageSize', (filters.pageSize ?? 10).toString())
      .set('sortBy', mappedSortBy);

    if (filters.filterByRating) {
      params = params.set('filterByRating', filters.filterByRating.toString());
    }
    if (filters.verifiedPurchasesOnly) {
      params = params.set('verifiedPurchasesOnly', 'true');
    }

    return this.http.get<BackendProductReviewsResponseDto>(url, { params });
  }

  // FIX: getReviewSummary is nu verwijderd, omdat deze niet langer in AbstractReviewsApiService staat
  // en de data wordt geleverd via getReviews().

  override createReview(payload: CreateReviewPayload): Observable<Review> {
    return this.http.post<BackendReviewDto>(this.reviewsApiUrl, payload).pipe(
      map(dto => this.mappingService.mapDtoToDomain(dto, payload.targetEntityId, payload.targetEntityType))
    );
  }
  
  override updateReview(reviewId: string, payload: UpdateReviewPayload): Observable<Review> {
    const url = `${this.reviewsApiUrl}/${reviewId}`;
    return this.http.put<BackendReviewDto>(url, payload).pipe(
      withLatestFrom(
        this.store.select(reviewsFeature.selectTargetEntityId),
        this.store.select(reviewsFeature.selectTargetEntityType)
      ),
      map(([dto, targetEntityId, targetEntityType]) => 
        this.mappingService.mapDtoToDomain(dto, targetEntityId || '', targetEntityType || ReviewTargetEntityType.PRODUCT)
      )
    );
  }


  override deleteReview(reviewId: string): Observable<void> {
    const url = `${this.reviewsApiUrl}/${reviewId}`;
    return this.http.delete<void>(url);
  }

  override vote(reviewId: string, voteType: ReviewVoteType): Observable<Review> {
    const url = `${this.reviewsApiUrl}/${reviewId}/vote/${voteType}`;
    return this.http.post<BackendReviewDto>(url, {}).pipe(
      withLatestFrom(
        this.store.select(reviewsFeature.selectTargetEntityId),
        this.store.select(reviewsFeature.selectTargetEntityType)
      ),
      map(([dto, targetEntityId, targetEntityType]) => 
        this.mappingService.mapDtoToDomain(dto, targetEntityId || '', targetEntityType || ReviewTargetEntityType.PRODUCT)
      )
    );
  }
  
  override getMyReviews(filters: ReviewFilters): Observable<PaginatedList<ReviewListItemDto>> {
    console.warn("getMyReviews is still mocked.");
    return of({ items: [], totalCount: 0, pageNumber: 1, totalPages: 0, hasNextPage: false, hasPreviousPage: false });
  }

  private mapSortByToBackend(sortBy: ReviewSortBy | undefined): string {
    switch (sortBy) {
      case 'newest': return 'Newest';
      case 'oldest': return 'Oldest';
      case 'highestRated': return 'HighestRated';
      case 'lowestRated': return 'LowestRated';
      case 'mostHelpful': return 'MostHelpful';
      default: return 'Newest';
    }
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/domain/src/index.ts ---
/**
 * @file index.ts (reviews-domain)
 * @Version 2.1.0 (Corrected Exports)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-01
 * @Description
 *   Public API entry point for the shared reviews domain library.
 *   Resolves all export ambiguities and provides a clean API.
 */

export * from './lib/review.model';
export * from './lib/review-list-item.model';
export * from './lib/review-mutation.model';
export * from './lib/review-filters.model';
--- END OF FILE ---

--- START OF FILE libs/features/reviews/domain/src/lib/review-filters.model.ts ---
/**
 * @file review-filters.model.ts
 * @Version 1.2.0 (Status Filter Added)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description Defines the filters for querying review collections, now including search functionality and status.
 */
import { ReviewStatus } from './review.model'; // Importeer ReviewStatus

export type ReviewSortBy = 'newest' | 'oldest' | 'highestRated' | 'lowestRated' | 'mostHelpful';

export interface ReviewFilters {
  pageNumber?: number;
  pageSize?: number;
  sortBy?: ReviewSortBy;
  filterByRating?: number;
  verifiedPurchasesOnly?: boolean;
  searchTerm?: string;
  status?: ReviewStatus;
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/domain/src/lib/review-list-item.model.ts ---
/**
 * @file review-list-item.model.ts
 * @Version 2.3.0 (Added userVote and helpfulScore)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-03
 * @Description Frontend DTO for a review item in a list, correctly handling nullability for avatar IDs and adding userVote and helpfulScore.
 */
import { DateTimeInfo } from '@royal-code/shared/base-models';
import { ReviewStatus, ReviewVoteType } from './review.model'; // Importeer ReviewVoteType

export interface ReviewListItemDto {
  readonly id: string;
  readonly rating: number;
  readonly title: string | null;
  readonly reviewText: string;
  readonly isVerifiedPurchase: boolean;
  readonly likes: number;
  readonly dislikes: number;
  readonly status: ReviewStatus; // Enum string, bijv. 'pending'
  readonly createdAt: DateTimeInfo; // ISO string
  readonly authorId: string;
  readonly authorDisplayName: string;
  readonly authorAvatarMediaId?: string | null; // Sta 'null' expliciet toe
  readonly mediaCount: number;
  readonly replyCount: number;
  readonly totalVotes: number;
  readonly likePercentage: number;
  readonly truncatedText: string;
  readonly targetEntityId: string; // Het ID van het product/entiteit waar de review over gaat
  readonly productName?: string; // Optioneel, voor weergave in lijsten
  readonly productImageUrl?: string; // Optioneel, voor weergave in lijsten
  readonly helpfulScore?: number; // << TOEGEVOEGD
  readonly userVote?: ReviewVoteType | null; // << TOEGEVOEGD
  readonly lastModified: DateTimeInfo; // << TOEGEVOEGD, omdat het in AuditableEntityBase zit
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/domain/src/lib/review-mutation.model.ts ---
/**
 * @file review-mutation.model.ts
 * @Version 2.1.0 (Writable Payload)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-01
 * @Description Payloads for creating and updating reviews, now 100% aligned with the Swagger API contract and allowing modification for construction.
 */
import { ReviewTargetEntityType } from "./review.model";

export interface CreateReviewPayload {
  readonly targetEntityId: string;
  readonly targetEntityType: ReviewTargetEntityType;
  readonly rating: number;
  title?: string; 
  readonly reviewText: string;
  readonly isVerifiedPurchase?: boolean;
  readonly mediaIds?: string[];
}

export interface UpdateReviewPayload {
  readonly rating?: number;
  title?: string; 
  readonly reviewText?: string;
  readonly mediaIds?: string[];
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/domain/src/lib/review.model.ts ---
/**
 * @file review.model.ts
 * @Version 4.2.0 (Definitive & Aligned)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-01
 * @Description Definitive domain models for Reviews, fully aligned.
 */
import { AuditableEntityBase, DateTimeInfo } from '@royal-code/shared/base-models';
import { Media, IUserStub, Image } from '@royal-code/shared/domain';

export enum ReviewTargetEntityType { PRODUCT = 'product' }
export enum ReviewStatus { Pending = 'pending', Approved = 'approved', Rejected = 'rejected', Flagged = 'flagged' }
export enum ReviewVoteType { Like = 'like', Dislike = 'dislike' }

export interface Review extends AuditableEntityBase {
  readonly id: string;
  readonly authorId: string;
  readonly profile: IUserStub;
  readonly targetEntityId: string;
  readonly targetEntityType: ReviewTargetEntityType;
  rating: number;
  title: string | null; // <-- FIX: Toegestaan null te zijn
  reviewText: string;
  isVerifiedPurchase: boolean;
  likes: number;
  dislikes: number;
  status: ReviewStatus;
  media?: ReadonlyArray<Media>;
  thumbnails?: ReadonlyArray<Image>;
  replyCount?: number;
  mediaCount?: number;
  userVote?: ReviewVoteType | null;
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/ui-challenger/src/index.ts ---
export * from './lib/reviews-ui-challenger/reviews-ui-challenger.component';
--- END OF FILE ---

--- START OF FILE libs/features/reviews/ui-challenger/src/lib/reviews-ui-challenger/reviews-ui-challenger.component.html ---
<p>ReviewsUiChallenger works!</p>
--- END OF FILE ---

--- START OF FILE libs/features/reviews/ui-challenger/src/lib/reviews-ui-challenger/reviews-ui-challenger.component.scss ---

--- END OF FILE ---

--- START OF FILE libs/features/reviews/ui-challenger/src/lib/reviews-ui-challenger/reviews-ui-challenger.component.ts ---
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'challenger-reviews-ui-challenger',
  imports: [CommonModule],
  templateUrl: './reviews-ui-challenger.component.html',
  styleUrl: './reviews-ui-challenger.component.scss',
})
export class ReviewsUiChallengerComponent {}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/ui-plushie/src/index.ts ---
/**
 * @file index.ts (ui-plushie)
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-12
 * @Description
 *   Public API entry point for the Plushie Paradise reviews UI feature library.
 *   This barrel file exports the route configuration and any components that
 *   absolutely must be exposed to other parts of the application (bij voorkeur geen).
 */

// The main export for lazy-loading the feature.
export * from './reviews-plushie.routes';

// Export components that are meant to be used dynamically by other services
// (e.g., an overlay service).
export * from './lib/components/create-review-form/create-review-form.component';
export * from './lib/components/review-list/review-list.component';
export * from './lib/components/review-summary/review-summary.component';
export * from './lib/components/review-card/review-card.component';
--- END OF FILE ---

--- START OF FILE libs/features/reviews/ui-plushie/src/lib/components/create-review-form/create-review-form.component.ts ---
/**
 * @file create-review-form.component.ts
 * @Version 3.2.0 (Definitive & Restored)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-28
 * @Description The definitive, fully functional component for creating/editing a review.
 *              This version restores all media upload logic, fixes styling issues for the overlay,
 *              and corrects all previously identified linting errors.
 */
import {
  ChangeDetectionStrategy, Component, inject, effect, signal,
  WritableSignal, computed, viewChild, ElementRef,
  DestroyRef
} from '@angular/core';
import { FormBuilder, FormControl, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { TranslateModule, TranslateService } from '@ngx-translate/core';

// UI components
import { UiRatingComponent } from '@royal-code/ui/rating';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiTextareaComponent } from '@royal-code/ui/textarea';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { UiParagraphComponent } from '@royal-code/ui/paragraph';
import { UiIconComponent } from '@royal-code/ui/icon';
import { AppIcon, Image, Media } from '@royal-code/shared/domain';
import { APP_CONFIG } from '@royal-code/core/config';

// Domain, Facade & DI Tokens
import { LoggerService } from '@royal-code/core/logging';
import { DYNAMIC_OVERLAY_DATA, DYNAMIC_OVERLAY_REF } from '@royal-code/ui/overlay';
import { Actions, ofType } from '@ngrx/effects';
import { CreateReviewPayload, Review as DomainReview, ReviewTargetEntityType, UpdateReviewPayload } from '@royal-code/features/reviews/domain';
import { ReviewsActions, ReviewsFacade, ReviewWithUIState } from '@royal-code/features/reviews/core';
import { AuthFacade } from '@royal-code/store/auth';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { NotificationService } from '@royal-code/ui/notifications';

interface ReviewFormData {
  targetEntityId: string;
  targetEntityType: ReviewTargetEntityType;
  reviewToEdit?: ReviewWithUIState;
}

interface ImagePreview {
  file: File;
  dataUrl: string;
  id: string;
}

@Component({
  selector: 'royal-code-create-review-form',
  standalone: true,
  imports: [
    ReactiveFormsModule, TranslateModule, UiRatingComponent,
    UiInputComponent, UiTextareaComponent, UiButtonComponent, UiSpinnerComponent,
    UiTitleComponent, UiParagraphComponent, UiIconComponent
  ],
  template: `
    <div class="p-6 sm:p-8 bg-card rounded-xl shadow-lg relative max-h-[90dvh] flex flex-col">
      <royal-code-ui-title
        [level]="TitleTypeEnum.H2"
        [text]="(isEditMode() ? 'reviewForm.editTitle' : 'reviewForm.title') | translate"
        extraClasses="mb-6 text-center"
      />

      <form [formGroup]="reviewForm" (ngSubmit)="onSubmit()" class="flex-grow flex flex-col overflow-y-auto pr-2 -mr-2">
        <div class="space-y-5">
          <!-- Rating -->
          <div>
            <label for="rating" class="block text-sm font-medium text-foreground mb-2">{{ 'reviewForm.ratingLabel' | translate }}<span class="text-error ml-1">*</span></label>
            <div class="flex items-center gap-2">
              <royal-code-ui-rating id="rating" formControlName="rating" />
              <span class="text-sm text-secondary">{{ ratingDisplayS() }}</span>
            </div>
             @if (ratingControl().invalid && (ratingControl().dirty || ratingControl().touched)) {
              <royal-code-ui-paragraph color="error" size="xs" extraClasses="mt-1 flex items-center gap-1.5" role="alert">
                <royal-code-ui-icon [icon]="AppIcon.AlertCircle" sizeVariant="xs" />
                {{ 'reviewForm.ratingRequired' | translate }}
              </royal-code-ui-paragraph>
            }
          </div>
          <!-- Title -->
          <div>
            <royal-code-ui-input formControlName="title" [label]="'reviewForm.reviewTitleLabel' | translate" [placeholder]="'reviewForm.reviewTitlePlaceholder' | translate" [error]="titleError()" />
          </div>
          <!-- Review Text -->
          <div>
            <royal-code-ui-textarea formControlName="reviewText" [label]="'reviewForm.reviewTextLabel' | translate" [placeholder]="'reviewForm.reviewTextPlaceholder' | translate" [rows]="5" [maxLength]="500" [showCharCounter]="true" [error]="reviewTextError()" />
          </div>
          <!-- Media Attachments -->
          <div>
            <div id="photo-label" class="block text-sm font-medium text-foreground mb-2">{{ 'reviewForm.addPhotosLabel' | translate }} ({{ selectedImagePreviews().length }} / {{ maxFiles() }})</div>
            <div class="flex flex-wrap gap-2 items-center" role="group" aria-labelledby="photo-label">
              @for (preview of selectedImagePreviews(); track preview.id) {
                <div class="relative w-20 h-20 border-2 border-border rounded-md overflow-hidden group">
                  <img [src]="preview.dataUrl" [alt]="preview.file.name" class="w-full h-full object-cover">
                  <button type="button" (click)="removeImagePreview(preview.id)" class="absolute top-0.5 right-0.5 bg-destructive/80 text-destructive-on rounded-full p-0.5 w-5 h-5 flex items-center justify-center" [attr.aria-label]="'Remove image ' + preview.file.name"><royal-code-ui-icon [icon]="AppIcon.X" sizeVariant="xs" /></button>
                </div>
              }
              @if (selectedImagePreviews().length < maxFiles()) {
                <button type="button" (click)="onAddPhotoClick()" class="w-20 h-20 border-2 border-dashed border-border rounded-md flex flex-col items-center justify-center text-secondary hover:bg-hover hover:border-primary transition-colors"><royal-code-ui-icon [icon]="AppIcon.Camera" sizeVariant="lg" /><span class="text-xs mt-1">{{ 'reviewForm.add' | translate }}</span></button>
              }
            </div>
            <input #fileInput type="file" [accept]="allowedImageTypes()" multiple class="hidden" (change)="onFileSelected($event)">
          </div>
        </div>
        <div class="flex-none flex justify-end gap-3 pt-6 mt-auto">
          <royal-code-ui-button type="outline" sizeVariant="md" (clicked)="onCancel()" [disabled]="isSubmitting()">{{ 'common.buttons.cancel' | translate }}</royal-code-ui-button>
          <royal-code-ui-button type="primary" sizeVariant="md" [htmlType]="'submit'" [disabled]="reviewForm.invalid || isSubmitting()" [enableNeonEffect]="true">
            @if (isSubmitting()) { <royal-code-ui-spinner size="sm" extraClasses="mr-2" /> }
            {{ (isEditMode() ? 'common.buttons.save' : 'reviewForm.submitButton') | translate }}
          </royal-code-ui-button>
        </div>
      </form>
      <button type="button" class="absolute top-4 right-4 text-secondary hover:text-foreground" (click)="onCancel()" [attr.aria-label]="'common.buttons.close' | translate"><royal-code-ui-icon [icon]="AppIcon.X" sizeVariant="md" /></button>
    </div>
  `,
  styles: [`
    :host {
      display: block;
      max-width: 600px;
      width: 100%;
      margin: auto;
      border: 3px solid red !important; /* TEMPORARY VISUAL DEBUG: Dit moet verschijnen */
    }
  `],

  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CreateReviewFormComponent {
  private readonly fb = inject(FormBuilder);
  private readonly reviewsFacade = inject(ReviewsFacade);
  private readonly authFacade = inject(AuthFacade);
  private readonly logger = inject(LoggerService);
  private readonly translate = inject(TranslateService);
  private readonly appConfig = inject(APP_CONFIG);
  private readonly formData = inject<ReviewFormData | null>(DYNAMIC_OVERLAY_DATA, { optional: true });
  private readonly overlayRef = inject(DYNAMIC_OVERLAY_REF);
  private readonly actions$ = inject(Actions);
  private readonly destroyRef = inject(DestroyRef);
  private readonly notificationService = inject(NotificationService);

  readonly TitleTypeEnum = TitleTypeEnum;
  readonly AppIcon = AppIcon;

  readonly reviewForm: FormGroup;
  readonly selectedImagePreviews = signal<ImagePreview[]>([]);
  private readonly fileInput = viewChild.required<ElementRef<HTMLInputElement>>('fileInput');
  readonly maxFiles = computed(() => this.appConfig.mediaUpload.maxFiles);
  readonly allowedImageTypes = computed(() => this.appConfig.mediaUpload.allowedImageTypes.join(','));
  readonly isSubmitting = this.reviewsFacade.isSubmitting;
  readonly submissionErrorS: WritableSignal<string | null> = signal(null);
  readonly isEditMode = signal(!!this.formData?.reviewToEdit);

  readonly ratingControl = computed(() => this.reviewForm.get('rating') as FormControl);
  readonly titleControl = computed(() => this.reviewForm.get('title') as FormControl);
  readonly reviewTextControl = computed(() => this.reviewForm.get('reviewText') as FormControl);

  readonly ratingDisplayS = computed(() => {
    const stars = (this.ratingControl().value ?? 0) / 2;
    return stars === 0 ? this.translate.instant('reviewForm.noRatingSelected') : this.translate.instant('reviewForm.starsDisplay', { stars: stars.toFixed(1) });
  });

  readonly titleError = computed(() => {
    const c = this.titleControl();
    if (c.invalid && (c.dirty || c.touched)) {
      if (c.hasError('maxlength')) return this.translate.instant('reviewForm.reviewTitleMaxLength', { maxLength: 100 });
    }
    return null;
  });
  readonly reviewTextError = computed(() => {
    const c = this.reviewTextControl();
    if (c.invalid && (c.dirty || c.touched)) {
      if (c.hasError('required')) return this.translate.instant('reviewForm.reviewTextRequired');
      if (c.hasError('minlength')) return this.translate.instant('reviewForm.reviewTextMinLength', { minLength: 10 });
    }
    return null;
  });

    constructor() {
    this.reviewForm = this.fb.nonNullable.group({
      rating: [0, [Validators.required, Validators.min(1)]],
      title: ['', [Validators.maxLength(100)]],
      reviewText: ['', [Validators.required, Validators.minLength(10), Validators.maxLength(500)]],
    });

    if (this.isEditMode() && this.formData?.reviewToEdit) {
      const review = this.formData.reviewToEdit;
      this.reviewForm.patchValue({
        // Rating omzetten van 1-5 naar 1-10 voor de slider
        rating: review.rating * 2,
        title: review.title ?? '',
        reviewText: review.reviewText,
      });
      // Als er bestaande media is, laad deze dan in de previews (voor edit, dit zou alleen thumbnails zijn)
      if (review.thumbnails && review.thumbnails.length > 0) {
        // Mock de ImagePreview structuur van de bestaande thumbnails voor weergave
        this.selectedImagePreviews.set(review.thumbnails.map((thumb: Image) => ({
          id: thumb.id,
          file: new File([], thumb.id, { type: 'image/jpeg' }), // Placeholder file
          dataUrl: thumb.variants[0].url,
        })));
      }
    }

    effect(() => {
      if (this.isSubmitting()) {
        this.reviewForm.disable();
      } else {
        this.reviewForm.enable();
      }
    });

    this.actions$.pipe(
      ofType(ReviewsActions.createReviewSuccess, ReviewsActions.updateReviewSuccess),
      takeUntilDestroyed(this.destroyRef)
    ).subscribe(() => {
      this.overlayRef.close({ submitted: true });
    });
  }

  onAddPhotoClick(): void { this.fileInput().nativeElement.click(); }
  onCancel(): void { this.overlayRef.close(); }

  onFileSelected(event: Event): void {
    const target = event.target as HTMLInputElement;
    const files = target.files;
    if (!files) return;

    const allowedTypes = this.appConfig.mediaUpload.allowedImageTypes;
    const maxSize = this.appConfig.mediaUpload.maxSizeMb * 1024 * 1024;
    const currentCount = this.selectedImagePreviews().length;
    const limit = Math.min(files.length, this.maxFiles() - currentCount);

    if (limit <= 0) {
      this.logger.warn(`[CreateReviewFormComponent] Max file limit of ${this.maxFiles()} reached.`);
      target.value = '';
      return;
    }

    const newPreviews: ImagePreview[] = [];
    for (let i = 0; i < limit; i++) {
      const file = files[i];
      if (allowedTypes.includes(file.type) && file.size <= maxSize) {
        const reader = new FileReader();
        const previewId = `${file.name}-${file.lastModified}-${Math.random().toString(36).substring(2)}`;
        reader.onload = (e: ProgressEvent<FileReader>) => {
          if (e.target?.result) {
            newPreviews.push({ file, dataUrl: e.target.result as string, id: previewId });
            if (newPreviews.length === limit) {
              this.selectedImagePreviews.update(existing => [...existing, ...newPreviews]);
            }
          }
        };
        reader.readAsDataURL(file);
      } else {
        this.logger.warn(`[CreateReviewFormComponent] Skipped invalid file: ${file.name}`);
      }
    }
    target.value = '';
  }

  removeImagePreview(previewId: string): void {
    this.selectedImagePreviews.update(previews => previews.filter(p => p.id !== previewId));
  }

    onSubmit(): void {
    if (this.reviewForm.invalid) {
      this.reviewForm.markAllAsTouched();
      return;
    }
    // Controleer of de gebruiker is ingelogd
    if (!this.authFacade.currentUserId()) {
      this.reviewsFacade.clearError(); // Wis eerdere fouten
      this.notificationService.showError(this.translate.instant('reviewForm.notLoggedInError'));
      return;
    }

    if (this.isEditMode()) {
      this.submitUpdate();
    } else {
      this.submitCreate();
    }
  }


   private submitCreate(): void {
    if (!this.formData) {
      this.logger.error("CreateReviewFormComponent: Missing form data for CREATE.");
      return;
    }
    const formValue = this.reviewForm.getRawValue();

    // --- DE FIX: Bouw de payload dynamisch om 'undefined' velden te verwijderen ---
    const payload: Partial<CreateReviewPayload> = {
      targetEntityId: this.formData.targetEntityId,
      targetEntityType: this.formData.targetEntityType,
      rating: formValue.rating / 2,
      reviewText: formValue.reviewText,
      mediaIds: [], // TODO: Integreren met een upload service
    };

    // Voeg 'title' alleen toe als het een niet-lege string is.
    if (formValue.title && formValue.title.trim() !== '') {
      payload.title = formValue.title;
    }
    
    // De 'isVerifiedPurchase' property wordt nu volledig weggelaten uit de payload.
    // De backend zal zijn default (waarschijnlijk 'null' voor een nullable boolean) gebruiken.
    
    this.reviewsFacade.submitReview(payload as CreateReviewPayload);
  }


  private submitUpdate(): void {
    const reviewToEdit = this.formData?.reviewToEdit;
    if (!reviewToEdit) {
      this.logger.error("CreateReviewFormComponent: In edit mode but no reviewToEdit data was provided.");
      return;
    }
    const formValue = this.reviewForm.getRawValue();
    const payload: UpdateReviewPayload = {
      rating: formValue.rating / 2,
      title: formValue.title,
      reviewText: formValue.reviewText,
      mediaIds: [],
    };
    this.reviewsFacade.updateReview(reviewToEdit.id, payload);
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/ui-plushie/src/lib/components/review-author-profile/review-author-profile.component.ts ---
/**
 * @file review-author-profile.component.ts
 * @Description Component for displaying a review author's profile, including avatar, name, level, and reputation.
 *              Acts as a composite component for `UiProfileImageComponent` and `UiParagraphComponent`.
 */
import { Component, ChangeDetectionStrategy, input, output } from '@angular/core';


import { UiProfileImageComponent } from '@royal-code/ui/media'; // Correct path
import { UiParagraphComponent } from '@royal-code/ui/paragraph';
import { Profile } from '@royal-code/shared/domain'; 

@Component({
  selector: 'lib-review-author-profile',
  standalone: true,
  imports: [
    UiProfileImageComponent,
    UiParagraphComponent,
],
  template: `
    <!-- Main wrapper div for avatar + text. This div is a flex container, not a fixed-size container. -->
    <!-- It is the clickable area, with accessibility attributes. -->
    <div
      class="flex items-center gap-3 cursor-pointer"
      tabindex="0"
      role="button"
      [attr.aria-label]="'Bekijk profiel van ' + (profile().displayName || 'gebruiker')"
      (click)="onAuthorClick()"
      (keydown.enter)="onAuthorClick()"
      (keydown.space)="onAuthorClick(); $event.preventDefault()"
    >
      <!-- UiProfileImageComponent: Internally handles its size (e.g., w-12 h-12 for 'lg'). -->
      <royal-code-ui-profile-image
        [source]="profile().avatar"
        [displayName]="profile().displayName"
        [size]="'xl'"
        [showStatus]="false"
        class="flex-shrink-0"
      />

      <!-- Text container: flex-grow makes it take available space. -->
      <div class="flex flex-col flex-grow min-w-0">
        <royal-code-ui-paragraph
          [text]="profile().displayName"
          size="md"
          color="foreground"
          extraClasses="font-semibold truncate"
        />

        @if (authorLevel()) {
          <royal-code-ui-paragraph
            [text]="'Level ' + authorLevel()"
            size="sm"
            color="primary"
            extraClasses="italic"
          />
        }

        @if (authorReputation()) {
          <royal-code-ui-paragraph
            [text]="'Reputatie: ' + authorReputation()"
            size="sm"
            color="primary"
          />
        }
      </div>
    </div>
  `,
  styles: [`
    :host {
      /* The host element wraps the internal div. It should simply display as a block. */
      display: block;
    }
  `],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class ReviewProfileComponent {
  readonly profile = input.required<Profile>();
  readonly authorLevel = input<number | undefined>();
  readonly authorReputation = input<number | undefined>();
  readonly authorClick = output<string>();

  onAuthorClick(): void {
    if (this.profile()?.id) {
      this.authorClick.emit(this.profile().id);
    }
  }
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/ui-plushie/src/lib/components/review-card/review-card.component.ts ---
/**
 * @file review-card.component.ts
 * @Version 6.0.0 (DEFINITIVE, ALL CRITICAL ERRORS FIXED)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-31
 * @Description The definitive, error-free presentational component for displaying a single review card.
 *              This version correctly handles all type mismatches, enum usage, and component inputs.
 */
import { ChangeDetectionStrategy, Component, computed, inject, input, output, booleanAttribute } from '@angular/core';
import { CommonModule, DatePipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { TranslateModule } from '@ngx-translate/core';

// Domain & UI Imports
import { Review as ReviewDomainModel, ReviewVoteType } from '@royal-code/features/reviews/domain';
import { AppIcon, Image, Media, MediaType, SyncStatus } from '@royal-code/shared/domain'; // Media hier geïmporteerd
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiDropdownComponent } from '@royal-code/ui/dropdown';
import { UiIconComponent } from '@royal-code/ui/icon';
import { UiImageComponent } from '@royal-code/ui/media';
import { UiParagraphComponent } from '@royal-code/ui/paragraph';
import { UiRatingComponent } from '@royal-code/ui/rating';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { MediaViewerService } from '@royal-code/ui/media';
import { ReviewProfileComponent } from '../review-author-profile/review-author-profile.component';
import { ReviewWithUIState } from '@royal-code/features/reviews/core';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { Profile } from '@royal-code/shared/domain';

@Component({
  selector: 'plushie-royal-code-review-card', // << DE FIX: Correcte selector naam
  standalone: true,
  imports: [
    CommonModule, DatePipe, TranslateModule, UiButtonComponent, UiDropdownComponent,
    UiIconComponent, UiImageComponent, UiParagraphComponent, UiRatingComponent,
    UiTitleComponent, ReviewProfileComponent, UiSpinnerComponent, RouterModule
  ],
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    @if(review(); as review) {
      <div class="bg-surface border border-border rounded-xl p-6 shadow-sm hover:shadow-md transition-all duration-200 group relative">
        <!-- Updating Overlay -->
        @if (isUpdating()) {
          <div class="absolute inset-0 bg-background/50 flex items-center justify-center z-10 rounded-xl">
            <royal-code-ui-spinner size="sm" />
          </div>
        }

        <!-- Header -->
        <div class="flex items-start justify-between gap-4 mb-4">
          @if(review.profile; as profile) {
            <lib-review-author-profile
              [profile]="profile"
              [authorLevel]="authorLevel()"
              [authorReputation]="authorReputation()"
              (authorClick)="authorClicked.emit($event)"
              class="flex-shrink-0" />
          }
          <div class="flex flex-col items-end gap-2 text-xs font-semibold mt-1">
            @if(helpfulScore() !== undefined && helpfulScore()! >= 0 && (review.likes + review.dislikes > 0)) {
              <div class="inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full"
                  [ngClass]="{
                    'bg-success/10 text-success border border-success/20': helpfulScore()! >= 70,
                    'bg-warning/10 text-warning border border-warning/20': helpfulScore()! < 70 && helpfulScore()! >= 40,
                    'bg-error/10 text-error border border-error/20': helpfulScore()! < 40
                  }">
                <royal-code-ui-icon [icon]="AppIcon.BarChart" sizeVariant="xs" />
                <span role="text">{{ helpfulScore() }}% {{ 'productDetail.reviewHelpful' | translate }}</span>
              </div>
            }
            @if (review.isVerifiedPurchase) {
              <div class="inline-flex items-center gap-1.5 px-2.5 py-1 bg-accent/10 text-accent border border-accent/20 rounded-full">
                <royal-code-ui-icon [icon]="AppIcon.BadgeCheck" sizeVariant="xs"/>
                <span role="text">{{ 'productDetail.verifiedPurchase' | translate }}</span>
              </div>
            }
          </div>
        </div>
        <!-- Rating & Date -->
        <div class="flex items-center justify-between mb-4">
          <div class="flex items-center gap-4">
            <royal-code-ui-rating [rating]="review.rating * 2" [readonly]="true" />
            <royal-code-ui-paragraph [text]="(review.createdAt?.iso | date:'d MMMM yyyy') || ''" size="sm" color="muted" extraClasses="font-medium" />
          </div>
          @if (review.likes > 0) {
            <div class="flex items-center gap-1.5 px-2 py-1 bg-accent/10 rounded-full">
              <royal-code-ui-icon [icon]="AppIcon.ThumbsUp" extraClass="mr-1.5" />
              <span>{{ review.likes }}</span>
            </div>
          }
        </div>

        <!-- Product Context (NEW) -->
        @if (showProductTitleLink() && review.productName && review.targetEntityId) {
            <div class="flex items-center gap-3 mb-4 p-3 bg-surface-alt rounded-md border border-border">
                @if (review.productImageUrl) {
                    <a [routerLink]="['/products', review.targetEntityId]" class="flex-shrink-0 w-12 h-12 rounded-md overflow-hidden border border-border">
                        <royal-code-ui-image [src]="review.productImageUrl" [alt]="review.productName" objectFit="cover" class="w-full h-full"/>
                    </a>
                }
                <a [routerLink]="['/products', review.targetEntityId]" class="font-semibold text-foreground hover:text-primary transition-colors">
                    {{ review.productName }}
                </a>
            </div>
        }

        <!-- Body -->
        @if (review.title) {
          <royal-code-ui-title [level]="TitleTypeEnum.H3" [text]="review.title" textColor="foreground" extraClasses="!text-lg !font-bold !mb-3 group-hover:text-primary transition-colors" />
        }
        <div class="mb-6">
          <royal-code-ui-paragraph [text]="review.reviewText" size="md" color="foreground" extraClasses="leading-relaxed whitespace-pre-line" />
        </div>
        <!-- Media -->
        @if (review.media && review.media.length > 0) {
            <div class="flex gap-3 overflow-x-auto pb-2 -mx-6 px-6">
              @for(mediaItem of review.media; track mediaItem.id) {
                @if (mediaItem.type === MediaType.IMAGE) {
                  <button type="button" class="flex-shrink-0 w-24 h-24 rounded-xs overflow-hidden border-2 border-border hover:border-primary transition-all hover:scale-105 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2" (click)="openLightbox(review.media, mediaItem.id)" [attr.aria-label]="'Bekijk grote versie van foto ' + ($index + 1)">
                    <royal-code-ui-image [image]="mediaItem" objectFit="cover" class="w-full h-full transition-transform duration-200" />
                  </button>
                }
              }
            </div>
        }
        <!-- Footer Actions -->
        <div class="flex items-center justify-between pt-4 border-t border-border">
          <div class="flex items-center gap-2">
            <royal-code-ui-button sizeVariant="sm" (clicked)="vote.emit(ReviewVoteType.Like)" [type]="review.userVote === ReviewVoteType.Like ? 'primary' : 'transparent'" [outline]="review.userVote === ReviewVoteType.Like" [enableNeonEffect]="review.userVote === ReviewVoteType.Like" [disabled]="isUpdating()">
              <royal-code-ui-icon [icon]="AppIcon.ThumbsUp" extraClass="mr-1.5" />
              <span>{{ review.likes }}</span>
            </royal-code-ui-button>
            <royal-code-ui-button sizeVariant="sm" (clicked)="vote.emit(ReviewVoteType.Dislike)" [type]="review.userVote === ReviewVoteType.Dislike ? 'theme-fire' : 'transparent'" [outline]="review.userVote === ReviewVoteType.Dislike" [enableNeonEffect]="review.userVote === ReviewVoteType.Dislike" [disabled]="isUpdating()">
              <royal-code-ui-icon [icon]="AppIcon.ThumbsDown" extraClass="mr-1.5" />
              <span>{{ review.dislikes }}</span>
            </royal-code-ui-button>
          </div>
          @if (review.profile) {
            <royal-code-ui-dropdown alignment="right" verticalAlignment="above">
              <button dropdown-trigger type="button" class="text-secondary hover:text-primary p-2 rounded-full hover:bg-hover -mr-2" [attr.aria-label]="'Meer acties voor review van ' + review.profile.displayName" [disabled]="isUpdating()">
                <royal-code-ui-icon [icon]="AppIcon.MoreVertical" sizeVariant="sm"/>
              </button>
              <div dropdown class="bg-card-primary border border-border rounded-xs shadow-lg py-1 w-40">
                @if (canEdit()) {
                  <button (click)="edit.emit()" class="w-full text-left px-3 py-1.5 text-sm flex items-center gap-2 hover:bg-hover text-foreground">
                    <royal-code-ui-icon [icon]="AppIcon.Edit" sizeVariant="xs" />
                    <span>{{ 'common.buttons.edit' | translate }}</span>
                  </button>
                }
                <button (click)="report.emit()" class="w-full text-left px-3 py-1.5 text-sm flex items-center gap-2 hover:bg-hover text-foreground">
                  <royal-code-ui-icon [icon]="AppIcon.Flag" sizeVariant="xs" />
                  <span>{{ 'common.report' | translate }}</span>
                </button>
                 @if(canDelete()) {
                    <button (click)="delete.emit()" class="w-full text-left px-3 py-1.5 text-sm flex items-center gap-2 hover:bg-hover text-error">
                        <royal-code-ui-icon [icon]="AppIcon.Trash2" sizeVariant="xs" />
                        <span>{{ 'common.delete' | translate }}</span>
                    </button>
                 }
              </div>
            </royal-code-ui-dropdown>
          }
        </div>
        <div class="absolute bottom-0 left-4 right-4 h-0.5 bg-gradient-to-r from-transparent via-primary/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
      </div>
    }
  `
})
export class PlushieReviewCardComponent {
  // --- INPUTS ---
  readonly review = input.required<ReviewWithUIState>();
  readonly canDelete = input(false, { transform: booleanAttribute });
  readonly canEdit = input(false, { transform: booleanAttribute });
  readonly showProductTitleLink = input(false, { transform: booleanAttribute }); 

  // --- OUTPUTS ---
  readonly vote = output<ReviewVoteType>(); // << DE FIX: Correct getypeerd als ReviewVoteType
  readonly report = output<void>();
  readonly delete = output<void>();
  readonly edit = output<void>();
  readonly authorClicked = output<string>();

  // --- PROTECTED PROPERTIES ---
  protected readonly AppIcon = AppIcon;
  protected readonly TitleTypeEnum = TitleTypeEnum;
  protected readonly ReviewVoteType = ReviewVoteType;
  protected readonly MediaType = MediaType;
  private readonly mediaViewerService = inject(MediaViewerService);

  // --- COMPUTED SIGNALS ---
  readonly isUpdating = computed(() => this.review().uiSyncStatus === SyncStatus.Syncing);
  readonly helpfulScore = computed(() => this.review().helpfulScore);
  readonly authorProfile = computed(() => this.review().profile);
  readonly authorLevel = computed(() => (this.authorProfile() as Profile)?.level);
 readonly authorReputation = computed(() => 0);

  // --- METHODS ---
  openLightbox(mediaItems: readonly Media[] | undefined, startWithId: string): void {
      if (!mediaItems || mediaItems.length === 0) return;
      const mutableImages = mediaItems.filter((m): m is Image => m.type === MediaType.IMAGE);
      const startIndex = mutableImages.findIndex(img => img.id === startWithId);
      if (mutableImages.length > 0) {
        this.mediaViewerService.openLightbox(mutableImages, Math.max(0, startIndex));
      }
  }

}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/ui-plushie/src/lib/components/review-list/review-list.component.ts ---
import { ChangeDetectionStrategy, Component, effect, inject, OnDestroy, ElementRef, viewChild, output } from '@angular/core'; // <-- DE FIX: 'output' geïmporteerd
import { CommonModule } from '@angular/common';

import { UiParagraphComponent } from '@royal-code/ui/paragraph';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';
import { PlushieReviewCardComponent } from '../review-card/review-card.component';
import { ReviewsFacade, ReviewWithUIState } from '@royal-code/features/reviews/core';
import { AuthFacade } from '@royal-code/store/auth';
import { NotificationService } from '@royal-code/ui/notifications';
import { TranslateService } from '@ngx-translate/core';
import { DynamicOverlayService } from '@royal-code/ui/overlay';
import { CreateReviewFormComponent } from '../create-review-form/create-review-form.component';
import { ReviewVoteType } from '@royal-code/features/reviews/domain';

@Component({
  selector: 'plushie-royal-code-review-list',
  standalone: true,
  imports: [ CommonModule, UiParagraphComponent, UiButtonComponent, UiSpinnerComponent, PlushieReviewCardComponent ],
  styles: [ `:host { display: block; width: 100%; }` ],
  template: `
    <div class="flex flex-col gap-6">
      @for (review of reviews(); track review.id) {
       <plushie-royal-code-review-card
          [review]="review"
          (vote)="onVote(review.id, $event)"
          (report)="onReport(review.id)"
          (delete)="onDelete(review.id)"
          (edit)="onEdit(review)"
          (authorClicked)="onAuthorClick($event)"
          [canDelete]="review.authorId === loggedInUserId()"
          [canEdit]="canUserEditReview(review)" />
      }
    </div>

    @if (isLoading() && reviews().length === 0) {
      <div class="flex justify-center p-8"><royal-code-ui-spinner></royal-code-ui-spinner></div>
    }
    @if (!isLoading() && !hasReviews()) {
      <div class="text-center p-8"><royal-code-ui-paragraph>No Reviews Yet</royal-code-ui-paragraph></div>
    }
    @if (error()) {
      <div class="text-center p-8"><royal-code-ui-paragraph color="error">{{ error()?.message }}</royal-code-ui-paragraph></div>
    }
    @if (hasMore() && !isLoading()) {
      <div #sentinel class="h-1"></div>
    }
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class ReviewListComponent implements OnDestroy {
  sentinel = viewChild<ElementRef>('sentinel');
  private readonly reviewsFacade = inject(ReviewsFacade);
  private readonly authFacade = inject(AuthFacade);
  private readonly notificationService = inject(NotificationService);
  private readonly EDIT_WINDOW_MILLISECONDS = 2 * 60 * 60 * 1000;

  readonly reviews = this.reviewsFacade.allReviews;
  readonly isLoading = this.reviewsFacade.isLoading;
  readonly error = this.reviewsFacade.error;
  readonly hasMore = this.reviewsFacade.hasMore;
  readonly hasReviews = this.reviewsFacade.hasReviews;
  readonly loggedInUserId = this.authFacade.currentUserId;

  private observer?: IntersectionObserver;

  // <-- DE FIX: Output toegevoegd voor de edit event
  readonly editReviewRequested = output<ReviewWithUIState>();

  constructor() {
    effect(() => {
      const sentinelEl = this.sentinel()?.nativeElement;
      this.observer?.disconnect();
      if (sentinelEl) { this.setupObserver(sentinelEl); }
    });
  }

  private setupObserver(element: HTMLElement): void {
    this.observer = new IntersectionObserver(([entry]) => {
      if (entry.isIntersecting && !this.isLoading()) { this.reviewsFacade.loadNextPage(); }
    }, { rootMargin: '200px' });
    this.observer.observe(element);
  }

  canUserEditReview(review: ReviewWithUIState): boolean {
    const isAuthor = review.authorId === this.loggedInUserId();
    if (!review.createdAt?.timestamp) return isAuthor;
    const createdWithinEditWindow = (Date.now() - review.createdAt.timestamp) < this.EDIT_WINDOW_MILLISECONDS;
    return isAuthor && createdWithinEditWindow;
  }

  // <-- DE FIX: onEdit methode emitteert de review
  onEdit(review: ReviewWithUIState): void {
    this.editReviewRequested.emit(review);
  }
  onVote(reviewId: string, voteType: ReviewVoteType): void { this.reviewsFacade.vote(reviewId, voteType); }
  onDelete(reviewId: string): void { this.reviewsFacade.deleteReview(reviewId); }
  onReport(reviewId: string): void { console.log('Report review:', reviewId); }
  onAuthorClick(authorId: string): void { console.log('Author clicked:', authorId); }
  
  ngOnDestroy(): void { this.observer?.disconnect(); }
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/ui-plushie/src/lib/components/review-summary/review-summary.component.ts ---
/**
 * @file product-review-summary.component.ts
 * @Version 1.2.0 (Dynamic i18n & Percentage Bar)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-15
 * @GeneratedBy Royal-Code MonorepoAppDevAI
 * @PromptSummary User requested to use UiPercentageBar and dynamic translation keys for star ratings in the review summary component.
 * @Description
 *   A presentational component that displays a summary of product reviews. This version now
 *   uses the simpler `UiPercentageBarComponent` for the rating distribution and constructs
 *   translation keys dynamically for star labels.
 */
import { Component, ChangeDetectionStrategy, computed, input, InputSignal, Signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { UiRatingComponent } from '@royal-code/ui/rating';
import { UiParagraphComponent } from '@royal-code/ui/paragraph';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { ReviewSummary } from '@royal-code/shared/domain';
import { TranslateModule } from '@ngx-translate/core';
import { UiPercentageBarComponent } from '@royal-code/ui/meters'; // <-- AANGEPASTE IMPORT

interface RatingDistributionItem {
  stars: 1 | 2 | 3 | 4 | 5;
  count: number;
  percentage: number;
}

@Component({
  selector: 'plushie-royal-code-review-summary',
  standalone: true,
  imports: [
    CommonModule, TranslateModule, UiRatingComponent, UiParagraphComponent,
    UiTitleComponent, UiPercentageBarComponent, // <-- AANGEPASTE IMPORT
  ],
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    @if (summary(); as reviewSummary) {
      <div class="grid grid-cols-1 md:grid-cols-3 gap-6 md:gap-8 items-center bg-surface p-6 rounded-xs border border-border">
        <!-- Left Side: Overall Rating -->
        <div class="flex flex-col items-center justify-center text-center border-b md:border-b-0 md:border-r border-border pb-6 md:pb-0 md:pr-8">
          <royal-code-ui-title [level]="TitleTypeEnum.H3" [text]="(reviewSummary.averageRating.toPrecision(2))" extraClasses="!text-4xl !font-bold !text-primary !mb-1" />
          <royal-code-ui-rating [rating]="reviewSummary.averageRating * 2" size="lg" [readonly]="true" />
          <royal-code-ui-paragraph color="muted" size="sm" extraClasses="mt-2">
            {{ 'reviews.summary.totalReviews' | translate: { count: reviewSummary.totalReviews } }}
          </royal-code-ui-paragraph>
        </div>

        <!-- Right Side: Rating Distribution -->
        <div class="md:col-span-2 flex flex-col gap-2">
          @for (item of ratingDistribution(); track item.stars) {
            <div class="grid grid-cols-[max-content_1fr_max-content] items-center gap-3 text-sm">
              <!-- Dynamische vertaalkey voor sterren -->
              <span class="text-secondary font-medium w-20">
                {{ 'reviews.stars.' + (item.stars === 1 ? '1star' : item.stars + 'stars') | translate }}
              </span>
              <!-- Gebruik UiPercentageBarComponent -->
              <royal-code-ui-percentage-bar
                [currentValue]="item.percentage"
                [maxValue]="100"
                [showValueText]="false"
                size="sm"
                [barColorClass]="'bg-primary'"
                [trackColorClass]="'bg-surface-alt'"
              />

              <span class="text-foreground font-semibold w-12 text-right">{{ item.percentage }}%</span>
            </div>
          }
        </div>
      </div>
    } @else {
      <div class="h-40 w-full bg-muted rounded-xs animate-pulse"></div>
    }
  `,
  styles: [` :host { display: block; } `],
})
export class ProductReviewSummaryComponent {
  readonly summary: InputSignal<ReviewSummary | undefined> = input.required<ReviewSummary | undefined>();
  protected readonly TitleTypeEnum = TitleTypeEnum;

  readonly ratingDistribution: Signal<RatingDistributionItem[]> = computed(() => {
    const s = this.summary();
    if (!s || s.totalReviews === 0) return [];

    const distribution: RatingDistributionItem[] = [];
    const starLevels: (1 | 2 | 3 | 4 | 5)[] = [5, 4, 3, 2, 1];

    for (const stars of starLevels) {
      const count = s.ratingDistribution[stars] ?? 0;
      const percentage = (count / s.totalReviews) * 100;
      distribution.push({
        stars: stars,
        count: count,
        percentage: Math.round(percentage),
        // De 'barConfig' is niet meer nodig
      });
    }
    return distribution;
  });
}
--- END OF FILE ---

--- START OF FILE libs/features/reviews/ui-plushie/src/reviews-plushie.routes.ts ---
/**
 * @file reviews-plushie.routes.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-12
 * @Description
 *   Defines the Angular routes for the Plushie Paradise Reviews feature. Since the reviews
 *   are typically displayed within other feature components (like ProductDetail), these
 *   routes primarily serve to provide the necessary NgRx state and effects for the feature
 *   to function correctly within its parent route's context.
 */
import { Routes } from '@angular/router';

export const PLUSHIE_REVIEWS_ROUTES: Routes = [
  {
    path: '',
  },
];
--- END OF FILE ---

--- START OF FILE libs/shared/utils/src/index.ts ---
// -- pipes --
export * from './lib/pipes/safe-async.pipe';
export * from './lib/pipes/safe-html.pipe';

// -- directives --
export * from './lib/directives/dynamic-title.directive';

// -- helpers --
export * from './lib/helpers/date-time-util.service';
export * from './lib/helpers/paginated-list.model';

// --- utils ----
export * from './lib/utils/skill.utils';
export * from './lib/utils/media.utils';
export * from './lib/utils/type-safety.utils';
export * from './lib/utils/entity-selector.utils';
export * from './lib/utils/type-safety.utils';

// -- resolvers --
export * from './lib/resolvers/i18n-init.resolver';

// --- services ---
export * from './lib/services/validation.service';
--- END OF FILE ---

--- START OF FILE libs/shared/utils/src/lib/directives/dynamic-title.directive.ts ---
/**
 * @file dynamic-title.directive.ts
 * @Version 1.2.0 (Definitive Content Projection Fix)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-18
 * @Description Angular directive to dynamically render an HTML element with a specified tag
 *              (e.g., h1-h6, p) and set its text content. This directive allows for
 *              semantic flexibility in components that need to display titles or text
 *              blocks where the exact HTML tag might vary based on input.
 *              It correctly prioritizes projected content (via ng-content in the host component)
 *              over its 'textContentForDirective' input by robustly detecting meaningful projected content.
 * @GeneratedBy Royal-Code MonorepoAppDevAI
 * @GeneratedDate 2025-08-18
 * @PromptSummary Fixed `DynamicTitleDirective` to correctly detect meaningful projected content by filtering out Angular's internal ng-container and comment nodes, resolving issues with empty paragraphs and titles.
 */
import {
  Directive,
  ElementRef,
  Input,
  OnChanges,
  Renderer2,
  SimpleChanges,
  AfterContentChecked,
  inject
} from '@angular/core';

@Directive({
  selector: '[libRoyalCodeDynamicTitle]',
  standalone: true,
})
export class DynamicTitleDirective implements OnChanges, AfterContentChecked {
  /**
   * @Input tag
   * @description The HTML tag to be rendered (e.g., 'h1', 'h2', 'p').
   * Defaults to 'p' if not specified.
   */
  @Input() tag: string = 'p';

  /**
   * @Input textContentForDirective
   * @description The text content to be displayed within the dynamic tag,
   *              but only if no *meaningful* content is projected into the host element via ng-content.
   */
  @Input() textContentForDirective: string = '';

  private hostElement: HTMLElement;
  private dynamicallyCreatedElement: HTMLElement | null = null;
  private previousTag: string = '';
  private previousTextContent: string = '';
  private hasMeaningfulProjectedContentCache: boolean | undefined = undefined;

  private elementRef = inject(ElementRef<HTMLElement>);
  private renderer = inject(Renderer2);

  constructor() {
    this.hostElement = this.elementRef.nativeElement;
  }

  ngOnChanges(changes: SimpleChanges): void {
    // Update if tag or text content input changes.
    // The actual rendering logic is deferred to AfterContentChecked to ensure
    // ng-content has been processed.
    if (changes['tag'] || changes['textContentForDirective']) {
      // Mark cache as dirty so AfterContentChecked will re-evaluate
      this.hasMeaningfulProjectedContentCache = undefined;
      // If tag changes, we must recreate the element.
      if (changes['tag'] && changes['tag'].currentValue !== changes['tag'].previousValue) {
        this.recreateDynamicElement();
      }
    }
  }

  ngAfterContentChecked(): void {
    // This hook runs after ng-content has been checked.
    // It's a suitable place to check for projected content and update text.
    const currentMeaningfulProjectedContent = this.checkForMeaningfulProjectedContent();

    if (this.hasMeaningfulProjectedContentCache === undefined ||
        this.hasMeaningfulProjectedContentCache !== currentMeaningfulProjectedContent ||
        this.previousTextContent !== this.textContentForDirective ||
        !this.dynamicallyCreatedElement || // Element might have been recreated
        (this.dynamicallyCreatedElement && this.dynamicallyCreatedElement.tagName.toLowerCase() !== this.tag.toLowerCase()) // Tag might have changed
       ) {

      this.hasMeaningfulProjectedContentCache = currentMeaningfulProjectedContent;
      this.previousTextContent = this.textContentForDirective;

      if (!this.dynamicallyCreatedElement || this.dynamicallyCreatedElement.tagName.toLowerCase() !== this.tag.toLowerCase()) {
        this.recreateDynamicElement();
      }
      this.updateElementContent();
    }
  }

  /**
   * @method recreateDynamicElement
   * @description Removes the existing dynamically created element (if any) and creates a new one
   *              with the current `tag`. This is called when the `tag` input changes.
   * @private
   */
  private recreateDynamicElement(): void {
    if (this.dynamicallyCreatedElement && this.hostElement.contains(this.dynamicallyCreatedElement)) {
      this.renderer.removeChild(this.hostElement, this.dynamicallyCreatedElement);
    }
    this.dynamicallyCreatedElement = this.renderer.createElement(this.tag.toLowerCase());
    this.renderer.appendChild(this.hostElement, this.dynamicallyCreatedElement);
    this.previousTag = this.tag.toLowerCase();
  }

  /**
   * @method checkForMeaningfulProjectedContent
   * @description Determines if there is *meaningful* content projected into the host element.
   *              Ignores Angular's internal comment nodes and empty text nodes or structural element wrappers.
   * @returns {boolean} True if meaningful projected content is found, false otherwise.
   * @private
   */
  private checkForMeaningfulProjectedContent(): boolean {
    const childNodes = Array.from(this.hostElement.childNodes);
    for (const node of childNodes) {
      // Ignore the element created by this directive itself.
      if (node === this.dynamicallyCreatedElement) {
        continue;
      }

      // Ignore Angular's internal comment nodes (e.g., <!--container--> from ng-content)
      if (node.nodeType === Node.COMMENT_NODE) {
        continue;
      }

      // If it's a text node, check if it contains actual non-whitespace content.
      if (node.nodeType === Node.TEXT_NODE) {
        if (node.textContent && node.textContent.trim().length > 0) {
          return true; // Found meaningful text content
        }
        continue; // Ignore empty text nodes (e.g., just whitespace)
      }

      // If it's an element node, check if it's not an Angular internal structural element
      // (like ng-container or ng-template) and if it contains any content.
      if (node.nodeType === Node.ELEMENT_NODE) {
        const tagName = (node as HTMLElement).tagName.toLowerCase();
        // Explicitly ignore common Angular structural elements that might be empty wrappers
        if (tagName === 'ng-container' || tagName === 'ng-template' || tagName.startsWith('ng-')) {
          continue;
        }
        // For other actual element nodes, assume it's meaningful projected content
        // if it has children or non-whitespace text content itself.
        const element = node as HTMLElement;
        if (element.children.length > 0 || (element.textContent ?? '').trim().length > 0) {
            return true;
        }
      }
    }
    return false;
  }

  /**
   * @method updateElementContent
   * @description Sets the textContent of the dynamically created element, but only if
   *              no *meaningful* content has been projected into the host element.
   * @private
   */
  private updateElementContent(): void {
    if (!this.dynamicallyCreatedElement) {
      return;
    }

    if (this.hasMeaningfulProjectedContentCache) {
      // If there's meaningful projected content, clear our dynamic element's text.
      // The projected content should then be rendered by Angular directly into this element.
      // We only clear if there's actual text to clear to avoid unnecessary DOM operations.
      if (this.dynamicallyCreatedElement.textContent !== '') {
        this.renderer.setProperty(this.dynamicallyCreatedElement, 'textContent', '');
      }
    } else {
      // No meaningful projected content, so use textContentForDirective.
      // Only update if the content has actually changed to avoid unnecessary DOM operations.
      if (this.dynamicallyCreatedElement.textContent !== this.textContentForDirective) {
        this.renderer.setProperty(
          this.dynamicallyCreatedElement,
          'textContent',
          this.textContentForDirective
        );
      }
    }
  }
}
--- END OF FILE ---

--- START OF FILE libs/shared/utils/src/lib/helpers/date-time-util.service.ts ---
// libs/shared/utils/src/lib/helpers/date-time-util.service.ts
/**
 * @file date-time-util.service.ts
 * @Version 1.1.0 - Added factory function `createDateTimeInfo`.
 * @Author ChallengerAppDevAI
 * @Description Provides utility functions for creating and manipulating DateTimeInfo objects.
 */
import { Injectable } from '@angular/core';
import { DateTimeInfo } from '@royal-code/shared/base-models';
import { DateTime } from 'luxon'; 

@Injectable({
  providedIn: 'root'
})
export class DateTimeUtil {

  /**
   * Creates a DateTimeInfo object from a Date object, Date string, or Unix timestamp (milliseconds).
   * Ensures dates are treated as UTC for ISO string and timestamp generation.
   * @param dateInput - The Date object, ISO string, or timestamp (in ms). If undefined, defaults to current UTC time.
   * @param timezoneId - Optional: IANA timezone identifier (e.g., "Europe/Amsterdam"). If provided, 'formatted' will reflect this.
   * @returns A DateTimeInfo object.
   */
  static createDateTimeInfo(
    dateInput?: Date | string | number,
    timezoneId?: string
  ): DateTimeInfo {
    let dt: DateTime;

    if (dateInput instanceof Date) {
      dt = DateTime.fromJSDate(dateInput).toUTC();
    } else if (typeof dateInput === 'string') {
      dt = DateTime.fromISO(dateInput, { zone: 'utc' });
      if (!dt.isValid) {
        // Probeer als RFC 2822 of HTTP datum als ISO faalt
        dt = DateTime.fromRFC2822(dateInput, { zone: 'utc' });
        if (!dt.isValid) {
          dt = DateTime.fromHTTP(dateInput, { zone: 'utc' });
        }
      }
    } else if (typeof dateInput === 'number') {
      dt = DateTime.fromMillis(dateInput, { zone: 'utc' });
    } else {
      dt = DateTime.utc(); // Default to current UTC time
    }

    if (!dt.isValid) {
      console.warn(`[DateTimeUtil] Invalid dateInput for createDateTimeInfo: ${dateInput}. Falling back to current UTC time.`);
      dt = DateTime.utc(); // Fallback
    }

    // Formatteer met Luxon voor meer controle, indien een timezoneId is meegegeven
    let formattedString: string | undefined;
    if (timezoneId) {
      formattedString = dt.setZone(timezoneId).toFormat('dd LLLL yyyy, HH:mm ZZZZ'); // 'LLLL' voor volledige maandnaam
    } else {
      // Standaard UTC format als geen specifieke timezoneId
      formattedString = dt.toFormat('dd LLLL yyyy, HH:mm \'UTC\'');
    }

    return {
      iso: dt.toISO() as string,
      timestamp: dt.toMillis(),
      utcOffsetMinutes: dt.offset, // dt.offset is number, dus dit is correct
      formatted: formattedString,
      timezoneId: timezoneId ?? dt.zoneName ?? undefined
    };
  }

  /**
   * Converteert een ISO-string naar een DateTimeInfo object.
   * Behandelt de input als UTC.
   * @param isoString - De ISO 8601 string.
   * @returns Een DateTimeInfo object.
   */
  static fromISO(isoString: string): DateTimeInfo {
    return DateTimeUtil.createDateTimeInfo(isoString);
  }

  /**
   * Converteert een Unix timestamp (in milliseconden) naar een DateTimeInfo object.
   * Behandelt de input als UTC.
   * @param timestamp - De timestamp in milliseconden.
   * @returns Een DateTimeInfo object.
   */
  static fromTimestamp(timestamp: number): DateTimeInfo {
    return DateTimeUtil.createDateTimeInfo(timestamp);
  }

  /**
   * Geeft het huidige DateTimeInfo object terug, gebaseerd op UTC tijd.
   * @returns Een DateTimeInfo object voor het huidige moment in UTC.
   */
  static now(): DateTimeInfo {
    return DateTimeUtil.createDateTimeInfo(); // Zonder argument, default naar nu
  }

  /**
   * Utility om een DateTimeInfo object te formatteren naar een specifieke string,
   * gebruikmakend van Luxon's formatting tokens en optioneel een timezone.
   * @param dateTimeInfo - Het DateTimeInfo object om te formatteren.
   * @param formatString - De Luxon format string (e.g., 'DDDD, HH:mm').
   * @param timezoneId - Optioneel: IANA timezone om naar te converteren voor formattering.
   * @returns De geformatteerde datum/tijd string, of de ISO string bij een fout.
   */
  static format(dateTimeInfo: DateTimeInfo, formatString: string, timezoneId?: string): string {
    try {
      let dt = DateTime.fromISO(dateTimeInfo.iso, { zone: 'utc' }); // Start vanuit UTC ISO
      if (timezoneId) {
        dt = dt.setZone(timezoneId); // Converteer naar doel timezone voor formattering
      }
      return dt.toFormat(formatString);
    } catch (e) {
      console.error(`[DateTimeUtil] Error formatting DateTimeInfo:`, e, dateTimeInfo);
      return dateTimeInfo.iso; // Fallback
    }
  }
}
--- END OF FILE ---

--- START OF FILE libs/shared/utils/src/lib/helpers/paginated-list.model.ts ---
/**
 * @file paginated-list.model.ts
 * @Version 2.0.0 (Synchronized with Backend DTO)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-07-19
 * @Description Defines the generic, reusable interface for paginated data responses
 *              from the backend, now fully aligned with the backend's DTO structure.
 */
export interface PaginatedList<T> {
  readonly items: readonly T[];
  readonly totalCount: number;
  readonly pageNumber: number; // Hernoemd van pageIndex voor consistentie
  readonly totalPages: number;
  readonly hasNextPage: boolean;
  readonly hasPreviousPage: boolean;
}
--- END OF FILE ---

--- START OF FILE libs/shared/utils/src/lib/pipes/safe-async.pipe.ts ---
import { ChangeDetectorRef, Pipe, PipeTransform, OnDestroy } from '@angular/core';
import { AsyncPipe } from '@angular/common';
import { Observable } from 'rxjs';

@Pipe({
  name: 'safeAsync',
  pure: false,
  standalone: true,
})
export class SafeAsyncPipe implements PipeTransform, OnDestroy {
  private asyncPipe: AsyncPipe;

  constructor(private cdr: ChangeDetectorRef) {
    this.asyncPipe = new AsyncPipe(this.cdr);
  }

  transform<T>(obj: Observable<T>): T {
    const value = this.asyncPipe.transform(obj);
    if (value === null || value === undefined) {
      return {} as T; // Return an empty object or appropriate default value
    }
    return value;
  }

  ngOnDestroy() {
    if (this.asyncPipe) {
      this.asyncPipe.ngOnDestroy();
    }
  }
}
--- END OF FILE ---

--- START OF FILE libs/shared/utils/src/lib/pipes/safe-html.pipe.ts ---
/**
 * @file safe-html.pipe.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-02
 * @Description
 *   Een pipe om HTML-inhoud of URL's veilig te markeren voor weergave in Angular,
 *   waarbij XSS-risico's worden beperkt door DomSanitizer te gebruiken.
 * @GeneratedBy Royal-Code MonorepoAppDevAI
 * @GeneratedDate 2025-09-02
 * @PromptSummary "Compilerfouten oplossen: 'bullet-list' type, ReviewSummary properties, en UI component imports."
 */
import { Pipe, PipeTransform, inject } from '@angular/core';
import { DomSanitizer, SafeHtml, SafeResourceUrl } from '@angular/platform-browser';

@Pipe({
  name: 'safeHtml',
  standalone: true,
})
export class SafeHtmlPipe implements PipeTransform {
  private readonly sanitizer = inject(DomSanitizer);

  transform(value: string | null | undefined, type: 'html' | 'url' | 'resourceUrl' = 'html'): SafeHtml | SafeResourceUrl {
    if (!value) return '';
    switch (type) {
      case 'html': return this.sanitizer.bypassSecurityTrustHtml(value);
      case 'url': return this.sanitizer.bypassSecurityTrustUrl(value);
      case 'resourceUrl': return this.sanitizer.bypassSecurityTrustResourceUrl(value);
      default: return this.sanitizer.bypassSecurityTrustHtml(value);
    }
  }
}
--- END OF FILE ---

--- START OF FILE libs/shared/utils/src/lib/resolvers/i18n-init.resolver.ts ---
/**
 * @file i18n-init.resolver.ts
 * @Version 1.2.0 (Added Logging)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-31
 * @description Een resolver die ervoor zorgt dat de i18n-vertalingen zijn geladen
 *              voordat de applicatie wordt weergegeven. Lost FOUC op en is null-safe.
 */
import { inject } from '@angular/core';
import { ResolveFn } from '@angular/router';
import { TranslateService } from '@ngx-translate/core';
import { firstValueFrom } from 'rxjs';
import { LoggerService } from '@royal-code/core/logging'; // <<< TOEGEVOEGD

export const i18nInitResolver: ResolveFn<boolean> = () => {
  const translateService = inject(TranslateService);
  const logger = inject(LoggerService); // <<< TOEGEVOEGD
  const langToUse = translateService.currentLang || translateService.defaultLang || 'en';

  logger.info(`[i18nInitResolver] Initializing i18n with language: ${langToUse}`); // <<< TOEGEVOEGD

  return firstValueFrom(translateService.use(langToUse)).then(() => {
    logger.info(`[i18nInitResolver] i18n successfully initialized for language: ${langToUse}`); // <<< TOEGEVOEGD
    return true;
  }).catch(error => {
    logger.error(`[i18nInitResolver] Failed to initialize i18n for language: ${langToUse}`, error); // <<< TOEGEVOEGD
    return false;
  });
};
--- END OF FILE ---

--- START OF FILE libs/shared/utils/src/lib/services/validation.service.ts ---
/**
 * @file validation.service.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-07
 * @Description A reusable service to extract user-friendly validation errors from a FormGroup.
 */
import { Injectable, inject } from '@angular/core';
import { FormGroup, AbstractControl, FormArray } from '@angular/forms';
import { TranslateService } from '@ngx-translate/core';

export interface ValidationError {
  label: string;
  message: string;
}

@Injectable({ providedIn: 'root' })
export class ValidationService {
  private readonly translate = inject(TranslateService);

  /**
   * Recursively traverses a FormGroup and returns a list of all validation errors.
   * @param formGroup The FormGroup to inspect.
   * @param controlLabels A map of control names/paths to their translation keys.
   * @returns An array of ValidationError objects.
   */
  public getFormErrors(formGroup: FormGroup, controlLabels: Record<string, string>): ValidationError[] {
    const errors: ValidationError[] = [];
    this.findErrorsRecursive(formGroup, controlLabels, errors);
    return errors;
  }

  private findErrorsRecursive(
    control: AbstractControl,
    labels: Record<string, string>,
    errorList: ValidationError[],
    path = ''
  ): void {
    if (control instanceof FormGroup) {
      Object.keys(control.controls).forEach(key => {
        const newPath = path ? `${path}.${key}` : key;
        this.findErrorsRecursive(control.get(key) as AbstractControl, labels, errorList, newPath);
      });
    } else if (control instanceof FormArray) {
      control.controls.forEach((c, index) => {
        const newPath = `${path}[${index}]`; // We gebruiken dit pad niet direct voor labels, maar het is goed voor debuggen
        this.findErrorsRecursive(c, labels, errorList, newPath);
      });
    }

    if (control.invalid && control.errors) {
      const labelKey = labels[path] || path;
      const label = this.translate.instant(labelKey);
      
      Object.keys(control.errors).forEach(errorKey => {
        // Alleen de eerste fout per veld tonen om de gebruiker niet te overweldigen.
        if (!errorList.some(e => e.label === label)) {
           errorList.push({
            label,
            message: this.getErrorMessageForError(errorKey),
          });
        }
      });
    }
  }

  private getErrorMessageForError(errorKey: string): string {
    // Deze switch kan worden uitgebreid met meer specifieke validatieregels
    switch (errorKey.toLowerCase()) {
      case 'required':
        return this.translate.instant('common.errors.validation.requiredField');
      case 'email':
        return this.translate.instant('common.errors.validation.invalidEmail');
      case 'min':
        // Hier zou je de error value kunnen gebruiken: `control.errors['min'].min`
        return this.translate.instant('common.errors.validation.minValue');
      case 'priceinvalid':
         return this.translate.instant('admin.products.form.priceCannotBeHigherThanOriginal');
      default:
        return this.translate.instant('common.errors.validation.invalidField');
    }
  }
}
--- END OF FILE ---

--- START OF FILE libs/shared/utils/src/lib/utils/entity-selector.utils.ts ---
/**
 * @file entity-selector.utils.ts
 * @Version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Description
 *   Utility functies voor het veilig maken van NgRx Entity selectors.
 *   Voorkomt de "ids is undefined" runtime errors die optreden tijdens
 *   state initialisatie race conditions.
 */
import { createSelector, MemoizedSelector } from '@ngrx/store';
import { EntityAdapter, EntityState } from '@ngrx/entity';

/**
 * Maakt veilige entity selectors die beschermd zijn tegen undefined state
 */
export function createSafeEntitySelectors<T extends { id: string | number }, S extends EntityState<T>>(
  adapter: EntityAdapter<T>,
  stateSelector: MemoizedSelector<any, S | undefined>
) {
  const adapterSelectors = adapter.getSelectors();

  /**
   * Helper functie voor het maken van veilige entity selectors
   */
  function createSafeSelector<R>(
    adapterSelector: (state: EntityState<T>) => R,
    fallbackValue: R,
    selectorName?: string
  ) {
    return createSelector(
      stateSelector,
      (state: S | undefined): R => {
        // Controleer of state bestaat en correct geïnitialiseerd is
        if (!state) {
          console.debug(`[EntitySelector] State is undefined for ${selectorName || 'unknown selector'}, returning fallback`);
          return fallbackValue;
        }

        // Controleer of de EntityState correct geïnitialiseerd is
        if (!state.ids || state.ids === undefined) {
          console.debug(`[EntitySelector] EntityState.ids is undefined for ${selectorName || 'unknown selector'}, returning fallback`);
          return fallbackValue;
        }

        // Extra veiligheid: try-catch voor onverwachte errors
        try {
          return adapterSelector(state);
        } catch (error) {
          console.warn(`[EntitySelector] Selector ${selectorName || 'unknown'} failed:`, error);
          return fallbackValue;
        }
      }
    );
  }

  return {
    selectAll: createSafeSelector(
      adapterSelectors.selectAll,
      [] as T[],
      'selectAll'
    ),
    selectEntities: createSafeSelector(
      adapterSelectors.selectEntities,
      {} as Record<string | number, T>,
      'selectEntities'
    ),
    selectIds: createSafeSelector(
      adapterSelectors.selectIds,
      [] as (string | number)[],
      'selectIds'
    ),
    selectTotal: createSafeSelector(
      adapterSelectors.selectTotal,
      0,
      'selectTotal'
    ),

    /**
     * Veilige selector voor het ophalen van een specifieke entity
     */
    selectById: (id: string | number) => createSelector(
      createSafeSelector(
        adapterSelectors.selectEntities,
        {} as Record<string | number, T>,
        'selectEntities'
      ),
      (entities) => entities[id] || null
    ),

    /**
     * Veilige selector die checkt of een entity bestaat
     */
    selectExists: (id: string | number) => createSelector(
      createSafeSelector(
        adapterSelectors.selectIds,
        [] as (string | number)[],
        'selectIds'
      ),
      (ids) => ids.includes(id)
    )
  };
}

/**
 * Utility functie voor het valideren van EntityState
 */
export function isValidEntityState<T>(state: EntityState<T> | undefined): state is EntityState<T> {
  return !!(state && state.ids !== undefined && Array.isArray(state.ids));
}

/**
 * Decorator functie voor het toevoegen van extra bescherming aan bestaande selectors
 */
export function withEntityStateGuard<T, R>(
  selector: (state: EntityState<T>) => R,
  fallbackValue: R
) {
  return (state: EntityState<T> | undefined): R => {
    if (!isValidEntityState(state)) {
      return fallbackValue;
    }
    try {
      return selector(state);
    } catch (error) {
      console.warn('[EntityStateGuard] Selector failed:', error);
      return fallbackValue;
    }
  };
}
--- END OF FILE ---

--- START OF FILE libs/shared/utils/src/lib/utils/media.utils.ts ---
// In: libs/shared/utils/src/lib/utils/media.utils.ts

import { Image, ImageVariant, Media, MediaType } from '@royal-code/shared/domain';

/**
 * Een flexibele functie om de beste ImageVariant te vinden op basis van een geordende lijst van doeleinden.
 * Het doorloopt de 'purposes' array en retourneert de eerste variant die overeenkomt.
 *
 * @param image Het Image object.
 * @param preferredPurposes Een array van strings die de gewenste doeleinden in volgorde van voorkeur aangeven (bijv. ['thumbnail', 'small_display']).
 * @returns De gevonden ImageVariant, of undefined als er geen match is.
 */
export function findImageVariantByPurpose(
  image: Image | undefined | null,
  preferredPurposes: string[]
): ImageVariant | undefined {
  if (!image?.variants?.length || !preferredPurposes?.length) {
    return undefined;
  }

  for (const purpose of preferredPurposes) {
    const variant = image.variants.find(v => v.purpose === purpose);
    if (variant) {
      return variant; // Gevonden! Retourneer meteen.
    }
  }

  return undefined; // Geen van de voorkeursvarianten gevonden.
}

/**
 * Een gespecialiseerde utility om de URL voor een profielavatar te krijgen.
 * Het definieert de standaard zoekvolgorde voor avatars en heeft een fallback.
 *
 * @param avatar Het Image object voor de avatar.
 * @returns De URL string van de meest geschikte variant, of undefined.
 */
export function getProfileAvatarUrl(avatar: Image | undefined | null): string | undefined {
  if (!avatar?.variants?.length) {
    return undefined;
  }

  // Zoek naar de beste variant in deze volgorde: 'icon', 'thumbnail', 'small_display'
  const preferredVariant = findImageVariantByPurpose(avatar, ['icon', 'thumbnail', 'small_display']);

  if (preferredVariant) {
    return preferredVariant.url;
  }

  // Fallback: als geen specifieke variant wordt gevonden, retourneer dan de variant met de kleinste breedte.
  const smallestVariant = [...avatar.variants].sort((a, b) => (a.width ?? 9999) - (b.width ?? 9999))[0];
  return smallestVariant?.url;
}

/**
 * Vindt de variant die het dichtst bij een bepaalde breedte ligt, zonder groter te zijn.
 * Ideaal voor het selecteren van de juiste bron voor een `<img>` tag in een container van bekende grootte.
 */
export function findVariantForWidth(image: Image | undefined | null, targetWidth: number): ImageVariant | undefined {
    if (!image?.variants?.length) {
        return undefined;
    }
    // Filter varianten die een breedte hebben en kleiner of gelijk zijn aan het doel, sorteer ze van groot naar klein.
    const suitableVariants = image.variants
        .filter(v => v.width && v.width <= targetWidth)
        .sort((a: ImageVariant, b: ImageVariant) => b.width! - a.width!);

    if (suitableVariants.length > 0) {
        return suitableVariants[0]; // Pak de grootste van de geschikte varianten.
    }

    // Fallback: als geen enkele variant kleiner is, pak dan de allerkleinste die beschikbaar is.
    return [...image.variants].sort((a, b) => (a.width ?? 9999) - (b.width ?? 9999))[0];
}



/**
 * Filtert een array van `Media` objecten en retourneert alleen de `Image` objecten.
 * Dit is een gecentraliseerde, type-veilige utility-functie om te voorkomen dat
 * feature-componenten deze logica moeten dupliceren.
 *
 * @param {Media[] | null | undefined} mediaList De array van `Media` objecten.
 * @returns {Image[]} Een nieuwe array die alleen `Image` objecten bevat.
 */
export function filterImageMedia(mediaList: readonly Media[] | null | undefined): Image[] {
  if (!mediaList) {
    return [];
  }
  // De .filter() methode retourneert altijd een nieuwe array, dus de 'readonly' is veilig.
  return mediaList.filter((item): item is Image => item.type === MediaType.IMAGE);
}
--- END OF FILE ---

--- START OF FILE libs/shared/utils/src/lib/utils/skill.utils.ts ---
// libs/shared/utils/src/lib/utils/skill.utils.ts
/**
 * @fileoverview Utility functions for character progression, potentially shared.
 * Provides helpers for calculating skill tiers, generating icon paths,
 * and deriving stat types from skill tree identifiers.
 * @version 1.0.2 - Improved type handling in getSkillIconPath.
 * @author ChallengerAppDevAI
 */

import { StatType } from '@royal-code/shared/domain'; // Zorg voor correct pad

/**
 * Calculates the skill tier based on the skill's current level.
 * Tier 1: Levels 1-6, Tier 2: Levels 7-12, Tier 3: 13-18, Tier 4: 19-24, Tier 5: 25-30.
 * @param level - The current level of the skill.
 * @returns The calculated tier number (1-5).
 */
export function getSkillTier(level: number): number {
  if (level <= 0) return 1;
  if (level >= 1 && level <= 6) return 1;
  if (level >= 7 && level <= 12) return 2;
  if (level >= 13 && level <= 18) return 3;
  if (level >= 19 && level <= 24) return 4;
  if (level >= 25) return 5;
  return 1; // Fallback
}

/**
 * Generates the full relative path to the SVG icon for a specific skill.
 * @param statTypeOrString - The core statistic type (e.g., StatType.Strength) or its string representation.
 * @param currentLevel - The current level of the skill.
 * @returns The relative path to the SVG icon.
 */
export function getSkillIconPath(statTypeOrString: StatType | string, currentLevel: number): string {
  const tier = getSkillTier(currentLevel);
  let statName: string;

  if (typeof statTypeOrString === 'string') {
    // Input is already a string, use its lowercase version.
    // Dit dekt ook het geval waarin een StatType enum waarde (die een string is) als string wordt doorgegeven.
    statName = statTypeOrString.toLowerCase();
  } else if (Object.values(StatType).includes(statTypeOrString as StatType)) {
    // Input is een StatType enum lid. Omdat StatType een string-enum is,
    // kunnen we het direct converteren naar een string en dan naar lowercase.
    // De 'as StatType' cast helpt de compiler, maar de check zelf is ook belangrijk.
    statName = (statTypeOrString as string).toLowerCase();
  } else {
    // Fallback voor onverwachte types (hoewel de functie signature dit zou moeten voorkomen)
    console.warn(`[getSkillIconPath] Unexpected statType: ${JSON.stringify(statTypeOrString)}. Defaulting icon name.`);
    statName = 'default'; // Gebruik een fallback naam
  }

  // Normaliseer de statName nogmaals voor het geval de input string case-varianten had
  // of als de enum value zelf niet lowercase was (hoewel onze StatType dat wel is).
  const normalizedStatName = statName.toLowerCase();

  return `assets/svg/stats/skills/tiers/${normalizedStatName}-tier-${tier}.svg`;
}

/**
 * Derives the core statistic type from a skillTreeId.
 * @param skillTreeId - The identifier of the skill tree (e.g., 'strength_skills').
 * @returns The corresponding StatType or the parsed string, or null.
 */
export function getStatTypeFromSkillTreeId(skillTreeId?: string): StatType | string | null {
  if (!skillTreeId) {
    return null;
  }
  const potentialStatTypeString = skillTreeId.toLowerCase().split('_')[0];

  // Check of de string overeenkomt met een waarde in de StatType enum
  const statTypeEnumValue = Object.values(StatType).find(
    value => value.toLowerCase() === potentialStatTypeString
  );

  // Retourneer de enum waarde indien gevonden, anders de string zelf.
  return statTypeEnumValue || potentialStatTypeString;
}
--- END OF FILE ---

--- START OF FILE libs/shared/utils/src/lib/utils/type-safety.utils.ts ---
/**
 * @file type-safety.utils.ts
 * @version 1.0.0
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-15
 * @description
 *   Provides essential, self-contained type-safety utility functions for the
 *   products-core library to avoid external dependencies for basic checks.
 */

/**
 * @function isDefined
 * @description A strict type guard that checks if a value is not null and not undefined.
 * @param {T | null | undefined} value - The value to check.
 * @returns {boolean} True if the value is defined.
 */
export function isDefined<T>(value: T | null | undefined): value is T {
  return value !== null && value !== undefined;
}

/**
 * @function withDefault
 * @description Returns the provided value if it is defined, otherwise returns the default value.
 * @param {T | null | undefined} value - The potentially undefined value.
 * @param {T} defaultValue - The value to return if the original value is not defined.
 * @returns {T} The original value or the default value.
 */
export function withDefault<T>(value: T | null | undefined, defaultValue: T): T {
  return value ?? defaultValue;
}

/**
 * @function emptyStringToNull
 * @description Converteert een lege string naar null. Dit is handig voor velden
 *              die optionele GUIDs of andere strings verwachten, om ervoor te zorgen
 *              dat de JSON-serialisatie compatibel is met backend `Guid?` of `string?` types.
 * @param value De input string, null, of undefined.
 * @returns null als de input een lege string is, anders de originele waarde.
 */
export function emptyStringToNull(value: string | null | undefined): string | null | undefined {
  if (typeof value === 'string' && value.trim() === '') {
    return null;
  }
  return value;
}
--- END OF FILE ---

--- START OF FILE libs/ui/forms/src/index.ts ---
export * from './lib/components/address-form/address-form.component';
export * from './lib/components/ui-select/ui-select.component';
export * from './lib/components/tag-input/tag-input.component';
export * from './lib/components/category-selector/category-selector.component';
export * from './lib/components/address-manager/address-manager.component';
--- END OF FILE ---

--- START OF FILE libs/ui/forms/src/lib/components/address-form/address-form.component.ts ---
import { Component, ChangeDetectionStrategy, inject, booleanAttribute, input, OnInit, signal, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormControl, ReactiveFormsModule, Validators } from '@angular/forms';
import { TranslateModule } from '@ngx-translate/core';
import { Address, AppIcon } from '@royal-code/shared/domain';
import { DYNAMIC_OVERLAY_DATA, DYNAMIC_OVERLAY_REF, DynamicOverlayRef } from '@royal-code/ui/overlay';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiInputComponent } from '@royal-code/ui/input';
import { UiSpinnerComponent } from '@royal-code/ui/spinner';

export interface AddressFormData {
  address?: Address;
  showSaveAddressToggle?: boolean; 
  isLoggedIn?: boolean;
}

export interface AddressFormOverlayResult {
  address: Address;
  shouldSave: boolean;
}

@Component({
  selector: 'royal-code-ui-address-form',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, TranslateModule, UiButtonComponent, UiInputComponent, UiSpinnerComponent],
  template: `
    <form novalidate="" [formGroup]="addressForm" (ngSubmit)="onSubmit()" class="w-full max-w-lg">
  <h2 class="text-xl font-bold mb-4">{{ addressToEdit() ? ('checkout.shipping.editAddressTitle' | translate) : ('checkout.shipping.addAddressTitle' | translate) }}</h2>
  <div class="space-y-4">
    <royal-code-ui-input formcontrolname="contactName" [label]="'checkout.shipping.form.contactName' | translate" [required]="true" />
    <royal-code-ui-input formcontrolname="street" [label]="'checkout.shipping.form.street' | translate" [required]="true" />
    <div class="grid grid-cols-1 gap-4 sm:grid-cols-3">
      <royal-code-ui-input formcontrolname="houseNumber" extraContainerClasses="sm:col-span-1" [label]="'checkout.shipping.form.houseNumber' | translate" [required]="true" />
      <royal-code-ui-input formcontrolname="addressAddition" extraContainerClasses="sm:col-span-2" [label]="'checkout.shipping.form.addressAddition' | translate" />
    </div>
    <div class="grid grid-cols-1 gap-4 sm:grid-cols-3">
      <royal-code-ui-input formcontrolname="postalCode" extraContainerClasses="sm:col-span-1" [label]="'checkout.shipping.form.postalCode' | translate" [required]="true" />
      <royal-code-ui-input formcontrolname="city" extraContainerClasses="sm:col-span-2" [label]="'checkout.shipping.form.city' | translate" [required]="true" />
    </div>
    <royal-code-ui-input formcontrolname="countryCode" [label]="'checkout.shipping.form.country' | translate" [required]="true" />
    <royal-code-ui-input formcontrolname="phoneNumber" [label]="'checkout.shipping.form.phoneNumber' | translate" />
    <royal-code-ui-input formcontrolname="email" type="email" [label]="'checkout.shipping.form.email' | translate" [required]="true" />
    <royal-code-ui-input formcontrolname="companyName" [label]="'checkout.shipping.form.companyName' | translate" />
    <royal-code-ui-input formcontrolname="deliveryInstructions" [label]="'checkout.shipping.form.deliveryInstructions' | translate" />
  </div>

  @if (showSaveAddressToggle()) {
    <div class="flex items-center mt-6">
      <input type="checkbox" id="saveAddress" [formControl]="saveAddressControl" class="h-4 w-4 rounded border-border text-primary focus:ring-primary" />
      <label for="saveAddress" class="ml-2 block text-sm text-foreground">
        {{ 'checkout.shipping.form.saveAddressCheckbox' | translate }}
      </label>
    </div>
  }

  <div class="flex justify-end gap-2 mt-6">
    <royal-code-ui-button type="default" (clicked)="overlayRef.close()">
      {{ 'common.buttons.cancel' | translate }}
    </royal-code-ui-button>
    <royal-code-ui-button type="primary" htmlType="submit" [disabled]="addressForm.invalid || isSubmitting()">
      @if (isSubmitting()) {
        <royal-code-ui-spinner size="sm" />
      } @else {
        <span>{{ submitButtonTextKey() | translate }}</span>
      }
    </royal-code-ui-button>
  </div>
</form>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class AddressFormComponent implements OnInit {
  // === Dependencies ===
  private readonly fb = inject(FormBuilder);
  public readonly overlayRef: DynamicOverlayRef<AddressFormOverlayResult | null> = inject(DYNAMIC_OVERLAY_REF);
  private readonly overlayData: AddressFormData | null = inject(DYNAMIC_OVERLAY_DATA, { optional: true });

  // === Inputs (nu als Signalen) ===
  // FIX: showSaveAddressToggle en isLoggedIn worden nu uit de overlayData gehaald
  readonly showSaveAddressToggle = computed(() => this.overlayData?.showSaveAddressToggle ?? false);
  readonly isLoggedIn = computed(() => this.overlayData?.isLoggedIn ?? false);
  readonly submitButtonTextKey = input<string>('common.buttons.save');
  readonly isSubmitting = input(false, { transform: booleanAttribute });

  // === Formulier Definitie ===
  // FIX: saveAddressControl is nu een computed property of wordt elders beheerd.
  // We kunnen de state hier lokaal bijhouden.
  readonly _saveAddressValue = signal(true); // Lokale state voor de checkbox
  readonly saveAddressControl = new FormControl(true); // Wordt nog steeds gebruikt voor form binding

  readonly addressForm = this.fb.group({
    id: [''],
    contactName: ['', Validators.required],
    street: ['', Validators.required],
    houseNumber: ['', Validators.required],
    addressAddition: [''],
    postalCode: ['', Validators.required],
    city: ['', Validators.required],
    countryCode: ['NL', Validators.required], // Default naar NL
    phoneNumber: [''],
    email: ['', [Validators.required, Validators.email]],
    companyName: [''],
    deliveryInstructions: [''],
    isDefaultShipping: [false],
    isDefaultBilling: [false],
  });

  ngOnInit(): void {
    if (this.addressToEdit()) {
      this.addressForm.patchValue(this.addressToEdit() as Address);
    }
    this.saveAddressControl.setValue(this.showSaveAddressToggle());
  }

  readonly addressToEdit = computed(() => this.overlayData?.address);

  onSubmit(): void {
    if (this.addressForm.invalid) {
      this.addressForm.markAllAsTouched();
      return;
    }
    const result: AddressFormOverlayResult = {
      address: this.addressForm.getRawValue() as Address,
      shouldSave: this.saveAddressControl.value ?? false, // Zorg voor een fallback
    };
    this.overlayRef.close(result);
  }
}
--- END OF FILE ---

--- START OF FILE libs/ui/forms/src/lib/components/address-manager/address-manager.component.ts ---
/**
 * @file address-manager.component.ts - UPDATED to hide add address card
 * @Version 14.0.0 (Hide Add Address Card Option)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-09-06
 * @Description
 *   Updated AddressManagerComponent met optie om de "add address card" te verbergen
 *   voor gevallen waar een parent component eigen add-button heeft.
 */
import { CommonModule } from '@angular/common';
import { ChangeDetectionStrategy, Component, computed, inject, input, output, OnInit, signal, booleanAttribute } from '@angular/core';
import { FormBuilder, ReactiveFormsModule, Validators, FormGroup, AbstractControl } from '@angular/forms';
import { RouterLink, RouterModule } from '@angular/router';
import { TranslateModule, TranslateService } from '@ngx-translate/core';

import { AppIcon, Address } from '@royal-code/shared/domain';
import { UiButtonComponent } from '@royal-code/ui/button';
import { UiCardComponent } from '@royal-code/ui/card';
import { UiIconComponent } from '@royal-code/ui/icon';
import { UiCheckboxComponent, UiInputComponent } from '@royal-code/ui/input';
import { UiParagraphComponent } from '@royal-code/ui/paragraph';
import { UiTitleComponent } from '@royal-code/ui/title';
import { TitleTypeEnum } from '@royal-code/shared/domain';
import { NotificationService } from '@royal-code/ui/notifications';
import { UserFacade } from '@royal-code/store/user';

export interface AddressSubmitEvent {
  address: Address;
  shouldSave: boolean;
}

@Component({
  selector: 'royal-code-ui-address-manager',
  standalone: true,
  imports: [
    CommonModule, ReactiveFormsModule, RouterModule, TranslateModule,
    UiButtonComponent, UiCardComponent, UiIconComponent, UiInputComponent,
    UiParagraphComponent, UiTitleComponent, UiCheckboxComponent
  ],
  template: `
    <section class="space-y-6">
      <!-- Opgeslagen adressen (alleen voor ingelogde gebruikers) -->
      @if (isLoggedIn() && addresses().length > 0) {
        <div class="space-y-4">
          <royal-code-ui-paragraph color="muted">{{ 'checkout.shipping.selectSavedAddress' | translate }}</royal-code-ui-paragraph>
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            @for (address of addresses(); track address.id) {
              <royal-code-ui-button
                type="none"
                (clicked)="selectAddress(address)"
                [extraClasses]="'relative group/address w-full p-4 text-left border-2 ' + (isSelected(address) ? 'border-primary bg-surface-alt' : 'border-border')"
                [attr.aria-pressed]="isSelected(address)">
                <div>
                  <p class="font-semibold pointer-events-none">{{ address.contactName }}</p>
                  <p class="text-sm text-muted pointer-events-none">
                    {{ address.street }} {{ address.houseNumber }}<br>
                    @if (address.addressAddition) {
                      {{ address.addressAddition }}<br>
                    }
                    {{ address.postalCode }} {{ address.city }}
                  </p>
                </div>
                <div class="address-actions-desktop absolute top-2 right-2 flex items-center gap-1">
                  <royal-code-ui-button type="transparent" sizeVariant="icon" extraClasses="h-8 w-8 text-muted hover:!text-primary" (clicked)="$event.stopPropagation(); editAddressClicked.emit(address)">
                    <royal-code-ui-icon [icon]="AppIcon.Edit" sizeVariant="sm" />
                  </royal-code-ui-button>
                  <royal-code-ui-button type="transparent" sizeVariant="icon" extraClasses="h-8 w-8 text-muted hover:!text-error" (clicked)="$event.stopPropagation(); deleteAddressClicked.emit(address.id!)">
                    <royal-code-ui-icon [icon]="AppIcon.Trash2" sizeVariant="sm" />
                  </royal-code-ui-button>
                </div>
              </royal-code-ui-button>
            }
            <!-- Add address card - alleen tonen als showAddAddressCard = true -->
            @if (showAddAddressCard()) {
              <a (click)="onAddNewAddressCardClick()" class="block cursor-pointer group add-address-card">
                <royal-code-ui-card extraContentClasses="flex flex-col items-center justify-center p-6 text-center h-full border-2 border-dashed border-border hover:border-primary transition-colors" class="h-full">
                  <royal-code-ui-icon [icon]="AppIcon.Plus" sizeVariant="xl" extraClasses="text-primary mb-3 group-hover:scale-110 transition-transform" />
                  <h3 class="text-lg font-semibold text-foreground">{{ 'account.addresses.addAddressTitle' | translate }}</h3>
                  <p class="text-sm text-secondary">{{ 'account.addresses.addAddressDescription' | translate }}</p>
                </royal-code-ui-card>
              </a>
            }
          </div>
          @if (isLoggedIn() && addresses().length > 0) {
            <div class="flex items-center justify-center pt-2">
              <div class="h-px flex-grow bg-border"></div>
              <royal-code-ui-paragraph size="sm" color="muted" extraClasses="px-4">{{ 'common.or' | translate }}</royal-code-ui-paragraph>
              <div class="h-px flex-grow bg-border"></div>
            </div>
          }
        </div>
      }

      <!-- Formulier voor nieuw adres of anonieme gebruiker -->
      @if (showAddAddressForm() || !isLoggedIn()) {
        <form [formGroup]="form" (ngSubmit)="onSubmit()" class="space-y-4">
          <royal-code-ui-input formControlName="contactName" [label]="'checkout.shipping.form.recipientName' | translate" [required]="true" />
          <royal-code-ui-input formControlName="street" [label]="'checkout.shipping.form.street' | translate" [required]="true" />
          <div class="grid grid-cols-1 gap-4 sm:grid-cols-3">
            <royal-code-ui-input formControlName="houseNumber" [label]="'checkout.shipping.form.houseNumber' | translate" [required]="true" extraContainerClasses="sm:col-span-1" />
            <royal-code-ui-input formControlName="addressAddition" [label]="'checkout.shipping.form.addressAddition' | translate" extraContainerClasses="sm:col-span-2" />
          </div>
          <div class="grid grid-cols-1 gap-4 sm:grid-cols-3">
            <royal-code-ui-input formControlName="postalCode" [label]="'checkout.shipping.form.postalCode' | translate" [required]="true" extraContainerClasses="sm:col-span-1" />
            <royal-code-ui-input formControlName="city" [label]="'checkout.shipping.form.city' | translate" [required]="true" extraContainerClasses="sm:col-span-2" />
          </div>
          <royal-code-ui-input formControlName="countryCode" [label]="'checkout.shipping.form.country' | translate" [required]="true" />
          <royal-code-ui-input formControlName="phoneNumber" [label]="'checkout.shipping.form.phoneNumber' | translate" />
          <royal-code-ui-input formControlName="email" [label]="'checkout.shipping.form.email' | translate" [required]="true" />
          <royal-code-ui-input formControlName="companyName" [label]="'checkout.shipping.form.companyName' | translate" />
          <royal-code-ui-input formControlName="deliveryInstructions" [label]="'checkout.shipping.form.deliveryInstructions' | translate" />

          @if (showSaveAddressToggle()) {
            <div class="pt-4 space-y-2">
              <royal-code-ui-checkbox
                formControlName="saveAddress"
                [label]="'checkout.shipping.form.saveAddress' | translate"
                [disabled]="!isLoggedIn()" />
              @if (!isLoggedIn()) {
                <div class="p-3 bg-surface-alt rounded-md flex flex-col sm:flex-row items-center justify-between gap-3">
                  <p class="text-sm text-secondary">{{ 'checkout.shipping.form.saveAddressForLoggedInUsers' | translate }}</p>
                  <royal-code-ui-button type="secondary" sizeVariant="sm" [routerLink]="['/register']" (clicked)="$event.stopPropagation()">
                    {{ 'auth.register.submit' | translate }}
                  </royal-code-ui-button>
                </div>
              }
            </div>
          }
          
          @if (showSubmitButton()) {
            <div class="pt-4 flex justify-end">
              <royal-code-ui-button type="primary" htmlType="submit" [disabled]="form.invalid">
                <royal-code-ui-icon [icon]="AppIcon.Plus" extraClass="mr-2" />
                <span>{{ submitButtonTextKey() | translate }}</span>
              </royal-code-ui-button>
            </div>
          }
        </form>
      }
    </section>
  `,
  styles: [`
    :host { display: block; }
    .group\\/address:hover .address-actions-desktop {
      opacity: 1;
    }
    .address-actions-desktop {
      opacity: 0;
      transition: opacity 0.2s ease-in-out;
    }
    .add-address-card {
        height: 100%;
    }
  `],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class AddressManagerComponent implements OnInit {
  // --- INPUTS ---
  readonly addresses = input.required<Address[]>();
  readonly initialAddress = input<Address | undefined>();
  readonly isLoggedIn = input.required<boolean>();
  readonly submitButtonTextKey = input.required<string>();
  readonly showSaveAddressToggle = input(true, { transform: booleanAttribute });
  readonly showEditAndDeleteActions = input(true, { transform: booleanAttribute });
  readonly alwaysShowActions = input(false, { transform: booleanAttribute });
  readonly showSubmitButton = input(true, { transform: booleanAttribute });
  readonly showAddAddressForm = input(false, { transform: booleanAttribute });
  
  // NEW: Input to control add address card visibility
  readonly showAddAddressCard = input(true, { transform: booleanAttribute });

  // --- OUTPUTS ---
  readonly addressSelected = output<Address>();
  readonly addressSubmitted = output<AddressSubmitEvent>();
  readonly editAddressClicked = output<Address>();
  readonly deleteAddressClicked = output<string>();
  readonly addAddressCardClicked = output<void>();

  // --- INTERNAL STATE ---
  protected readonly AppIcon = AppIcon;
  protected readonly TitleTypeEnum = TitleTypeEnum;

  protected readonly isEditing = signal(false);
  protected readonly selectedLocalAddress = signal<Address | undefined>(undefined);

  protected form = inject(FormBuilder).group({
    id: [null as string | null],
    contactName: ['', Validators.required],
    street: ['', Validators.required],
    houseNumber: ['', Validators.required],
    addressAddition: [null as string | null],
    postalCode: ['', Validators.required],
    city: ['', Validators.required],
    countryCode: ['', Validators.required],
    phoneNumber: [null as string | null],
    email: ['', [Validators.required, Validators.email]],
    companyName: [null as string | null],
    deliveryInstructions: [null as string | null],
    isDefaultShipping: [false as boolean | null],
    isDefaultBilling: [false as boolean | null],
    saveAddress: [false],
  });

  private readonly notificationService = inject(NotificationService);
  private readonly translate = inject(TranslateService);
  private readonly userFacade = inject(UserFacade);

  ngOnInit(): void {
    if (this.initialAddress()) {
      this.selectedLocalAddress.set(this.initialAddress());
      this.patchFormWithAddress(this.initialAddress()!);
      this.isEditing.set(false);
    }
  }

  isSelected(address: Address): boolean {
    return this.selectedLocalAddress()?.id === address.id;
  }

  selectAddress(address: Address): void {
    this.selectedLocalAddress.set(address);
    this.addressSelected.emit(address);
    this.isEditing.set(false);
    this.resetForm();
  }

  onAddNewAddressCardClick(): void {
    this.resetForm();
    this.isEditing.set(false);
    this.addAddressCardClicked.emit();
  }

  onEditAddress(address: Address): void {
    this.patchFormWithAddress(address);
    this.isEditing.set(true);
    this.selectedLocalAddress.set(address);
    this.editAddressClicked.emit(address);
  }

  onSubmit(): void {
    this.form.markAllAsTouched();
    if (this.form.invalid) {
      this.notificationService.showError(this.translate.instant('common.messages.error'));
      return;
    }
    const formValue = this.form.getRawValue();
    const shouldSave = formValue.saveAddress ?? false;
    const address: Address = {
      id: formValue.id || '',
      userId: this.userFacade.profile()?.id,
      contactName: formValue.contactName!,
      street: formValue.street!,
      houseNumber: formValue.houseNumber!,
      addressAddition: formValue.addressAddition,
      postalCode: formValue.postalCode!,
      city: formValue.city!,
      countryCode: formValue.countryCode!,
      phoneNumber: formValue.phoneNumber,
      email: formValue.email!,
      companyName: formValue.companyName,
      deliveryInstructions: formValue.deliveryInstructions,
      isDefaultShipping: formValue.isDefaultShipping ?? undefined,
      isDefaultBilling: formValue.isDefaultBilling ?? undefined,
    };

    this.addressSubmitted.emit({ address, shouldSave });
    this.resetForm();
    this.isEditing.set(false);
  }

  resetForm(): void {
    this.form.reset({
      id: null,
      contactName: '',
      street: '',
      houseNumber: '',
      addressAddition: null,
      postalCode: '',
      city: '',
      countryCode: '',
      phoneNumber: null,
      email: '',
      companyName: null,
      deliveryInstructions: null,
      isDefaultShipping: false,
      isDefaultBilling: false,
      saveAddress: false,
    });
    this.form.markAsPristine();
    this.form.markAsUntouched();
    this.isEditing.set(false);
  }

  private patchFormWithAddress(address: Address): void {
    this.form.patchValue({
      id: address.id,
      contactName: address.contactName,
      street: address.street,
      houseNumber: address.houseNumber,
      addressAddition: address.addressAddition,
      postalCode: address.postalCode,
      city: address.city,
      countryCode: address.countryCode,
      phoneNumber: address.phoneNumber,
      email: address.email,
      companyName: address.companyName,
      deliveryInstructions: address.deliveryInstructions,
      isDefaultShipping: address.isDefaultShipping ?? null,
      isDefaultBilling: address.isDefaultBilling ?? null,
      saveAddress: false,
    });
    this.form.markAsPristine();
  }
}
--- END OF FILE ---

--- START OF FILE libs/ui/forms/src/lib/components/category-selector/category-selector.component.ts ---
/**
 * @file category-selector.component.ts
 * @Version 3.4.0 (Refactored to use UiCheckboxComponent)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-05
 * @Description
 *   A component for selecting product categories from a list. This version is
 *   refactored to use the new, dedicated `UiCheckboxComponent`, resolving previous
 *   binding and CVA conflicts.
 */
import { Component, ChangeDetectionStrategy, forwardRef, input, signal, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { ProductCategory } from '@royal-code/features/products/domain';
import { UiCheckboxComponent } from '@royal-code/ui/input'; 

@Component({
  selector: 'royal-code-ui-category-selector',
  standalone: true,
  imports: [CommonModule, UiCheckboxComponent],
  template: `
    <div>
      <label class="block text-sm font-medium text-foreground mb-1">{{ label() }}</label>
      @if (isLoading()) {
        <p class="text-sm text-secondary">Categorieën laden...</p>
      } @else {
        <div class="max-h-48 overflow-y-auto border border-input rounded-md p-2 space-y-1">
          @for (category of rootCategories(); track category.id) {
            <ng-container [ngTemplateOutlet]="categoryTemplate" [ngTemplateOutletContext]="{$implicit: category, level: 0}"></ng-container>
          }
        </div>
      }
    </div>

    <ng-template #categoryTemplate let-category let-level="level">
      <div [style.padding-left.rem]="level * 1.5">
        <!-- === GEBRUIK NU DE NIEUWE CHECKBOX COMPONENT === -->
        <royal-code-ui-checkbox
          [label]="category.name"
          [checked]="isSelected(category.id)"
          (changed)="toggleSelection(category.id, $event)"
          [explicitId]="'category-' + category.id"
          [labelClasses]="isSelected(category.id) ? 'text-primary font-semibold' : ''" 
        />
      </div>
      @if (category.children && category.children.length > 0) {
        @for(child of category.children; track child.id) {
          <ng-container [ngTemplateOutlet]="categoryTemplate" [ngTemplateOutletContext]="{$implicit: child, level: level + 1}"></ng-container>
        }
      }
    </ng-template>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
  providers: [{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => UiCategorySelectorComponent),
    multi: true
  }]
})
export class UiCategorySelectorComponent implements ControlValueAccessor {
  readonly categories = input.required<readonly ProductCategory[]>();
  readonly label = input<string>('Categorieën');
  readonly isLoading = input<boolean>(false);

  protected selectedIds = signal<Set<string>>(new Set());
  private onChange: (value: string[] | null) => void = () => {};
  private onTouched: () => void = () => {};

  protected categoryMap = computed(() => this.flattenCategories(this.categories()));
  protected rootCategories = computed(() => this.categories().filter(c => !c.parentId));

  writeValue(value: string[] | null): void {
    this.selectedIds.set(new Set(value || []));
  }
  registerOnChange(fn: any): void { this.onChange = fn; }
  registerOnTouched(fn: any): void { this.onTouched = fn; }

  isSelected(id: string): boolean {
    return this.selectedIds().has(id);
  }

  toggleSelection(id: string, isChecked: boolean): void {
    const newSelectedIds = new Set(this.selectedIds());
    
    this.updateDescendants(newSelectedIds, id, isChecked);
    this.updateAncestors(newSelectedIds, id);

    this.selectedIds.set(newSelectedIds);
    this.onChange(Array.from(newSelectedIds));
    this.onTouched();
  }

  private flattenCategories(categories: readonly ProductCategory[]): Map<string, ProductCategory> {
    const map = new Map<string, ProductCategory>();
    function recurse(cats: readonly ProductCategory[]) {
      for (const cat of cats) {
        map.set(cat.id, cat);
        if (cat.children) {
          recurse(cat.children);
        }
      }
    }
    recurse(categories);
    return map;
  }
  
  private getDescendantIds(startId: string): string[] {
    const descendants: string[] = [];
    const queue: string[] = [startId];
    const map = this.categoryMap();
    
    while (queue.length > 0) {
      const currentId = queue.shift()!;
      const category = map.get(currentId);
      if (category?.children) {
        for (const child of category.children) {
          descendants.push(child.id);
          queue.push(child.id);
        }
      }
    }
    return descendants;
  }

  private updateDescendants(selected: Set<string>, startId: string, shouldBeSelected: boolean): void {
    const idsToUpdate = [startId, ...this.getDescendantIds(startId)];
    if (shouldBeSelected) {
      idsToUpdate.forEach(id => selected.add(id));
    } else {
      idsToUpdate.forEach(id => selected.delete(id));
    }
  }

  private updateAncestors(selected: Set<string>, startId: string): void {
    const map = this.categoryMap();
    let parentId = map.get(startId)?.parentId;

    while (parentId) {
      const parent = map.get(parentId);
      if (!parent || !parent.children) break;

      const allChildrenSelected = parent.children.every(child => selected.has(child.id));
      
      if (allChildrenSelected) {
        selected.add(parent.id);
      } else {
        selected.delete(parent.id);
      }
      
      parentId = parent.parentId;
    }
  }
}
--- END OF FILE ---

--- START OF FILE libs/ui/forms/src/lib/components/tag-input/tag-input.component.ts ---
/**
 * @file tag-input.component.ts
 * @Version 2.0.0 (Refactored for pure UiInputComponent CVA with ngModel)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-05
 * @Description
 *   A reusable tag input component with autocomplete functionality. This version
 *   is refactored to correctly interact with the pure `UiInputComponent` CVA,
 *   relying on `ngModel` for two-way binding to its internal input field.
 */
import { Component, ChangeDetectionStrategy, input, inject, signal, computed, effect, OnInit, OnDestroy, forwardRef, DestroyRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms'; // FormsModule voor ngModel
import { AdminProductApiService } from '@royal-code/features/admin-products/data-access';
import { ProductTagLookup } from '@royal-code/features/admin-products/domain';
import { Subject, of } from 'rxjs';
import { debounceTime, distinctUntilChanged, switchMap, filter, map, catchError } from 'rxjs/operators';
import { UiIconComponent } from '@royal-code/ui/icon';
import { AppIcon } from '@royal-code/shared/domain';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { UiInputComponent } from '@royal-code/ui/input';

@Component({
  selector: 'royal-code-ui-tag-input',
  standalone: true,
  imports: [CommonModule, FormsModule, UiIconComponent, UiInputComponent],
  template: `
    <div>
      @if (label()) {
        <label [for]="inputId()" class="block text-sm font-medium text-foreground mb-1">{{ label() }}</label>
      }
      <div class="relative">
        <royal-code-ui-input
          [id]="inputId()"
          type="text"
          [placeholder]="placeholder()"
          [(ngModel)]="currentInputValue"
          (blur)="onInputBlur()"
          (focusedEvent)="onInputFocus()"
          [disabled]="isDisabled()"
          [icon]="AppIcon.Search"
          iconPosition="right"
        ></royal-code-ui-input>

        @if (suggestions().length > 0 && showSuggestions()) {
          <ul class="absolute z-10 w-full bg-card border border-border rounded-md shadow-lg mt-1 max-h-60 overflow-auto">
            @for(suggestion of suggestions(); track suggestion.name) {
              <li
                class="px-3 py-2 cursor-pointer hover:bg-hover text-sm"
                (mousedown)="onSuggestionMouseDown($event, suggestion.name)"
              >
                {{ suggestion.name }}
              </li>
            }
          </ul>
        }
      </div>

      <div class="mt-2 flex flex-wrap gap-2">
        @for(tag of selectedTags(); track tag) {
          <span class="flex items-center gap-1 rounded-full bg-primary/20 px-3 py-1 text-sm text-primary-on border border-primary">
            {{ tag }}
            <button type="button" (click)="removeTag(tag)" class="ml-1 text-primary-on/80 hover:text-primary-on">
              <royal-code-ui-icon [icon]="AppIcon.X" sizeVariant="xs" />
            </button>
          </span>
        }
        @if (selectedTags().length === 0 && !currentInputValue()) {
            <p class="text-sm text-secondary mt-1">{{ noTagsMessage() }}</p>
        }
      </div>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => UiTagInputComponent),
      multi: true,
    },
  ],
})
export class UiTagInputComponent implements ControlValueAccessor, OnInit, OnDestroy {
  // Inputs
  readonly label = input<string>('Tags');
  readonly placeholder = input<string>('Voeg tags toe...');
  readonly noTagsMessage = input<string>('Nog geen tags gekozen.');
  readonly debounceTimeMs = input<number>(300);

  // Dependencies
  private readonly apiService = inject(AdminProductApiService);
  private readonly destroyRef = inject(DestroyRef);

  // Internal state (signals & model())
  protected readonly inputId = signal(`tag-input-${Math.random().toString(36).substring(2, 9)}`);
  protected readonly selectedTags = signal<string[]>([]);
  protected currentInputValue = signal<string>(''); // Gebruikt met [(ngModel)]
  protected readonly suggestions = signal<ProductTagLookup[]>([]);
  protected readonly showSuggestions = signal<boolean>(false);
  protected readonly AppIcon = AppIcon;

  // ControlValueAccessor internal functions
  private _onChange: (value: string[] | null) => void = () => {};
  private _onTouched: () => void = () => {};
  protected isDisabled = signal(false); // Via setDisabledState

  // RxJS Subjects
  private readonly searchTerm$ = new Subject<string>();

  constructor() {
    // Effect om de waarde van de interne input te volgen voor de zoekterm
    effect(() => {
      this.searchTerm$.next(this.currentInputValue());
    });
  }

  ngOnInit(): void {
    this.searchTerm$.pipe(
      debounceTime(this.debounceTimeMs()),
      distinctUntilChanged(),
      filter(term => term.length > 1),
      switchMap(term => this.apiService.getTags(term).pipe(
        map((tags: ProductTagLookup[]) => tags),
        catchError(() => of([] as ProductTagLookup[]))
      )),
      takeUntilDestroyed(this.destroyRef)
    ).subscribe((suggestions: ProductTagLookup[]) => {
      this.suggestions.set(suggestions);
      this.showSuggestions.set(suggestions.length > 0);
    });
  }

  ngOnDestroy(): void {
    this.searchTerm$.complete();
  }

  // ControlValueAccessor methods
  writeValue(value: string[] | null): void {
    this.selectedTags.set(value || []);
  }

  registerOnChange(fn: (value: string[] | null) => void): void {
    this._onChange = fn;
  }

  registerOnTouched(fn: () => void): void {
    this._onTouched = fn;
  }

  setDisabledState?(isDisabled: boolean): void {
    this.isDisabled.set(isDisabled);
  }

  // Event Handlers
  onInputFocus(): void {
    if (this.currentInputValue().length > 1) {
      this.searchTerm$.next(this.currentInputValue());
    }
    this.showSuggestions.set(true);
  }

  onSuggestionMouseDown(event: MouseEvent, tagName: string): void {
    event.preventDefault(); // Voorkom dat de input blur-event triggert en de suggesties sluit
    this.addTag(tagName);
  }

  onInputBlur(): void {
    if (this.currentInputValue().length > 0) {
      this.addTag(this.currentInputValue());
    }
    
    // Kleine timeout om click op suggestie toe te staan voordat suggesties verdwijnen
    setTimeout(() => {
      this.showSuggestions.set(false);
      this._onTouched();
    }, 100);
  }

  // Tag Management Logic
  addTag(tag: string): void {
    const trimmedTag = tag.trim();
    if (trimmedTag && !this.selectedTags().includes(trimmedTag)) {
      this.selectedTags.update((tags: string[]) => [...tags, trimmedTag]);
      this.currentInputValue.set(''); // Reset de inputwaarde
      this.suggestions.set([]);
      this.showSuggestions.set(false);
      this._onChange(this.selectedTags());
      this._onTouched();
    }
  }

  removeTag(tagToRemove: string): void {
    this.selectedTags.update((tags: string[]) => tags.filter((tag: string) => tag !== tagToRemove));
    this._onChange(this.selectedTags());
    this._onTouched();
  }
}
--- END OF FILE ---

--- START OF FILE libs/ui/forms/src/lib/components/ui-select/ui-select.component.ts ---
/**
 * @file ui-select.component.ts
 * @Version 2.2.0 (Definitive CVA with Error Handling)
 * @Author Royal-Code MonorepoAppDevAI
 * @Date 2025-08-07
 * @Description A reusable select component, fully upgraded to Angular v21+ syntax.
 *              This version adds an 'error' input for displaying validation messages,
 *              aligning its API with other form components like UiInputComponent.
 */
import { Component, ChangeDetectionStrategy, forwardRef, input, model, computed, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NG_VALUE_ACCESSOR, ControlValueAccessor, ReactiveFormsModule } from '@angular/forms';

export interface SelectOption {
  value: any;
  label: string;
}

@Component({
  selector: 'royal-code-ui-select',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  template: `
    <div>
      @if (label()) {
        <label [for]="id()" class="block text-sm font-medium text-foreground mb-1">
          {{ label() }}
          @if (required()) {
            <span class="text-destructive">*</span>
          }
        </label>
      }
      <select
        [id]="id()"
        [value]="value()"
        (blur)="onTouched()"
        (change)="onChange($event)"
        [disabled]="disabled()"
        [ngClass]="{ 'border-destructive': hasErrors() }"
        class="w-full p-2 border border-input rounded-xs bg-background text-sm focus:ring-primary focus:border-primary ring-1 ring-inset ring-border shadow-sm disabled:opacity-50 disabled:cursor-not-allowed"
        [attr.aria-required]="required()"
      >
        @for (option of options(); track option.value) {
          <option [ngValue]="option.value">{{ option.label }}</option>
        }
      </select>
      <!-- === HIER IS DE TOEGEVOEGDE LOGICA VOOR FOUTMELDINGEN === -->
      @if (hasErrors()) {
        <p class="mt-2 text-sm text-destructive" [attr.id]="id() + '-error'">
          {{ error() }}
        </p>
      }
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => UiSelectComponent),
      multi: true,
    },
  ],
})
export class UiSelectComponent implements ControlValueAccessor {
  // === Inputs ===
  label = input<string | undefined>();
  options = input<SelectOption[]>([]);
  required = input<boolean>(false);
  error = input<string | undefined>(); // <-- TOEGEVOEGD

  // === Value Model ===
  value = model<any>('');

  // === Internal State ===
  readonly id = computed(() => `select-${Math.random().toString(36).substring(2)}`);
  protected readonly disabled = signal<boolean>(false);
  readonly hasErrors = computed(() => !!this.error()); // <-- TOEGEVOEGD

  // === ControlValueAccessor Callbacks ===
  private onChangeFn: (value: any) => void = () => {};
  onTouched: () => void = () => {};

  // === CVA Implementation ===
  writeValue(value: any): void {
    this.value.set(value);
  }

  registerOnChange(fn: (value: any) => void): void {
    this.onChangeFn = fn;
  }

  registerOnTouched(fn: () => void): void {
    this.onTouched = fn;
  }

  setDisabledState?(isDisabled: boolean): void {
    this.disabled.set(isDisabled);
  }

  // === Event Handlers ===
  onChange(event: Event): void {
    const selectElement = event.target as HTMLSelectElement;
    const selectedOption = this.options().find(opt => String(opt.value) === selectElement.value);
    const newValue = selectedOption ? selectedOption.value : selectElement.value;
    
    this.value.set(newValue);
    this.onChangeFn(newValue);
  }
}
--- END OF FILE ---

