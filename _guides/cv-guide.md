
### **1. Filosofie: De Interactieve Ervaring als Bewijs**

Dit is geen CV. Het is een live demonstratie van uw expertise. Elke pixel, elke interactie en elke regel code is een bewijsstuk. We transformeren een passieve leeservaring in een actieve ontdekkingsreis. De gebruiker (recruiter, tech lead, CTO) leest niet alleen wat u kunt; hij of zij *ervaart* het.

### **2. Psychologische Grondslagen**

Dit plan is gebouwd op de volgende, bewezen psychologische principes:

1.  **Show, Don't Tell (Cognitive Fluency):** Bewijs is geloofwaardiger dan beweringen. Een werkende, performante applicatie is het ultieme bewijs.
2.  **Dual-Audience Pathfinding (Personalisatie):** We creëren twee paden: een snelle, impactvolle route voor recruiters (de "30-seconde scan") en een diepgaande, technische route voor developers (de "Deep Dive").
3.  **Primacy & Recency Effect (De Eerste & Laatste Indruk):** De eerste indruk (de "Hook") en de laatste indruk (de "Closer") worden geoptimaliseerd voor maximale impact en herinnering.
4.  **STAR-Methode & Kwantificering (Concrete Cognition):** We vervangen vage taken met concrete, meetbare resultaten (Situatie, Taak, Actie, Resultaat) om impact tastbaar te maken.
5.  **Social Proof & Authority (Vertrouwen):** We bouwen geloofwaardigheid op via testimonials, certificaten en directe links naar technische bewijsstukken (code).
6.  **Peak-End Rule (Het "Wow"-Moment):** We ontwerpen een onvergetelijk hoogtepunt (de AI Avatar) en een vlekkeloze afsluiting om een blijvende, positieve indruk achter te laten.

---

## **DE GEBRUIKERSREIS: EEN NARRATIEF IN VIER ACTES**

### **ACTE I: DE HOOK (DE EERSTE 6 SECONDEN)**
**Doel:** Directe aandacht grijpen, kernwaarde communiceren en onmiddellijke geloofwaardigheid vestigen.

#### **1.1. Hero-Blok: De Onweerlegbare Elevator Pitch**

*   **(Headline):** Full-Stack Architect | Gespecialiseerd in .NET, Angular & AI-Workflow Optimalisatie
*   **(Pitch):** Als Full-Stack Architect ontwerp en bouw ik schaalbare applicaties die **ontwikkeltijd met 30% reduceren** en **performance met 60% verhogen**. Dit bereik ik door een unieke, AI-gedreven "Specification-Driven" workflow te combineren met een robuuste Clean Architecture. Ik ben een strategische partner die complexe business-uitdagingen omzet in meetbaar resultaat.
*   **(Status):** Regio Utrecht | Hybride/Remote | `[Badge: Beschikbaar voor nieuwe opdrachten]`
*   **(Acties):**
    *   `[Primary Button]` Download CV (PDF)
    *   `[Secondary Button]` Plan een Gesprek
    *   `[Icon Button]` LinkedIn
    *   `[Icon Button]` GitHub

#### **1.2. Sectie: Mijn Kernimpact & Social Proof**

*   **(Titel):** Mijn Kernimpact
*   **Kaart 1 (Architectuur):**
    *   **Icoon:** `AppIcon.Sparkles`
    *   **Titel:** Architectuur & Modernisatie
    *   **Resultaat:** Legacy systemen omgezet naar modulaire Clean Architectures. **Resultaat: +60% performance, -40% codebase complexiteit.**
*   **Kaart 2 (Frontend):**
    *   **Icoon:** `AppIcon.Zap`
    *   **Titel:** Frontend Excellence
    *   **Resultaat:** Complexe Angular frontends geoptimaliseerd met NgRx (Signals) voor een consistente **95+ Lighthouse score**.
*   **Kaart 3 (Workflow):**
    *   **Icoon:** `AppIcon.Bot`
    *   **Titel:** Workflow Innovatie
    *   **Resultaat:** De "AI Specification-Driven" workflow geïmplementeerd. **Resultaat: -30% Time-to-Market voor nieuwe features.**
*   **(Logo Strip):** `[Logo Microsoft Certified]` `[Logo Scrum.org]` `[Logo's van (geanonimiseerde) top-opdrachtgevers]`

---

### **ACTE II: DE DIEPGANG (BEWIJSVOERING & CONTEXT)**
**Doel:** De beweringen uit Acte I onderbouwen met gedetailleerde, onweerlegbare case studies.

#### **2.1. Werkervaring (De STAR-Methode in Actie)**

*   **Senior Full-Stack Architect @ Royal-Code Corp.** | Utrecht | Jan 2020 – Heden
    *   *Technologieën: C#, .NET 8, Angular 18, Azure, SQL Server, NgRx, Tailwind CSS, Nx*
    *   **Situatie:** Het team worstelde met een trage, handmatige releasecyclus die de time-to-market vertraagde.
    *   **Taak:** Ontwerp en implementeer een volledige CI/CD-pipeline in Azure DevOps om de feedbackcyclus te versnellen en de betrouwbaarheid te verhogen.
    *   **Actie:** De architectuur voor een multi-stage YAML-pipeline ontworpen, inclusief geautomatiseerde unit- en E2E-tests, en de technische transitie naar een Nx monorepo geleid voor betere code-scheiding en herbruikbaarheid.
    *   **Resultaat:** **Deployment failures met 90% gereduceerd**, de **onboarding-tijd voor nieuwe developers gehalveerd** en een **kostenbesparing van €1.2M** gerealiseerd door de versnelde ontwikkeling van een intern automatiseringsplatform.

#### **2.2. Projectportfolio (Elk Project een Case Study)**

*   **Project: Royal-Code Monorepo (Dit CV!)**
    *   **De Uitdaging:** Het creëren van een dynamisch, onderhoudbaar en visueel indrukwekkend online portfolio dat niet alleen mijn ervaring toont, maar ook mijn technische vaardigheden live demonstreert.
    *   **Mijn Aanpak:** Opgezet als een enterprise-grade Nx Monorepo met strikte scheiding tussen `feature`, `data-access`, `ui` en `domain` libraries. De frontend is gebouwd met Angular (Signals, Standalone Components) en scoort consistent 95+ op Google Lighthouse. State management wordt afgehandeld door NgRx met de `createFeature` API.
    *   **Het Resultaat:** Een volledig functionele, responsive, themable en toegankelijke PWA die dient als mijn digitale visitekaartje en een showcase is van moderne Angular best practices.
    *   **Under the Hood:**
        *   `[Link]` Bekijk de State Management structuur op GitHub.
        *   `[Link]` Analyseer het Theming Systeem in de code.
    *   **Links:** `[Live Demo]` | `[Bekijk op GitHub]`

---

### **ACTE III: DE AUTORITEIT (EXPERTISE & UNIEKE WAARDE)**
**Doel:** Jezelf positioneren als een expert en innovator die verder denkt dan alleen code.

#### **3.1. Showcase: Mijn Unieke AI-Workflow**

*   **(Titel):** Case Study: Van Specificatie tot Werkende Code in 48 Uur
*   **Probleem:** Een klant had binnen zeer korte tijd een Proof-of-Concept nodig voor een complex review-systeem. De traditionele doorlooptijd was onacceptabel.
*   **Mijn Methode: De `README.md` als Technisch Contract**
    *   Ik heb een extreem gedetailleerde `README.md` geschreven die fungeerde als een "contract" voor mijn AI-codeassistent, met daarin de volledige architectuur (`Clean Architecture`), datamodellen (`NgRx Entity`), en component-API's (`Angular Standalone`).
*   **Resultaat:**
    *   Door deze specificatie als context te geven aan de AI, kon de volledige boilerplate en de basis-implementatie in een fractie van de normale tijd worden gegenereerd. Mijn rol verschoof van het schrijven van repetitieve code naar het zijn van **architect en reviewer**.
    *   **Impact:** De volledige feature was in **2 dagen** klaar voor demo, vergeleken met een geschatte 7 dagen.
    *   `[Link naar een geanonimiseerd voorbeeld van zo'n specificatie (PDF/Gist)]`

#### **3.2. Testimonials (Geloofwaardigheid door Anderen)**

*   > "Roy's AI-spec workflow verkortte onze release-cyclus met een volle sprint en verhoogde de initiële codekwaliteit significant. Een absolute game-changer voor onze time-to-market."
    > **– Jane Doe, Lead Developer @ Tech Solutions Inc.**
*   > "Zijn vermogen om complexe requirements te vertalen naar schone, schaalbare Clean Architecture is indrukwekkend. Een fantastische teamspeler met diep technisch inzicht."
    > **– John Smith, Senior Software Engineer @ Innovate Corp.**

#### **3.3. Kern-skills & Tooling (Overzicht van Expertise)**

*   **Backend:** .NET 9, ASP.NET Core, EF Core, C#, Clean Architecture, DDD, CQRS, RESTful APIs
*   **Frontend:** Angular (20+), RxJS, NgRx (Signals), TypeScript, Tailwind CSS, Standalone Components
*   **Database:** SQL Server, SQLite, PostgreSQL
*   **Cloud & DevOps:** Microsoft Azure, Azure DevOps, GitHub Actions, Docker
*   **AI & Tooling:** Prompt Engineering, Specification-Driven Development, Nx Monorepos, Git, Jest, Playwright

---

### **ACTE IV: DE AFSLUITING (PERSOONLIJKE CONNECTIE & CONVERSIE)**
**Doel:** Een blijvende, positieve indruk achterlaten en de drempel voor contact minimaliseren.

#### **4.1. De Persoon Achter de Code**

*   Buiten de wereld van code en architectuur vind ik mijn balans in strategische bordspellen en wielrennen. Deze activiteiten leren me discipline, vooruitdenken en het waarderen van een goed ontworpen systeem – principes die ik dagelijks toepas in mijn werk.

#### **4.2. De AI Avatar: De Ultieme "Closer"**

*   De `AiChatComponent` is niet zomaar een chatbot. Het is een interactieve demo, getraind op de codebase en architectuurdocumenten van dit project. Stel hem een technische vraag!
    *   *"Hoe is de state management in dit project opgezet?"*
    *   *"Wat zijn de voordelen van de Nx Monorepo structuur die je gebruikt?"*

#### **4.3. Contact & Volgende Stappen**

*   Ik sta altijd open voor een gesprek over uitdagende projecten of innovatieve ideeën. Laten we praten.
    *   **E-mail:** `[jouw-email@voorbeeld.com]`
    *   **Calendly:** `[Plan direct een gesprek in mijn agenda]`

---

## **TECHNISCHE IMPLEMENTATIEGIDS**

**Doel:** Deze gids vertaalt de contentstrategie naar concrete acties in de codebase.

### **Fase 1: Content & Model Updates (Fix at Source)**
1.  **WorkExperienceItem (`experience.model.ts`):**
    *   Voeg toe: `situationKey: string`, `taskKey: string`, `actionKey: string`, `resultKey: string`.
    *   Verwijder `summaryKey` en `highlights` en vervang deze door de nieuwe STAR-properties.
2.  **ProjectDetail (`project.model.ts`):**
    *   Hernoem `problemStatementKey` naar `challengeKey`.
    *   Voeg toe: `underTheHood?: { titleKey: string; image: Image; githubLink: string; }[]`.
3.  **Content Update (`*.json`, `*.ts` data services):**
    *   Herschrijf de content in `experience.component.ts` en `project-data.service.ts` volgens de STAR-methode en kwantificeerbare resultaten.
    *   Vul `testimonial-data.service.ts` met echte, verifieerbare testimonials.
    *   Update `cv.hero.pitch` in `en.json` en `nl.json`.

### **Fase 2: Component & Pagina Implementatie**
1.  **CvExperienceCardComponent (`experience-card.component.ts`):**
    *   Pas de template aan om de nieuwe `situationKey`, `taskKey`, `actionKey`, `resultKey` te tonen. Geef de `resultKey` visueel prioriteit (bv. met een `AppIcon.Zap` en een `text-primary` kleur).
2.  **ProjectDetailComponent (`project-detail.component.ts`):**
    *   Implementeer de "Under the Hood"-sectie door te itereren over de `underTheHood` array. Gebruik een nieuw te maken `UiCodeShowcaseComponent`.
3.  **Architectuurpagina (Nieuw):**
    *   Maak een nieuwe route `/architectuur` in `app.routes.ts`.
    *   Genereer een nieuw standalone component `apps/cv/src/app/features/architecture-page`.
    *   Gebruik `UiTitleComponent` en `UiParagraphComponent` om de principes uit `README_SHORT.md` uit te leggen. Overweeg een library als `mermaid.js` voor diagrammen.
4.  **Testimonial Sectie (Nieuw):**
    *   Gebruik `UiTestimonialCardComponent` op de `home.component.ts` om de data uit `TestimonialDataService` te tonen.

### **Fase 3: Geavanceerde Features**
1.  **AI Avatar Training:** Dit vereist een backend of een service die de content van `README_SHORT.md`, `ARCHITECTURE.MD` en de projectdata kan gebruiken als context voor de Large Language Model. De `AiChatComponent` moet deze context kunnen meesturen.
2.  **PDF Export:** Implementeer een service die een headless browser (bv. Puppeteer op een serverless functie) of een client-side library (`jsPDF`) gebruikt om een geoptimaliseerde PDF-versie te genereren.

### **Appendix: SEO & ATS Optimalisatie**
*   **Keywords:** `Angular, NgRx, .NET 9, C#, Azure, Clean Architecture, CQRS, AI Prompt Engineering, TypeScript, Tailwind CSS, Docker, Azure DevOps, GitHub Actions, Jest, xUnit, Playwright, SQL Server, SQLite, PostgreSQL, Entity Framework Core, Full-Stack, Architect, Software Engineer`
*   **JSON-LD (`index.html`):** Implementeer het `Person` schema zoals voorgesteld.


# **Het Ultieme CV Masterplan: De Definitieve Blauwdruk**
_Auteur: Royal-Code MonorepoAppDevAI_
_Document Versie: 5.0.0 (Definitief & Compleet)_

**De Filosofie: Building a Digital Metropolis with Modular Precision**

Stel je voor dat je een uitgestrekte digitale metropool bouwt. Je zou niet alles uit één gigantisch betonblok construeren. In plaats daarvan ontwerp je duidelijke districten (features), gespecialiseerde fabrieken (UI-componenten), en robuuste infrastructuur (kernservices), allemaal met elkaar verbonden via een nauwkeurig gepland netwerk. Deze metropool is gebouwd om oneindig te groeien, zich aan te passen aan nieuwe behoeften, en elk team (of elke ontwikkelaar) autonoom te laten bouwen zonder elkaars werk te belemmeren.

Deze frontend is zo'n metropool, aangedreven door de **Nx Monorepo**. Elk onderdeel is een gestandaardiseerd, onderling verbonden module, ontworpen voor extreme schaalbaarheid, onderhoudbaarheid en herbruikbaarheid. Deze gids neemt u mee op een rondleiding en legt de strategische keuzes achter de constructie uit.

---

### **Sectie 1: De Topologie - Het Monorepo Ecosysteem**

Het **Nx Monorepo** is het fundament. Het biedt een eengemaakte ontwikkelervaring voor meerdere applicaties (`apps/`) en een uitgebreide set herbruikbare bibliotheken (`libs/`). De `nx dependency-graph` bewaakt de architecturale grenzen en zorgt voor een heldere scheiding van verantwoordelijkheden.

#### **1.1. De Grote Stad: Overzicht van de Applicaties (`apps/`)**

Dit zijn de "gebouwen" in onze metropool. Elk is een complete, zelfstandige applicatie die een specifieke gebruikerservaring levert, maar deelt dezelfde onderliggende architecturale principes en veel van dezelfde bouwblokken.

*   `apps/`
    *   `admin-panel/`: Een webapplicatie voor administratie en beheer.
    *   `challenger/`: Een gamified "Real Life MMO" app.
    *   `cv/`: *Dit* interactieve portfolio dat u nu bekijkt.
    *   `plushie-paradise/`: Een e-commerce applicatie.

#### **1.2. De Leveranciers: Overzicht van de Libraries (`libs/`)**

Dit zijn de "fabrieken" en "diensten" die de gebouwen van materialen en functionaliteit voorzien. Deze worden gedeeld over meerdere apps (scope: `shared`), zijn specifiek voor bepaalde apps (scope: `plushie-paradise`, `challenger`, `admin-panel`, `cv`), of behoren tot de kerninfrastructuur (type: `core`).

```
libs/
├── auth/                 # AUTHENTICATIE: Gedeelde login/logout logic
│   ├── data-access/      # API-interactie voor auth
│   └── domain/           # Auth modellen (LoginCredentials, AuthResponse)
│
├── core/                 # KERNINFRASTRUCTUUR: Essentiële Nutsvoorzieningen voor de hele monorepo
│   ├── config/           # App-brede configuratie (API URLs, etc.)
│   ├── error-handling/   # Globale HTTP-error interceptor & state management
│   ├── http/             # HTTP utilities (bv. ETag interceptor voor caching)
│   ├── logging/          # Gestructureerde logging service
│   ├── navigation/       # Navigatie helpers (bv. BreadcrumbService)
│   ├── routing/          # Globale routes & router state models
│   └── storage/          # Veilige browser storage service (localStorage/sessionStorage)
│
├── features/             # BUSINESS-LOGICA: Opgesplitst per functionaliteit (de "districten")
│   ├── admin-products/   # Productbeheer voor Admin Panel
│   ├── cart/             # Winkelwagen functionaliteit
│   │   ├── core/         # NgRx state & facade (gedeeld over alle apps)
│   │   ├── data-access-challenger/ # API voor Challenger app
│   │   ├── data-access-plushie/    # API voor Plushie app
│   │   ├── domain/       # Winkelwagen modellen (gedeeld over alle apps)
│   │   ├── ui/           # OPTIONEEL: Algemene UI componenten *voor de cart feature* (gedeeld over apps)
│   │   ├── ui-challenger/  # UI voor Challenger app (specifiek voor die app)
│   │   └── ui-plushie/     # UI voor Plushie app (specifiek voor die app)
│   ├── media/            # Media upload/beheer
│   │   ├── core/
│   │   ├── data-access-plushie/
│   │   └── domain/
│   ├── social/           # Sociale feed functionaliteit
│   │   ├── core/
│   │   ├── data-access/
│   │   └── domain/
│   └── ... (meer features zoals products, reviews, orders, chat, users)
│
├── shared/               # ALGEMENE HELPERS: App-onafhankelijke definities en utilities
│   ├── assets/           # Gedeelde statische assets (i18n JSONs, images)
│   ├── domain/           # Gedeelde, fundamentele modellen (Profile, DateTimeInfo, AppIcon)
│   └── utils/            # Generieke utility functies (date-time-util, filter-utils, type-safety)
│
├── store/                # GLOBALE NGRX STATE: App-brede state modules
│   ├── auth/             # Authenticatie state
│   ├── error/            # Globale error state & notificaties
│   ├── theme/            # UI theme state (light/dark mode, skins)
│   └── user/             # User profile & settings state
│
└── ui/                   # GEDEELDE UI COMPONENTEN: De "Lego blokjes" van de hele metropool
    ├── button/           # Herbruikbare knop component
    ├── card/             # Generieke kaart component (bv. stat-card)
    ├── dropdown/         # Dropdown component
    ├── folder-tree/      # Component om folder structuren te visualiseren (gebruikt in dit CV!)
    ├── icon/             # Lucide icon component
    └── ... (meer algemene UI componenten zoals input, paragraph, title, media, notifications)
```

---

### **Sectie 2: Frontend Strategie: Een Schaalbaar Angular Ecosysteem**

Hier duiken we dieper in hoe een specifieke feature (`products` als voorbeeld) is gestructureerd en hoe data door de applicatie stroomt.

#### **2.1. De Anatomie van een Feature: Slice-Based Architectuur**

Elke business-functionaliteit (bv. 'products', 'cart', of 'reviews') wordt opgedeeld in een "slice" van gespecialiseerde libraries. Deze aanpak, bekend als **"Feature-Based" of "Slice-Based" architectuur**, zorgt voor maximale modulariteit en herbruikbaarheid.

**Visuele Folderstructuur van een feature (met nadruk op App-agnostisch vs. App-specifiek UI):**

```
libs/
└── features/
    └── products/
        ├── domain/           # Type: domain (rood)
        │   └── src/lib/models/product.model.ts  # 🧠 De Universele Taal (Definitie Product, Varianten)
        ├── data-access-plushie/ # Type: data-access (blauw)
        │   └── src/lib/services/plushie-product-api.service.ts # 📡 De Connector (API-calls naar Plushie Backend)
        ├── core/             # Type: feature-core (oranje)
        │   └── src/lib/state/product.feature.ts   # ⚙️ De Core Logica (NgRx State, Facade, Effects)
        ├── ui/               # Type: ui (gedeeld feature-UI, paars - **OPTIONEEL**)
        │   └── src/lib/components/product-card/product-card.component.ts # 🖼️ Feature-specifieke presentatiecomponenten (app-agnostisch)
        └── ui-plushie/       # Type: feature (groen)
            └── src/lib/pages/product-detail.component.ts # 🎨 De App-Specifieke UI (Product Detail Pagina)
```

**De Rol van Elk Library Type (met "Waarom" voor Recruiter/Hiring Manager):**

*   **`domain` (De Definities):**
    *   **Wat:** Bevat uitsluitend TypeScript interfaces, types en enums.
    *   **Waarom (Strategisch):** "Dit is onze gemeenschappelijke taal voor data. Door alles hier te definiëren, elimineren we miscommunicatie en zorgen we voor **optimale type-veiligheid** en **consistentie** door de hele applicatie heen, wat de ontwikkelingssnelheid en bugreductie ten goede komt."
*   **`data-access` (De Connectiviteit):**
    *   **Wat:** Omvat Angular Services met `HttpClient` calls, API-specifiek.
    *   **Waarom (Strategisch):** "Dit is het communicatiekanaal met de backend. De abstractie hier maakt het mogelijk om de **backend-technologie te wisselen zonder de rest van de feature aan te passen**, wat enorme flexibiliteit en **kostenbesparing** biedt bij migraties of microservices."
*   **`feature-core` (De Business Logica):**
    *   **Wat:** Huisvest alle NgRx state management logica: `Actions` (wat is er gebeurd), `Reducer` (hoe verandert de state), `Effects` (side-effects zoals API-calls), en de `Facade` (de publieke API naar de UI).
    *   **Waarom (Strategisch):** "Dit is het 'brein' van de feature. Het centraliseert alle complexe logica en databeheer. Hierdoor blijft de gebruikersinterface 'dom' en **makkelijk te testen**, en zijn state-gerelateerde problemen **snel te diagnosticeren** en op te lossen."
*   **`ui` (Shared Feature UI - **OPTIONEEL**):**
    *   **Wat:** Presentatiecomponenten specifiek voor deze feature, maar app-agnostisch (bv. een generieke `ProductCard`).
    *   **Waarom (Strategisch):** "Als we componenten nodig hebben die specifiek zijn voor een feature, maar over **meerdere applicaties** (bv. e-commerce en admin panel) hergebruikt moeten worden, plaatsen we ze hier. Dit maximaliseert **code-hergebruik** en garandeert een **consistent UI/UX** over verschillende applicaties."
*   **`feature` (of `ui-[appName]`) (De Presentatie per App):**
    *   **Wat:** "Smart" Angular componenten die specifieke applicatie-functionaliteit implementeren (bv. een productdetailpagina voor de Plushie Paradise app).
    *   **Waarom (Strategisch):** "Deze laag brengt alles samen en toont het aan de gebruiker. De scheiding zorgt ervoor dat we de **app-specifieke gebruikerservaring kunnen optimaliseren** zonder de onderliggende gedeelde logica te beïnvloeden."
*   **`ui` (Algemene Bouwstenen: `libs/ui`):**
    *   **Wat:** Algemene, app-onafhankelijke, herbruikbare "dumb" UI-componenten (knoppen, kaarten, iconen, paragrafen, titels).
    *   **Waarom (Strategisch):** "Dit is onze gedeelde 'Lego-set' van basis-UI-elementen. Het garandeert een **consistente look & feel** over alle applicaties, versnelt de ontwikkeling exponentieel en vereenvoudigt theming en toegankelijkheid."

#### **2.2. De Workflow: Van Idee tot Code met Nx Generate**

Consistentie is fundamenteel. Elke nieuwe feature wordt gestart met een serie gestandaardiseerde `nx generate` commando's. Dit is geen suggestie, maar een gedefinieerde regel binnen het project, die ervoor zorgt dat elke nieuwe feature direct in de juiste architecturale structuur past.

```powershell
# 1. Creëer de 'domain' library voor productdefinities (types)
# Dit is de fundering, gedeeld door iedereen.
npx nx g @nx/angular:library libs/features/products/domain --name=products-domain --importPath="@royal-code/features/products/domain" --tags="scope:shared,type:domain,context:products" --prefix=royal-code --strict

# 2. Creëer de 'feature-core' library voor de product business logica (NgRx state, facade)
# Het "brein" van de productfunctionaliteit, nog steeds app-onafhankelijk.
npx nx g @nx/angular:library libs/features/products/core --name=products-core --importPath="@royal-code/features/products/core" --tags="scope:shared,type:feature-core,context:products" --prefix=royal-code --strict

# 3. Creëer de 'ui' library voor SHARED feature-UI componenten (OPTIONEEL, indien nodig voor cross-app hergebruik van FEATURE-specifieke UI)
# Dit component zou bijvoorbeeld een 'ProductCard' kunnen zijn die een 'Product' domain model ontvangt en rendert.
npx nx g @nx/angular:library libs/features/products/ui --name=products-ui --importPath="@royal-code/features/products/ui" --tags="scope:shared-feature,type:ui,context:products" --prefix=royal-code --standalone --strict --style=scss

# 4. Creëer de 'data-access' library voor API-interactie (app-specifiek)
# Dit is de connector naar de specifieke backend van de Plushie Paradise app.
npx nx g @nx/angular:library libs/features/products/data-access-plushie --name=products-data-access-plushie --importPath="@royal-code/features/products/data-access-plushie" --tags="scope:plushie-paradise,type:data-access,context:products" --prefix=plushie --strict --style=scss

# 5. Creëer de 'feature' (of 'ui-[appName]') library voor de app-specifieke presentatie
# De concrete pagina's en componenten die de gebruiker daadwerkelijk ziet in Plushie Paradise.
npx nx g @nx/angular:library libs/features/products/ui-plushie --name=products-ui-plushie --importPath="@royal-code/features/products/ui-plushie" --tags="scope:plushie-paradise,type:feature,context:products" --prefix=plushie --standalone --strict --style=scss
```

#### **2.3. De Dataflow: Het Avontuur van een Klik (Visueel & Codevoorbeelden)**

Wat gebeurt er als een gebruiker op "Voeg toe aan winkelwagen" klikt op de productdetailpagina? De data volgt een strikte, voorspelbare route door onze lagen. Dit is de "reis" van data door het systeem, een essentieel concept voor ontwikkelaars.

**(Visuele Mindmap van Dataflow: UI -> Facade -> Effect -> API Service -> Mapper -> Reducer -> UI)**

```mermaid
graph TD
    A[Gebruiker klikt "Voeg toe aan Winkelwagen"] --> B(ProductDetailComponent: UI Laag);
    B --> C{Roep Facade aan: cartFacade.addItem(productId)};
    C --> D(CartFacade: Stuurt NgRx Action);
    D --> E[CartActions.addItem({ productId })];
    E --> F{CartEffects: Vangt Action op};
    F --> G[Roep Abstracte API Service aan: cartApiService.addItemToApi(productId)];
    G --> H(PlushieCartApiService: Implementeert API Call);
    H --> I{HttpClient.post() naar Backend};
    I --> J[Ruwe Backend DTO Ontvangen];
    J --> K(CartMappingService: Map DTO naar Domain Model);
    K --> L[Schone Domain Model (Cart) voor Frontend];
    L --> M{CartEffects: Dispatch Success Action};
    M --> N[CartActions.addItemSuccess({ cart })];
    N --> O(CartReducer: Update Immutable State);
    O --> P[NgRx Store (State geupdate)];
    P --> Q(CartDropdownComponent: UI Laag Reageert);
    Q --> R[Winkelwagen Icoon automatisch bijgewerkt];
```

**De Kracht van Abstractie: Verwisselbare Backends**

De `feature-core` laag, waar de `Effects` leven, heeft geen directe kennis van de backend. Het kent alleen een `AbstractCartApiService`. Hierdoor kunnen we de concrete implementatie (bijvoorbeeld voor `Plushie` of `Challenger`) wijzigen zonder dat de kernlogica verandert. Dit is het hart van ontkoppeling.

```typescript
// Het Contract (in libs/features/cart/core/src/lib/data-access/abstract-cart-api.service.ts)
// "Ik heb IETS nodig dat een item kan toevoegen, het maakt me niet uit HOE dat gebeurt."
import { Observable } from 'rxjs';
// DTO's worden hier als abstracte types gebruikt, of geïmporteerd vanuit een gezamenlijke backend.types.
interface BackendCartDto { /* ... */ }

export abstract class AbstractCartApiService {
  abstract addItemToApi(productId: string): Observable<BackendCartDto>;
}

// Implementatie A (in libs/features/cart/data-access-plushie):
// "Ik praat met de Plushie Paradise backend over /api/plushie/cart."
import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { AbstractCartApiService } from '@royal-code/features/cart/core'; // Abstractie

@Injectable()
export class PlushieCartApiService extends AbstractCartApiService {
  private readonly http = inject(HttpClient);

  addItemToApi(productId: string): Observable<BackendCartDto> {
    return this.http.post<BackendCartDto>('/api/plushie/cart', { productId });
  }
}

// Implementatie B (voor een hypothetische 'Challenger' app, in libs/features/cart/data-access-challenger):
// "Ik praat met de Challenger backend over /api/challenger/v2/basket."
import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { AbstractCartApiService } from '@royal-code/features/cart/core'; // Abstractie

@Injectable()
export class ChallengerCartApiService extends AbstractCartApiService {
  private readonly http = inject(HttpClient);

  addItemToApi(productId: string): Observable<BackendCartDto> {
    return this.http.post<BackendCartDto>('/api/challenger/v2/basket', { product_id: productId });
  }
}
```
**DTO Mapping: De Taalbrug**

Data van de API is vaak in een "backend-formaat" (DTO). De `data-access` laag is de enige plek waar deze vertaald wordt naar de schone, frontend-vriendelijke `domain` modellen. Dit voorkomt dat componenten of de state-logica vervuild raken met backend-specifieke details.

```typescript
// Voorbeeld Backend DTO (wat de API teruggeeft)
// In: libs/features/products/core/src/lib/DTO/backend.types.ts
interface BackendProductDto {
  Id: string;
  Name: string;
  CurrentPrice: number;
  StockStatus: number; // bv. 0 = InStock, 1 = OutOfStock
}

// Voorbeeld Frontend Domain Model (wat de app gebruikt)
// In: libs/features/products/domain/src/lib/models/product.model.ts
interface Product {
  id: string;
  name: string;
  price: number;
  isInStock: boolean;
}

// De mapping logica (in een Mappers/Service: bv. libs/features/products/core/src/lib/mappers/product-mapping.service.ts)
// "Vertaal de onbewerkte backend data naar onze schone frontend taal."
import { Injectable } from '@angular/core';
import { Product } from '@royal-code/features/products/domain'; // Frontend Domain
import { BackendProductDto } from '../DTO/backend.types'; // Backend DTO

@Injectable()
export class ProductMappingService {
  mapProduct(dto: BackendProductDto): Product {
    return {
      id: dto.Id,
      name: dto.Name,
      price: dto.CurrentPrice,
      isInStock: dto.StockStatus === 0 // Business logic voorradig
    };
  }
}
```

---

### **Sectie 3: Backend Strategie: De Fort van Logica (Clean Architecture)**

De frontend-filosofie van "scheiding van verantwoordelijkheden" wordt 1-op-1 gespiegeld in de .NET backend, gebaseerd op de **Clean Architecture**. Dit zorgt voor een conceptuele symmetrie tussen de twee ecosystemen.

**Visuele Folderstructuur van de Backend:**

```
src/
├── Domain          # Het Hart: Entiteiten, Enums, Exceptions. Geen externe afhankelijkheden.
│   └── Entities    # bv. Product.cs, Review.cs
├── Application     # De Dirigent: Use cases & business rules. Definieert contracten (interfaces).
│   ├── Products
│   │   ├── Commands  # bv. CreateProductCommandHandler
│   │   └── Queries   # bv. GetProductByIdQueryHandler
│   └── Common
│       └── Interfaces # bv. IProductRepository.cs
├── Infrastructure  # De Werkers: Implementatie van contracten. Hier zit de database (EF Core).
│   ├── Data          # EF Core DbContext & Repositories
│   └── Identity      # ASP.NET Core Identity implementatie
└── Web             # De Poort: Het toegangspunt (ASP.NET Core API).
    └── Endpoints     # Minimal API endpoints die de Application laag aanroepen.
```

**De Afhankelijkheidsregel in Actie (Codevoorbeeld):**

Het kernprincipe van Clean Architecture is de **Afhankelijkheidsregel**: alle afhankelijkheden wijzen naar binnen, richting het `Domain`. De `Domain`-laag, het hart van de business, heeft geen enkele kennis van externe systemen zoals databases of API's. Dit garandeert dat de kernlogica robuust en gemakkelijk te testen is.

```csharp
// Application Layer (het "wat" - definieert de behoefte)
// In: Application/Common/Interfaces/IProductRepository.cs
// "De business logic heeft een manier nodig om producten op te halen,
// maar het maakt niet uit HOE dat gebeurt (SQL, Mongo, etc.)."
public interface IProductRepository {
    Task<Product?> GetByIdAsync(Guid id, CancellationToken cancellationToken);
}

// Infrastructure Layer (het "hoe" - implementeert de behoefte)
// In: Infrastructure/Data/ProductRepository.cs
// "Ik weet HOE ik producten moet ophalen: met Entity Framework Core
// uit een SQL database. Ik voldoe aan het contract van de Application laag."
public class ProductRepository : IProductRepository {
    private readonly ApplicationDbContext _context;
    // Constructor voor Dependency Injection
    public ProductRepository(ApplicationDbContext context) {
        _context = context;
    }
    public async Task<Product?> GetByIdAsync(Guid id, CancellationToken cancellationToken) {
        return await _context.Products.FindAsync(new object[] { id }, cancellationToken);
    }
}
```
**Het Resultaat:** De `Application` laag en de business logic zijn volledig onafhankelijk van het `Infrastructure` detail. De database-provider kan gewisseld worden zonder de kernlogica te beïnvloeden.

---

### **Sectie 4: De Nutsvoorzieningen - Kernservices & Cross-Cutting Concerns**

De `core/` library en globale NgRx-modules bevatten essentiële, applicatie-brede services die de robuustheid en consistentie garanderen. Deze "nutsbedrijven" werken op de achtergrond en zorgen dat de hele metropool soepel draait.

*   **Globale State (`store/`):**
    *   **`auth/`:** Beheert de authenticatiestatus (ingelogd/uitgelogd), tokens, en het profiel van de ingelogde gebruiker. Essentieel voor gepersonaliseerde content en beveiligde routes.
    *   **`theme/`:** Controleert het actieve thema (light/dark mode, skins) en synchroniseert dit met `localStorage`. Zorgt voor een consistente en aanpasbare gebruikerservaring.
    *   **`error/`:** Een centrale plek voor alle applicatie-fouten. De `global-error.interceptor` vangt HTTP-fouten af en dispatcht acties, waardoor errors voorspelbaar worden beheerd en getoond aan de gebruiker.
*   **`LoggerService` (`core/logging`):** Een gestructureerde logging-service met configureerbare log-levels (Debug, Info, Warn, Error), die ook naar een externe service kan loggen in productie. Cruciaal voor monitoring en diagnose.
*   **`StorageService` (`core/storage`):** Een veilige wrapper rondom `localStorage` en `sessionStorage`, die zorgt voor SSR-compatibiliteit en gestructureerde data-opslag. Voorkomt direct `window`-object gebruik.
*   **`HttpInterceptors` (`core/http`, `core/error-handling`):** Centraal beheer van HTTP-requests.
    *   **`AuthInterceptor`:** Voegt automatisch JWT-tokens toe aan uitgaande requests, waardoor authenticatie transparant is voor services.
    *   **`EtagInterceptor`:** Implementeert slimme client-side caching (304 Not Modified) om onnodige data-overdracht te voorkomen, wat resulteert in snellere laadtijden en minder belasting van de backend.
    *   **`GlobalErrorInterceptor`:** Vangt alle HTTP-errors af op één centrale plek en dispatcht globale error-notificaties naar de `error` store. Zorgt voor een uniforme en robuuste foutafhandeling.

---

### **Sectie 5: Code Kwaliteit & Ontwikkelpraktijken**

Deze architectuur faciliteert en moedigt een hoge standaard van codekwaliteit en efficiënte ontwikkelpraktijken aan.

*   **Type Safety (`strictTypeSafety`):** Overal wordt strikt TypeScript gebruikt. Het vermijden van `any` en het consistent toepassen van `domain` modellen zorgt voor minder runtime bugs en betere tooling support.
*   **DRY (Don't Repeat Yourself):** Herbruikbare componenten (`libs/ui`), gedeelde logica (`feature-core`) en geabstraheerde services elimineren redundantie, wat de codebase kleiner en consistenter maakt.
*   **Clean Code & Leesbaarheid:** Strikte naamgevingsconventies, kleine, gefocuste functies (Single Responsibility Principle) en gestructureerde comments maken de code makkelijk leesbaar en onderhoudbaar, zelfs voor nieuwe teamleden.
*   **Commentaarstrategie:** Een gelaagde commentaarstrategie (Enterprise Comments) zorgt voor duidelijke documentatie van publieke API's (JSDoc/TSDoc) en complexe logica, zonder zelf-evidente code te vervuilen.
*   **AI-Assisted Development:** Integratie van AI-tools in de ontwikkelworkflow voor het genereren van boilerplate code en het afdwingen van architecturale standaarden (zoals gedemonstreerd in de "AI Specification-Driven Bot" case study). Dit versnelt de ontwikkeling en vermindert initiële fouten.

---

### **Sectie 6: Performance & Veerkracht**

De architectuur is ontworpen met performance en resilience in gedachten, zowel aan de frontend als de backend.

*   **Frontend Optimalisatie:**
    *   **Lazy Loading (`@defer` & `loadChildren`):** Code wordt pas geladen wanneer deze nodig is, wat de initiële laadtijden drastisch verlaagt (Fast First Contentful Paint).
    *   **Image Optimization (`UiImageComponent`):** Gestandaardiseerd gebruik van een geoptimaliseerde afbeeldingscomponent die responsive `srcset` en `sizes` ondersteunt, lazy loading, en moderne formaten (WebP, AVIF).
    *   **Change Detection (`OnPush` & Signals):** Efficiënte updatecycli door `ChangeDetectionStrategy.OnPush` en de Angular Signals API, minimaliseren onnodige re-renders.
    *   **Memoization (`computed` & NgRx Selectors):** Herberekeningen van afgeleide data worden gecached, waardoor de applicatie responsief blijft, zelfs met complexe datatransformaties.
*   **Backend Resilience & Schaalbaarheid:**
    *   **Request Annulering (`CancellationToken`):** Backend-operaties (vooral databasequeries) respecteren annuleringstekens van de frontend, wat onnodig resourceverbruik voorkomt bij afgebroken requests (bv. door navigatie).
    *   **Asynchrone & Non-Blocking Operaties:** Overal wordt `async/await` gebruikt voor I/O-gebonden operaties, waardoor de server responsief blijft onder hoge belasting.
    *   **Globale Exception Middleware:** Uniforme afhandeling van onverwachte backend-fouten, retournerend gestructureerde `ProblemDetails` aan de frontend.

---

### **Conclusie: Gebouwd voor de Toekomst**

Deze architectuur, met zijn strikte scheiding van verantwoordelijkheden, focus op modulariteit en consistentie, is ontworpen om elke digitale uitdaging aan te gaan. Het is een flexibel, schaalbaar en onderhoudbaar ecosysteem dat klaar is voor de toekomst – of het nu een nieuwe applicatie, een andere backend, of een compleet nieuwe feature betreft.